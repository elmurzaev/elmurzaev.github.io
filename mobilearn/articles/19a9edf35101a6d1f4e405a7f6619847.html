<!DOCTYPE html>
<html>
<head>

    <title> Лекция 2. Операторы языка С++. Структура программы</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<section id="l2_1">
    <h1> 1. Операторы языка C++ </h1>
    <p>
        Операторы управляют процессом выполнения программы. Набор операторов языка <span>С++</span>
        содержит все управляющие конструкции структурного программирования.
    </p>
    <p>
        Составной оператор ограничивается фигурными скобками. Все другие операторы заканчиваются
        точкой с запятой.
    </p>
    <ul>
        <li id="l2_vuoto">
            <b>Пустой оператор – <span class="sint"> ; </span></b>
            <p>
                Пустой оператор – это оператор, состоящий только из точки с запятой. Он может
                появиться в любом месте программы, где по синтаксису требуется оператор. Выполнение
                пустого оператора не меняет состояния программы.
            </p>
        </li>
        <li id="l2_complesso">
            <b>Составной оператор – <span class="sint"> {...}</span></b>
            <p>
                Действие составного оператора состоит в последовательном выполнении содержащихся в
                нем операторов, за исключением тех случаев, когда какой-либо оператор явно передает
                управление в другое место программы.
            </p>
        </li>
        <li id="l2_try"><b>Оператор обработки исключений</b>
            <span class="sint">
  <b>try</b> { <i>&lt;операторы&gt;</i> }
  <b>catch</b> (<i>&lt;объявление исключения&gt;</i>) { <i>&lt;операторы&gt;</i> }
  <b>catch</b> (<i>&lt;объявление исключения&gt;</i>) { <i>&lt;операторы&gt;</i> }
  <b>...</b>
  <b>catch</b> (<i>&lt;объявление исключения&gt;</i>) { <i>&lt;операторы&gt;</i> }
 </span>

        </li>
        <li id="l2_if"><b>Условный оператор</b>
            <span class="sint">
  <b>if</b> (<i>&lt;выражение&gt;</i>) <i>&lt;оператор 1&gt;</i> [<b>else</b> <i>&lt;оператор 2&gt;</i>]
 </span>

        </li>
        <li id="l2_switch"><b>Оператор-переключатель</b>
            <span class="sint">
  <b>switch</b> (<i>&lt;выражение&gt;</i>)
    { <b>case</b> <i>&lt;константное выражение 1&gt;</i>: <i>&lt;операторы 1&gt;</i>
       <b>case</b> <i>&lt;константное выражение 2&gt;</i>: <i>&lt;операторы 2&gt;</i>
       <b>...</b>
       <b>case</b> <i>&lt;константное выражение N&gt;</i>: <i>&lt;операторы N&gt;</i>
       [<b>default</b>: <i>&lt;операторы&gt;</i>]
      } </span>

            <p>
                Оператор-переключатель предназначен для выбора одного из нескольких альтернативных
                путей выполнения программы. Вычисление оператора-переключателя начинается с
                вычисления <i>выражения</i>, после чего управление передается <i>оператору</i>,
                помеченному <i>константным выражением</i>, равным вычисленному значению
                <i>выражения</i>. Выход из оператора-переключателя осуществляется оператором <span
                    class="keys">break</span>. Если значение <i>выражения</i> не равно ни одному <i>константному
                выражению</i>, то управление передается <i>оператору</i>, помеченному ключевым
                словом <i>default</i>, если он есть.
            </p>
        </li>
        <li id="l2_while"><b>Оператор цикла с предусловием</b>
            <span class="sint">
  <b>while</b> (<i>&lt;выражение&gt;</i>) <i>&lt;оператор&gt;</i>
 </span>

        </li>
        <li id="l2_do"><b>Оператор цикла с постусловием</b>
            <span class="sint">
  <b>do</b> <i>&lt;оператор&gt;</i> <b>while</b> <i>&lt;выражение&gt;</i>; </span>

            <p>
                В языке C++ этот оператор отличается от классической реализации цикла с постусловием
                тем, что при истинности <i>выражения</i> происходит продолжение работы цикла, а не
                выход из цикла.
            </p>
        </li>
        <li id="l2_for"><b>Оператор пошагового цикла</b>
            <span class="sint">
  <b>for</b> ([<i>&lt;начальное выражение&gt;</i>];
         [<i>&lt;условное  выражение&gt;</i>];
         [<i>&lt;выражение приращения&gt;</i>])
      <i>&lt;оператор&gt;</i> </span>

            <p>
                Тело оператора <span class="keys">for</span> выполняется до тех пор, пока <i>условное
                выражение</i> не станет ложным (равным 0). <i>Начальное выражение</i> и <i>выражение
                приращения</i> обычно используются для инициализации и модификации параметров цикла
                и других значений. <i>Начальное выражение</i> вычисляется один раз до первой
                проверки <i>условного выражения</i>, а <i>выражение приращения</i> вычисляется после
                каждого выполнения <i>оператора</i>. Любое из трех выражений заголовка цикла, и даже
                все три могут быть опущены (не забывайте только оставлять точки с запятой). Если
                опущено <i>условное выражение</i>, то оно считается истинным, и цикл становится
                бесконечным.
            </p>
            <p>
                Оператор пошагового цикла в языке <span>С++</span> является гибкой и удобной
                конструкцией, поэтому оператор цикла с предусловием <span class="keys">while</span>
                используется в языке <span>С++</span> крайне редко, т.к. в большинстве случаев
                удобнее пользоваться оператором <span class="keys">for</span>.
            </p>
        </li>
        <li id="l2_break"><b>Оператор разрыва
            <span class="sint">
break</span></b>;
            <p>
                Оператор разрыва прерывает выполнение операторов <span class="keys">while</span>,
                <span class="keys">do</span>, <span class="keys">for</span> и <span class="keys">switch</span>.
                Он может содержаться только в теле этих операторов. Управление передается оператору
                программы, следующему за прерванным. Если оператор разрыва записан внутри вложенных
                операторов <span class="keys">while</span>, <span class="keys">do</span>, <span
                    class="keys">for</span>, <span class="keys">switch</span>, то он завершает
                только непосредственно охватывающий его оператор.
            </p>
        </li>
        <li id="l2_continue"><b>Оператор продолжения
            <span class="sint">
continue</span></b>;
            <p>
                Оператор продолжения передает управление на следующую итерацию в операторах цикла
                <span class="keys">while</span>, <span class="keys">do</span>, <span class="keys">for</span>.
                Он может содержаться только в теле этих операторов. В операторах <span class="keys">do</span>
                и <span class="keys">while</span> следующая итерация начинается с вычисления
                условного выражения. В операторе <span class="keys">for</span> следующая итерация
                начинается с вычисления выражения приращения, а затем происходит вычисление
                условного выражения.
            </p>
        </li>
        <li id="l2_return"><b>Оператор возврата</b>
            <span class="sint">
  <b>return</b> [<i>&lt;выражение&gt;</i>]; </span>

            <p>
                Оператора возврата заканчивает выполнение функции, в которой он содержится, и
                возвращает управление в вызывающую функцию. Управление передается в точку вызывающей
                функции, непосредственно следующую за оператором вызова. Значение <i>выражения</i>,
                если она задано, вычисляется, приводится к типу, объявленному для функции,
                содержащей оператор возврата, и возвращается в вызывающую функцию. Если
                <i>выражение</i> опущено, то возвращаемое функцией значение не определено.
            </p>
            <p>
                С формальной точки зрения операторы <span class="keys">break</span>, <span
                    class="keys">continue</span> и <span class="keys">return</span> не являются
                операторами структурного программирования. Однако их использование в ограниченных
                количествах оправдано, когда они упрощают понимание программы и позволяют избегать
                больших вложенных структур. Например, мы проверяем входные данные на аномалии. Если
                не использовать эти операторы, то всю обработку придется вложить в условный блок,
                что ухудшает читабельность программы. Вместо этого можно написать небольшой условный
                блок, который организует выход из функции при неверных исходных данных.
            </p>
        </li>
    </ul>
    <p>
        <b> Ввод/вывод </b> не является частью языка <span>С++</span>, а осуществляется функциями,
        входящими в состав стандартной библиотеки. Для подробной информации см. .
    </p></section>
<section id="l2_2">
    <h1> 2. Структура программы </h1>
    <p>
        Программа на языке <span>С++</span> состоит из ,
        указаний компилятору, объявлений , объявлений и определений .
    </p>
    <h2 id="l2_2_2">2.1. Объявление переменной </h2>
    <p id="l2_ini">
        Объявление переменной задаёт имя и атрибуты переменной. Атрибутами переменной могут быть ,
        количество элементов (для ), , а также <i>инициализатор</i>. <b>Инициализатор</b> – это
        константа соответствующего типа, задающая значение, которое присваивается переменной при
        создании.
    </p>
    <p>
        Объявление переменной имеет следующий синтаксис:
        <span class="sint">
 [<i>&lt;спецификация класса памяти&gt;</i>] <i>&lt;тип&gt;</i> <i>&lt;имя&gt;</i> [= <i>&lt;инициализатор&gt;</i>]
                                                              [,<i>&lt;имя&gt;</i> [= <i>&lt;инициализатор&gt;</i>] <b>...</b>];
</span>
    </p>
    <p>
        <b> Примеры объявления переменных </b>
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> x;
            </td>
            <td class="commenti">// Объявление переменной целого типа без инициализатора</td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">double</span> y = exp(1);
            </td>
            <td class="commenti">// Переменная вещественного типа инициализируется числом e.
                // exp(x) – функция, вычисляющая e<sup>x</sup>.
            </td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> a, b = 0;
            </td>
            <td class="commenti">// Объявление двух переменных целого типа. Переменная <var>b</var>
                инициализируется значением 0.
            </td>
        </tr>
    </table>
    <p>
        В языке С++ нет ограничений на количество символов в имени. Однако некоторые части
        реализации (в частности, компоновщик) недоступны автору компилятора, и они иногда
        накладывают такие ограничения.
    </p>
    <h3 id="l2_2_2_1"> 2.1.1. Константы</h3>
    <p>
        В языке С++ введена концепция определяемых пользователем констант для указания на то, что
        значение нельзя изменить непосредственно. Это может быть полезно в нескольких отношениях.
        Например, многие объекты не меняются после инициализации; использование символических
        констант приводит к более удобному в сопровождении коду, чем применение литералов
        непосредственно в тексте программы; указатели часто используются только для чтения, но не
        для записи; большинство параметров функций читаются, но не перезаписываются.
    </p>
    <p>
        Чтобы объявить объект константой, в объявление нужно добавить ключевое слово <i>const</i>.
        Так как константе нельзя присваивать значения, она должна быть инициализирована.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">const int</span> a = 100;
                <span class="chiavi">const int</span> b[] = {1, 2, 3, 4, 5};
                <span class="chiavi">const int</span> c;
            </td>
            <td class="commenti">// <var>a</var> является константой
                // Все <var>b[i]</var> являются константами
                // Ошибка – нет инициализатора!
            </td>
        </tr>
    </table>
    <p>
        Типичным является использование констант в качестве размера массивов и меток в инструкции
        <i>case</i>.
    </p>
    <p>
        Отметьте, что <i>const</i> модифицирует тип, т.е. ограничивает возможное использование
        объекта, но не указывает способ размещения константного объекта. Простым и типичным
        использованием константы является тот случай, когда значение константы известно во время
        компиляции и под неё не требуется выделение памяти. Для массива констант, как правило,
        требуется выделение памяти, так как, в общем случае, компилятор не в состоянии определить, к
        какому элементу массива происходит обращение в выражении.
    </p>
    <h3 id="l2_2_2_2">2.1.2. Объявление <i>typedef</i></h3>
    <p>
        Объявление, начинающееся с ключевого слова <i>typedef</i>, вводит новое имя для типа, не для
        переменной данного типа. Целью такого объявления часто является назначение короткого
        синонима для часто используемого типа. Например, при частом применении <span class="type">unsigned char</span>
        можно ввести синоним <span class="type">uchar</span>.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">typedef unsigned char</span> uchar;
            </td>
            <td class="commenti">// Теперь <span class="type">uchar</span> – синоним для <span
                    class="type">unsigned char</span></td>
        </tr>
    </table>
    <p>
        Имена, вводимые с помощью <i>typedef</i>, являются <b>синонимами, а не новыми типами</b>.
        Следовательно, старые типы можно использовать совместно с их синонимами. Если вам нужны
        различные типы с одинаковой семантикой или с одинаковым представлением, обратитесь к или .
    </p>
    <h2 id="l2_2_1">2.2. Объявление и определение функции </h2>
    <p>
        Объявление функции задаёт имя функции, тип возвращаемого значения и количество и типы
        параметров, которые должны присутствовать при вызове функции. Указание <span class="type">void</span>
        в качестве возвращаемого значения означает, что функция не возвращает значения.
    </p>
    <p>
        Определением функции является объявление функции, в котором присутствует тело функции.
        Определение функции имеет следующий синтаксис:
        <span class="sint">
<i>&lt;тип&gt;</i> <i>&lt;имя&gt;</i> <b>(</b><i>&lt;список формальных параметров&gt;</i><b>)</b>
 <b>{</b>
      [<i>&lt;объявления&gt;</i>]
      [<i>&lt;операторы&gt;</i>]
  <b>}</b>
</span>
    </p>
    <p>
        Типы в определении и объявлениях функции должны совпадать. Однако, имена параметров не
        являются частью типа и не обязаны совпадать.
    </p>
    <p>
        <b>Все функции в программе существуют на глобальном уровне и не могут быть вложены друг в
            друга.</b>
    </p>
    <p id="l2_main">
        Среди функций выделяется одна главная функция, которая должна иметь имя <i>main</i>. С нее
        начинается выполнение программы, обычно она управляет выполнением программы, организуя
        вызовы других функций. Для того чтобы программа могла быть скомпилирована и выполнена, она
        должна содержать, по крайней мере, определение функции <i>main</i>.
    </p>
    <p>
        <b>Примеры определения функции</b>
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">double</span> Cube(<span class="chiavi">double</span> x);
            </td>

            <td class="commenti">// // Объявление (прототип) функции
            </td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">void</span> main()
                {
                printf("%lf\n", Cube(5));
                }
            </td>

            <td class="commenti">// Главная функция программы, которая печатает 5<sup>3</sup></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">double</span> Cube(<span class="chiavi">double</span> x)
                {
                <span class="chiavi">return</span> x * x * x;
                }
            </td>

            <td class="commenti">// Функция одного вещественного аргумента, которая возвращает
                вещественное значение,
                // равное кубу аргумента
            </td>
        </tr>
    </table>
    <p>
        При вызове функции выделяется память под её формальные параметры, и каждому формальному
        параметру присваивается значение соответствующего фактического параметра. Семантика передачи
        параметров идентична семантике инициализации. В частности, проверяется соответствие типов
        формальных и фактических параметров и при необходимости выполняются либо стандартные, либо
        определённые пользователем преобразования типов. Существуют специальные правила для , , и .
    </p>
    <p>
        Функция должна возвращать значение, если она не объявлена как <span class="type">void</span>.
        И наоборот – значение не может быть возвращено из функции, если она объявлена как <span
            class="type">void</span>. Как и передача параметров, семантика возврата значения из
        функции идентична семантике инициализации. Возвращаемое значение задаётся инструкцией <span
            class="keys">return</span>.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span>  f1() { }
                <span class="chiavi">void</span> f2() { }
            </td>
            <td class="commenti">// Ошибка – не возвращается значение
                // Правильно
            </td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> f3() { <span class="chiavi">return</span> 1; }
                <span class="chiavi">void</span> f4() { <span class="chiavi">return</span> 1; }
            </td>
            <td class="commenti">// Правильно
                // Ошибка – значение возвращается в функции <span class="type">void</span>
            </td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span>  f5() { <span class="chiavi">return</span>; }
                <span class="chiavi">void</span> f6() { <span class="chiavi">return</span>; }
            </td>
            <td class="commenti">// Ошибка – не указано возвращаемое значение
                // Правильно
            </td>
        </tr>
    </table>
    <p>
        Функция с типом <span class="type">void</span> не может возвращать значение. Однако вызов
        функции с типом <span class="type">void</span> не даёт значения, так что функция с типом
        <span class="type">void</span> может использовать вызов функции с типом <span class="type">void</span>
        как выражение в инструкции <span class="keys">return</span>.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">void</span> g() { ... }
                <span class="chiavi">void</span> h() { <span class="chiavi">return</span> g(); }
            </td>
            <td class="commenti">
                // Правильно
            </td>
        </tr>
    </table>
    <p>
        Такая форма инструкции <span class="keys">return</span> важна при написании , когда тип
        возвращаемого значения является параметром шаблона.
    </p>
    <h3 id="l2_2_1_1">2.2.1. Встраиваемые функции</h3>
    <p>
        Функцию можно определить со спецификатором <i>inline</i>. Такие функции называются <i>встраиваемыми</i>.
        Спецификатор <i>inline</i> указывает компилятору, что открытая подстановка тела функции
        предпочтительнее обычной реализации вызова функции и что он должен пытаться каждый раз
        генерировать в месте вызова код, соответствующий встраиваемой функции, а не создавать
        отдельно код функции (однократно) и затем вызывать её посредством обычного механизма вызова.
        Спецификатор <i>inline</i> не оказывает влияния на смысл вызова функции.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">inline int</span> max(<span class="chiavi">int</span> x, <span
                    class="chiavi">int</span> y) { <span class="chiavi">return</span> x &gt; y ? x :
                y; }
            </td>
        </tr>
    </table>
    <p>
        Открытая подстановка не влияет на результаты вызова функции, чем отличается от .
        Встраиваемая функция имеет обычный синтаксис описания функции и подчиняется всем правилам,
        касающимся и контроля типов. Открытая подстановка является просто иной реализацией вызова
        функции. Вместо генерации кода, передающего управление и параметры единственному экземпляру
        тела функции, копия тела функции, соответственно модифицированная, помещается на место
        вызова. Это экономит время для передачи управления.
    </p>
    <p>
        Для всех, кроме простейших, функций время выполнения функций доминирует над издержками
        времени на обслуживание вызова. Из этого следует, что для всех, кроме простейших, функций
        экономия за счёт открытой подстановки минимальна. Идеальным кандидатом для открытой
        подстановки является функция, делающая нечто простое, вроде увеличения или возврата
        значения. Существование таких функций вызывается необходимостью обработки .
    </p>
    <h3 id="l2_2_1_2">2.2.2. Параметры функций по умолчанию</h3>
    <p>
        В языке С++ можно задавать так называемые <b>параметры функции по умолчанию</b>. Если в
        объявлении формального параметра задано выражение, то оно воспринимается как умолчание этого
        параметра. Все последующие параметры также должны иметь умолчания. Умолчания параметров
        подставляются в вызов функции при отсутствии в нём последних по списку параметров.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> g(<span class="chiavi">int</span> m = 1, <span
                    class="chiavi">int</span> n);
                <span class="chiavi">int</span> h(<span class="chiavi">int</span> m = 1, <span
                    class="chiavi">int</span> n = 2);
                <span class="chiavi">int</span> h(<span class="chiavi">int</span> m = 1, <span
                    class="chiavi">int</span> n = 2) { ... }
                <span class="chiavi">int</span> h(<span class="chiavi">int</span> m = 0, <span
                    class="chiavi">int</span> n = 0) { ... }
                <span class="chiavi">int</span> f(<span class="chiavi">int</span> m = 1, <span
                    class="chiavi">int</span> n = 2);
                <span class="chiavi">int</span> f(<span class="chiavi">int</span> m , <span
                    class="chiavi">int</span> n) { ... }
                f(5, 6);
                f(5);
                f();
            </td>

            <td class="commenti">// Ошибка
                // Правильно
                // Ошибка – повтор параметров по умолчанию
                // Ошибка – изменение параметров по умолчанию
                // Правильно
                // Вызов функции с двумя параметрами
                // Эквивалентно вызову f(5, 2);
                // Эквивалентно вызову f(1, 2);
            </td>
        </tr>
    </table>
    <h3 id="l2_2_1_3">2.2.3. Параметры программы</h3>
    <p>
        Функция <i>main</i>, как и любая другая функция может иметь параметры. Эти параметры
        передаются в программу из командной строки.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">void</span> main(<span class="chiavi">int</span> argc, <span
                    class="chiavi">char</span> *argv[])
                { ... }
            </td>
            <td class="commenti">// Имена <var>argc</var> и <var>argv</var> не являются требованием
                языка
            </td>
        </tr>
    </table>
    <p>
        Первый параметр содержит количество элементов в массиве – втором параметре, который является
        массивом указателей на строки. Каждая строка хранит один переданный программе параметр, при
        этом первый параметр (с индексом 0) содержит имя исполняемого файла и существует всегда.
        Порядок объявления параметров существенен.
    </p>
    <h3 id="l2_2_1_4">2.2.4. Функции с переменным числом параметров</h3>

    <p>
        В языке С++ существует возможность использовать функции с <i>переменным числом
        параметров</i>. Для объявления такой функции надо указать многоточие (,…) в конце списка
        параметров функции. Для вызова такой функции не требуется никаких специальных действий,
        просто задается столько параметров, сколько нужно.
    </p>
    <p>
        Во время интерпретации списка параметров такая функция пользуется информацией, не доступной
        компилятору. Поэтому он не в состоянии гарантировать, что ожидаемые параметры действительно
        присутствуют или что они имеют правильные типы. Ясно, что если параметр не был объявлен,
        компилятор не имеет информации, необходимой для выполнения стандартной проверки и
        преобразований типа.

    </p>
    <p>
        Функцию только с необъявленными параметрами, в принципе, определить можно, но выбрать
        параметры будет затруднительно, т.к. макроопределения для работы с необъявленными
        параметрами используют имя последнего объявленного формального параметра.

    </p>
    <p>
        Внутри функции программист сам отвечает за выбор из стека дополнительных параметров. Для
        работы с ними используются макроопределения <span class="sint">va_arg</span>, <span
            class="sint">va_start</span> и <span class="sint">va_end</span>, определённые в файле
        <span class="sint">stdarg.h</span>.

    </p>
    <p>
        Пример программы с функцией с перменным числом параметров см. .
    </p>
    <h2 id="l2_2_3">2.3. Препроцессор </h2>
    <p>
        <b>Препроцессор</b> – это программа, которая обрабатывает текст вашей программы до
        компилятора. Таким образом, на вход компилятора попадает текст, который может отличаться от
        того, который видите Вы. Работа препроцессора управляется директивами. С помощью
        препроцессора можно выполнять следущие операции:
    </p>
    <ul>
        <li> ;
        </li>
        <li> ;
        </li>
        <li> , т.е. замена обозначения параметризованным текстом, формируемым препроцессором с
            учетом конкретных аргументов;
        </li>
        <li> исключение из программы отдельных частей текста ().
        </li>
    </ul>
    <h3 id="l2_2_3_1">2.3.1. Включение файлов</h3>
    <p>
        Включение файлов производиться с помощью директивы <i>#include</i>, которая имеет следующий
        синтаксис:
        <span class="sint">
<b>#include</b> <i>&lt;путь&gt;</i>
<b>#include</b> <i>"путь"</i>
</span>
    </p>
    <p>
        Угловые скобки здесь являются элементом синтаксиса.
    </p>
    <p>
        Директива <i>#include</i> включает содержимое файла, путь к которому задан, в компилируемый
        файл вместо строки с директивой. Если путь заключен в угловые скобки, то поиск файла
        осуществляется в стандартных директориях. Если путь заключен в кавычки и задан полностью, то
        поиск файла осуществляется в заданной директории, а если путь полностью не задан – в текущей
        директории. С помощью это директивы Вы можете включать в текст программы как стандартные,
        так и свои файлы.
    </p>
    <p>
        Во включаемый файл можно поместить, например, общие для нескольких исходных файлов
        определения именованных констант и макроопределения. Включаемые файлы используются также для
        хранения объявлений внешних переменных и абстрактных типов данных, разделяемых несколькими
        исходными файлами. Более подробную информацию об использовании заголовочных файлов см. .
    </p>
    <p>
        Кроме того, как было указано выше, в языке <span>С++</span> ряд функций, такие как функции
        ввода/вывода, динамического распределения памяти и т.д., не являются элементом языка, а
        входят в стандартные библиотеки. Для того чтобы пользоваться функциями стандартных
        библиотек,
        необходимо в текст программы включать так называемые заголовочные файлы (в описании каждой
        функции указывается, какой заголовочный файл необходим для неё). Это также делается с
        помощью директивы препроцессора <i>#include</i>.
    </p>
    <p>
        Директива <i>#include</i> может быть вложенной. Это значит, что она может встретиться в
        файле, включенном другой директивой <i>#include</i>. Допустимый уровень вложенности директив
        <i>#include</i> зависит от реализации компилятора.
    </p>
    <h3 id="l2_2_3_2">2.3.2. Макроподстановки</h3>
    <p>
        Макроподстановки реализуются директивой <i>#define</i>, которая имеет следующий синтаксис:
        <span class="sint">
<b>#define</b> <i>&lt;идентификатор&gt;</i> <i>&lt;текст&gt;</i> 
<b>#define</b> <i>&lt;идентификатор&gt;</i>(<i>&lt;список параметров&gt;</i>) <i>&lt;текст&gt;</i> 
</span>
    </p>
    <p>
        Директива <i>#define</i> заменяет все вхождения <i>идентификатора</i> в исходном файле на
        <i>текст</i>, следующий в директиве за <i>идентификатором</i>. Этот процесс называется
        макроподстановкой. <i>Идентификатор</i> заменяется лишь в том случае, если он представляет
        собой отдельную лексему. Например, если <i>идентификатор</i> является частью строки или
        более длинного идентификатора, он не заменяется.
    </p>
    <p>
        <i>Текст</i> представляет собой набор лексем, таких как ключевые слова, константы,
        идентификаторы или выражение. Один или более пробельных символов должны отделять
        <i>текст</i> от <i>идентификатора</i> (или от заключённых в скобки параметров). Если <i>текст</i>
        не умещается на строке, то он может быть продолжен на следующей строке, для этого следует
        набрать в конце строки символ «обратный слэш» и сразу за ним нажать клавишу «ВВОД».
    </p>
    <p>
        <i>Текст</i> может быть опущен. В этом случае все экземпляры <i>идентификатора</i> будут
        удалены из исходного текста программы. Тем не менее, сам <i>идентификатор</i>
        рассматривается как определённый.
    </p>
    <p>
        <i>Список параметров</i>, если он задан, содержит один или более идентификаторов,
        разделённых запятыми, и должен быть заключён в круглые скобки. Идентификаторы в списке
        должны отличаться друг от друга. Их область действия ограничена макроопределением, в котором
        они заданы. Имена формальных параметров в <i>тексте</i> отмечают позиции, в которые должны
        быть подставлены фактические аргументы макровызова.
    </p>
    <p>
        В макровызове следом за <i>идентификатором</i> записывается в круглых скобах список
        фактических аргументов, соответствующих формальным параметрам из <i>списка параметров</i>.
        Списки фактически и формальных параметров должны содержать одно и то же количество
        элементов. <b>Не следует путать подстановку аргументов в макроопределение с передачей
        аргументов функции. Подстановка в препроцессоре носит чисто текстовый характер. Никаких
        вычислений или преобразований типа при этом не производится.</b>
    </p>
    <p>
        После того как выполнена макроподстановка, полученная строка вновь просматривается для
        поиска других имен макроопределений. При повторном просмотре не принимается к рассмотрению
        имя ранее произведенной макроподстановки. Поэтому директива <span
            class="sint">#define x x</span> не приведет к зацикливанию препроцессора.
    </p>
    <p><b>Примеры </b>
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">#define</span> N 100
                <span class="chiavi">#define</span> MULT(a, b) ((a) * (b))
                <span class="chiavi">#define</span> MAX(x, y) ((x) &gt; (y)) ? (x) : (y)
            </td>
        </tr>
    </table>
    <p>
        Вызов <span class="sint">MULT(x + y, z)</span> будет заменен на <span class="sint">((x + y) * (z))</span>.
        При отсутствии внутренних скобок получилось бы <span class="sint">(x + y * z)</span>, что
        неверно.
    </p>
    <p>
        Макровызов <span class="sint">MAX(i, a[i++])</span> заменится на <span class="sint">((i) &gt; (a[i++])) ? (i) : (a[i++]))</span>.
        Результат вычисления непредсказуем.
    </p>
    <p id="l2_incollare">
        В директиве <i>#define</i> две лексемы могут быть «склеены» вместе. Для этого их нужно
        объединить знаками ## (слева и справа допустимы пробельные символы). Препроцессор объединяет
        такие лексемы в одну. Например, макроопределение <span
            class="sint">#define VAR(i, j) i ## j </span> при макровызове VAR(x, 6) образует
        идентификатор x6.
    </p>
    <p id="l2_stringa">
        Символ #, помещаемый перед аргументом макроопределения, указывает на необходимость
        преобразования его в символьную строку. При макровызове конструкция <i>#&lt;формальный
        параметр&gt;</i> заменяется на "<i>&lt;фактический параметр&gt;</i>".
    </p>
    <p id="l2_undef">
        Замены в тексте можно отменить директивой <i>#undef</i>, которая имеет следующий синтаксис:
        <span class="sint">
<b>#undef</b> &lt;<i>идентификатор</i>&gt; 
</span>
    </p>
    <p>
        Директива <i>#undef</i> отменяет действие текущего определения <i>#define</i> для <i>идентификатора</i>.
        Чтобы отменить макроопределение, достаточно задать его <i>идентификатор</i>. Задание списка
        параметров не требуется. Не является ошибкой применение директивы <i>#undef</i> к
        идентификатору, который ранее не был определён или действие которого уже отменено.
    </p>
    <p>
        Принятая в С/С++ форма макросов является серьезным недостатком языка. Теперь эту форму можно
        считать устаревшей благодаря наличию более подходящих средств языка, таких как , , и . Точно
        также, широкое использование приведений типа в любом языке сигнализирует о плохом
        проектировании. Как макросы, так и приведения являются частыми источниками ошибок. Тот факт,
        что без них можно обойтись, делает программирование на <span>С++</span> гораздо более
        безопасным и элегантным.
    </p>
    <h3 id="l2_2_3_3">2.3.3. Условная компиляция</h3>
    <p>
        Условная компиляция обеспечивается в языке <span>С++</span> набором команд, которые, по
        существу, управляют не компиляцией, а препроцессорной обработкой. Эти директивы позволяют
        исключить из процесса компиляции какие-либо части исходного файла посредством проверки
        условий.
        <span class="sint">
<b>#if</b> <i>&lt;константное выражение&gt;</i>
    [<i>&lt;текст&gt;</i>]
[<b>#elif</b> <i>&lt;константное выражение&gt;</i>
    [<i>&lt;текст&gt;</i>]]
...
[<b>#else</b>
    [<i>&lt;текст&gt;</i>]]
<b>#endif</b>
</span>
    </p>
    <p>
        Каждой директиве <i>#if</i> в том же исходном файле должна соответствовать завершающая её
        директива <i>#endif.</i> Между директивами <i>#if</i> и <i>#endif</i> допускается
        произвольное количество директив <i>#elif</i> и не более одной директивы <i>#else</i>. Если
        директива <i>#else</i> присутствует, то между ней и директивой <i>#endif</i> на данном
        уровне вложенности не должно быть других директив <i>#elif</i>.
    </p>
    <p>
        Препроцессор выбирает участок текста для обработки на основе вычисления <i>константного
        выражения</i>, следующего за каждой директивой <i>#if</i> и <i>#elif</i>. Выбирается <i>текст</i>,
        следующий за <i>константным выражением</i> со значением «истина». Если ни одно ограниченное
        константное выражение не истинно, то препроцессор выбирает <i>текст</i>, следующий за
        директивой <i>#else</i>. Если же директива<i> #else</i> отсутствует, то никакой текст не
        выбирается.
    </p>
    <p id="l2_defined">
        <i>Константное выражение</i> может содержать препроцессорную операцию <b>defined</b>(<i>&lt;идентификатор&gt;</i>).
        Эта операция возвращает истинное значение, если заданный <i>идентификатор</i> в данный
        момент определён, в противном случае выражение ложно.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">#if</span> (<span class="chiavi">sizeof</span>(<span
                    class="chiavi">void</span> *) == 2)
                <span class="chiavi">#define</span> SDATA
                <span class="chiavi">#else</span>
                <span class="chiavi">#define</span> LDATA
                <span class="chiavi">#endif</span>
                <span class="chiavi">#if defined</span>(CREDIT)
                credit();
                <span class="chiavi">#elif</span> defined(DEBIT)
                debit();
                <span class="chiavi">#else</span>
                printerror();
                <span class="chiavi">#endif</span>
            </td>
        </tr>
    </table>
</section>
<section id="l2_3">
    <h2>3. Пример </h2>
    <h3 id="l2_3_1">3.1. Программа поиска корня уравнения <i>f</i>(<i>x</i>) = 0 на отрезке
        [<i>a</i>; <i>b</i>] с заданной точностью
                методом деления отрезка пополам</h3>
    <h4>Первый вариант – обычный способ </h4>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">#include</span> &lt;cstdio&gt;
                <span class="chiavi">#include</span> &lt;math.h&gt;
                <span class="chiavi">void</span> main()
                { <span class="chiavi">double</span> a, b, e, x, c, fa, fc;
                <span class="chiavi">int</span> n;

                printf("Введите границы отрезка и точность: ");
                scanf("%lf%lf%lf", &amp;a, &amp;b, &amp;e);
                <span class="chiavi">for</span> (n = 0; fabs(a - b) &gt; e; n++)


                <b>{</b> c = (a + b) / 2;
                fa = f(a);
                fc = f(c);
                <span class="chiavi">if</span> (fa * fc &lt; 0)
                b = c;
                <span class="chiavi">else</span>
                a = c;
                <b>}</b>
                x = (a + b) / 2;
                printf("Корень уравнения = %lf\nЧисло итераций = %d\n", x, n);
                }
            </td>
            <td class="commenti">// Включаем заголовочные файлы,
                // содержащие прототипы функций ввода/вывода
                // и математических функций (для fabs)
                // Объявления переменных
                // Приглашение для пользователя
                // Ввод исходных данных
                // В заголовок цикла <span class="keys">for</span> включаем инициализацию переменной
                <var>n</var>,
                // её увеличение на 1, т.к. оно безусловно выполняется
                // на каждом шаге цикла, и проверку условия цикла
                // Т.к. в теле цикла должно быть более одного оператора,
                // а по синтаксису возможен только один,
                // операторы, составляющие тело цикла,
                // объединяются в один с помощью операторных скобок {...}
            </td>
        </tr>
    </table>
    <h4> Второй вариант – как на Паскале </h4>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">#include</span> &lt;cstdio&gt;
                <span class="chiavi">#include</span> &lt;math.h&gt;
                <span class="chiavi">void</span> main()
                { <span class="chiavi">double</span> a, b, e, x, c, fa, fc;
                <span class="chiavi">int</span> n;
                printf("Введите границы отрезка и точность: ");
                scanf("%lf%lf%lf", &amp;a, &amp;b, &amp;e);
                n = 0;
                <span class="chiavi">while</span> (fabs(a - b) &gt; e)
                { c = (a + b) / 2;
                fa = f(a);
                fc = f(c);
                <span class="chiavi">if</span> (fa * fc &lt; 0)
                b = c;
                <span class="chiavi">else</span>
                a = c;
                n++;
                }
                x = (a + b) / 2;
                printf("Корень уравнения = %lf\nЧисло итераций = %d\n", x, n);
                }
            </td>
        </tr>
    </table>
    <h4>Третий вариант – весь алгоритм помещен в заголовок цикла <i>for</i></h4>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">#include</span> &lt;cstdio&gt;
                <span class="chiavi">#include</span> &lt;math.h&gt;
                <span class="chiavi">void</span> main()
                { <span class="chiavi">double</span> a, b, e, x, c, fa, fc;
                <span class="chiavi">int</span> n;
                printf("Введите границы отрезка и точность: ");
                scanf("%lf%lf%lf", &amp;a, &amp;b, &amp;e);
                <span class="chiavi">for</span> (n = 0;
                fabs(a - b) &gt; e;
                c = (a + b) / 2, fa = f(a), fc = f(c), fa * fc &lt; 0 ? b = c : a = c, n++) ;


                x = (a + b) / 2;
                printf("Корень уравнения = %lf\nЧисло итераций = %d\n", x, n);
                }
            </td>

            <td class="commenti">
                // Для объединения нескольких операторов
                // в используется
                //
            </td>
        </tr>
    </table>
    <h3 id="l2_3_2">3.2. Функция с переменным числом параметров, аналогичная функции <i>printf</i>
    </h3>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">#include</span> &lt;cstdio&gt;
                <span class="chiavi">#include</span> &lt;stdarg.h&gt;
                <span class="chiavi">void</span> print(<span class="chiavi">char</span> *format,
                ...);
                <span class="chiavi">void</span> main()
                { <span class="chiavi">int</span> a = 45, b = 87;
                <span class="chiavi">double</span> f = 2.75;
                print("dfd", a, f, b);
                }
                <span class="chiavi">void</span> print(<span class="chiavi">char</span> * format,
                ...)
                { va_list list;
                <span class="chiavi">int</span> n, i;
                <span class="chiavi">double</span> f;

                va_start(list, format);
                <span class="chiavi">for</span> (i = 0; format[i]; i++)
                <span class="chiavi">switch</span>(format[i])
                { <span class="chiavi">case</span> 'd':
                n = va_arg(list, <span class="chiavi">int</span>);
                printf("%d\n", n);
                <span class="chiavi">break</span>;
                <span class="chiavi">case</span> 'f':
                f = va_arg(list, <span class="chiavi">double</span>);
                printf("%lf\n", f);
                <span class="chiavi">break</span>;
                }
                va_end(list);
                }
            </td>
            <td class="commenti">
                // Переменная для работы со списком аргументов
                // Инициализация указателя на список аргументов
                // Выбираем очередной параметр
                // Выбираем очередной параметр
                // Сброс указателя на список аргументов в NULL
            </td>
        </tr>
    </table>
</section>

</body>
</html>
