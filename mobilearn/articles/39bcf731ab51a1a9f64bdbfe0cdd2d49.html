<!DOCTYPE html>
<html>
<head>

    <title>11. Лекция: Многопоточные вычисления.</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<p>В этой лекции рассматриваются вопросы взаимодействия потоков (нитей) в рамках одной программы.
    Вводятся основные понятия (семафоры, очереди, блокировки). Делается попытка объяснить
    особенности параллельного программирования на основе модели многопоточности.</p>
<p>О потоках управления</p>
<p>В современной операционной системе, даже не выполняющей ничего особенного, могут одновременно
    работать несколько процессов (processes). Например, при запуске программы запускается новый
    процесс. Функции для управления процессами можно найти в стандартном модуле os языка Python.
    Здесь же речь пойдет о потоках.</p>
<p>Потоки управления (threads) образуются и работают в рамках одного процесса. В однопоточном
    приложении (программе, которая не использует дополнительных потоков) имеется только один поток
    управления. Говоря упрощенно, при запуске программы этот поток последовательно исполняет
    встречаемые в программе операторы, направляясь по одной из альтернативных ветвей оператора
    выбора, проходит через тело цикла нужное число раз, выбирается к месту обработки исключения при
    возбуждении исключения. В любой момент времени интерпретатор Python знает, какую команду
    исполнить следующей. После исполнения команды становится известно, какой команде передать
    управление. Эта ниточка непрерывна в ходе выполнения программы и обрывается только по ее
    завершении.</p>
<p>Теперь можно представить себе, что в некоторой точке программы ниточка раздваивается, и каждый
    поток идет своим путем. Каждый из образовавшихся потоков может в дальнейшем еще несколько раз
    раздваиваться. (При этом один из потоков всегда остается главным, и его завершение означает
    завершение всей программы.) В каждый момент времени интерпретатор знает, какую команду какой
    поток должен выполнить, и уделяет кванты времени каждому потоку. Такое, казалось бы,
    незначительное усложнение механизма выполнения программы на самом деле требует качественных
    изменений в программе — ведь деятельность потоков должна быть согласована. Нельзя допускать,
    чтобы потоки одновременно изменяли один и тот же объект, результат такого изменения, скорее
    всего, нарушит целостность объекта.</p>
<p>Одним из классических средств согласования потоков являются объекты, называемые семафорами.
    Семафоры не допускают выполнения некоторого участка кода несколькими потоками одновременно.
    Самый простой семафор — замок (lock) или mutex (от английского mutually exclusive,
    взаимоисключающий). Для того чтобы поток мог продолжить выполнение кода, он должен сначала
    захватить замок. После захвата замка поток выполняет определенный участок кода и потом
    освобождает замок, чтобы другой поток мог его получить и пройти дальше к выполнению охраняемого
    замком участку программы. Поток, столкнувшись с занятым другим потоком замком, обычно ждет его
    освобождения.</p>
<p>Поддержка многопоточности в языке Python доступна через использование ряда модулей. В стандартном
    модуле threading определены нужные для разработки многопоточной (multithreading) программы
    классы: несколько видов семафоров (классы замков Lock, RLock и класс Semaphore) и другие
    механизмы взаимодействия между потоками (классы Event и Condition), класс Timer для запуска
    функции по прошествии некоторого времени. Модуль Queue реализует очередь, которой могут
    пользоваться сразу несколько потоков. Для создания и (низкоуровневого) управления потоками в
    стандартном модуле thread определен класс Thread.</p>
<p>Пример многопоточной программы</p>
<p>В следующем примере создается два дополнительных потока, которые выводят на стандартный вывод
    каждый свое:</p>
<p>Листинг</p>
<p>import threading</p>
<p>def proc(n):</p>
<p>print «Процесс», n</p>
<p>p1 = threading.Thread(target=proc, name=«t1», args=[«1»])</p>
<p>p2 = threading.Thread(target=proc, name=«t2», args=[«2»])</p>
<p>p1.start()</p>
<p>p2.start()</p>
<p>Сначала получается два объекта класса Thread, которые затем и запускаются с различными
    аргументами. В данном случае в потоках работает одна и та же функция proc(), которой передается
    один аргумент, заданный в именованном параметре args конструктора класса Thread. Нетрудно
    догадаться, что метод start() служит для запуска нового потока. Таким образом, в приведенном
    примере работают три потока: основной и два дополнительных (с именами «t1» и «t2»).</p>
<p>Функции модуля threading</p>
<p>В модуле threading, который здесь используется, есть функции, позволяющие получить информацию о
    потоках:</p>
<p>activeCount() Возвращает количество активных в настоящий момент экземпляров класса Thread.
    Фактически, это len(threading.enumerate()).</p>
<p>currentThread() Возвращает текущий объект–поток, то есть соответствующий потоку управления,
    который вызвал эту функцию. Если поток не был создан через модуль threading, будет возвращен
    объект–поток с сокращенной функциональностью (dummy thread object).</p>
<p>enumerate() Возвращает список активных потоков. Завершившиеся и еще не начатые потоки не входят в
    список.</p>
<p>Класс Thread</p>
<p>Экземпляры класса threading.Thread представляют потоки Python–программы. Задать действия, которые
    будут выполняться в потоке, можно двумя способами: передать конструктору класса исполняемый
    объект и аргументы к нему или путем наследования получить новый класс с переопределенным методом
    run(). Первый способ был рассмотрен в примере выше. Конструктор класса threading.Thread имеет
    следующие аргументы:</p>
<p>Листинг</p>
<p>Thread(group, target, name, args, kwargs)</p>
<p>Здесь group — группа потоков (пока что не используется, должен быть равен None), target — объект,
    который будет вызван в методе run(), name — имя потока, args и kwargs — последовательность и
    словарь позиционных и именованных параметров (соответственно) для вызова заданного в параметре
    target объекта. В примере выше были использованы только позиционные параметры, но то же самое
    можно было выполнить и с применением именованных параметров:</p>
<p>Листинг</p>
<p>import threading</p>
<p>def proc(n):</p>
<p>print «Процесс», n</p>
<p>p1 = threading.Thread(target=proc, name=«t1», kwargs={«n»: «1»})</p>
<p>p2 = threading.Thread(target=proc, name=«t2», kwargs={«n»: «2»})</p>
<p>p1.start()</p>
<p>p2.start()</p>
<p>То же самое можно проделать через наследование от класса threading.Thread с определением
    собственного конструктора и метода run():</p>
<p>Листинг</p>
<p>import threading</p>
<p>class T(threading.Thread):</p>
<p>def __init__(self, n):</p>
<p>threading.Thread.__init__(self, name=«t» + n)</p>
<p>self.n = n</p>
<p>def run(self):</p>
<p>print «Процесс», self.n</p>
<p>p1 = T(«1»)</p>
<p>p2 = T(«2»)</p>
<p>p1.start()</p>
<p>p2.start()</p>
<p>Самое первое, что необходимо сделать в конструкторе — вызвать конструктор базового класса. Как и
    раньше, для запуска потока нужно выполнить метод start() объекта–потока, что приведет к
    выполнению действий в методе run().</p>
<p>Жизнью потоков можно управлять вызовом методов:</p>
<p>start()Дает потоку жизнь.</p>
<p>run()Этот метод представляет действия, которые должны быть выполнены в потоке.</p>
<p>join([timeout])Поток, который вызывает этот метод, приостанавливается, ожидая завершения потока,
    чей метод вызван. Параметр timeout (число с плавающей точкой) позволяет указать время ожидания
    (в секундах), по истечении которого приостановленный поток продолжает свою работу независимо от
    завершения потока, чей метод join был вызван. Вызывать join() некоторого потока можно много раз.
    Поток не может вызвать метод join() самого себя. Также нельзя ожидать завершения еще не
    запущенного потока. Слово «join» в переводе с английского означает «присоединить», то есть,
    метод, вызвавший join(), желает, чтобы поток по завершении присоединился к вызывающему метод
    потоку.</p>
<p>getName()Возвращает имя потока. Для главного потока это «MainThread».</p>
<p>setName(name)Присваивает потоку имя name.</p>
<p>isAlive()Возвращает истину, если поток работает (метод run() уже вызван, но еще не
    завершился).</p>
<p>isDaemon()Возвращает истину, если поток имеет признак демона. Программа на Python завершается по
    завершении всех потоков, не являющихся демонами. Главный поток демоном не является.</p>
<p>setDaemon(daemonic)Устанавливает признак daemonic того, что поток является демоном. Начальное
    значение этого признака заимствуется у потока, запустившего данный. Признак можно изменять
    только для потоков, которые еще не запущены.</p>
<p>В модуле Thread пока что не реализованы возможности, присущие потокам в Java (определение групп
    потоков, приостановка и прерывание потоков извне, приоритеты и некоторые другие вещи), однако
    они, скорее всего, будут созданы в недалеком будущем.</p>
<p>Таймер</p>
<p>Класс threading.Timer представляет действие, которое должно быть выполнено через заданное время.
    Этот класс является подклассом класса threading.Thread, поэтому запускается также методом
    start(). Следующий простой пример, печатающий на стандартном выводе Hello, world! поясняет
    сказанное:</p>
<p>Листинг</p>
<p>def hello():</p>
<p>print «Hello, world!»</p>
<p>t = Timer(30.0, hello)</p>
<p>t.start()</p>
<p>Замки</p>
<p>Простейший замок может быть реализован на основе класса Lock модуля threading. Замок имеет два
    состояния: он может быть или открыт, или заперт. В последнем случае им владеет некоторый поток.
    Объект класса Lock имеет следующие методы:</p>
<p>acquire([blocking=True])Делает запрос на запирание замка. Если параметр blocking не указан или
    является истиной, то поток будет ожидать освобождения замка. Если параметр не был задан, метод
    не возвратит значения. Если blocking был задан и истинен, метод возвратит True (после успешного
    овладения замком). Если блокировка не требуется (то есть задан blocking=False), метод вернет
    True, если замок не был заперт и им успешно овладел данный поток. В противном случае будет
    возвращено False.</p>
<p>release()Запрос на отпирание замка.</p>
<p>locked()Возвращает текущее состояние замка (True — заперт, False — открыт). Следует иметь в виду,
    что даже если состояние замка только что проверено, это не означает, что он сохранит это
    состояние до следующей команды.</p>
<p>Имеется еще один вариант замка — threading.RLock, который отличается от threading.Lock тем, что
    некоторый поток может запрашивать его запирание много раз. Отпирание такого замка должно
    происходить столько же раз, сколько было запираний. Это может быть полезно, например, внутри
    рекурсивных функций.</p>
<p>Когда нужны замки?</p>
<p>Замки позволяют ограничивать вход в некоторую область программы одним потоком. Замки могут
    потребоваться для обеспечения целостности структуры данных. Например, если для корректной работы
    программы требуется добавление определенного элемента сразу в несколько списков или словарей,
    такие операции в многопоточном приложении следует обставить замками. Вокруг атомарных операций
    над встроенными типами (операций, которые не вызывают исполнение какого–то другого кода на
    Python) замки ставить необязательно. Например, метод append() (встроенного) списка является
    атомарной операцией, а тот же метод, реализованный пользовательским классом, может требовать
    блокировок. В случае сомнений, конечно, лучше перестраховаться и поставить замки, однако следует
    минимизировать общее время действия замка, так как замок останавливает другие потоки, пытающиеся
    попасть в ту же область программы. Отсутствие замка в критической части программы, работающей
    над общими для двух и более потоков ресурсами, может привести к случайным, трудноуловимым
    ошибкам.</p>
<p>Тупиковая ситуация (deadlock)</p>
<p>Замки применяются для управления доступом к ресурсу, который нельзя использовать совместно. В
    программе таких ресурсов может быть несколько. При работе с замками важно хорошо продумать, не
    зайдет ли выполнение программы в тупик (deadlock) из–за того, что двум потокам потребуются одни
    и те же ресурсы, но ни тот, ни другой не смогут их получить, так как они уже получили замки.
    Такая ситуация проиллюстрирована в следующем примере:</p>
<p>Листинг</p>
<p>import threading, time</p>
<p>resource = {'A': threading.Lock(), 'B': threading.Lock()}</p>
<p>def proc(n, rs):</p>
<p>for r in rs:</p>
<p>print «Процесс %s запрашивает ресурс %s» % (n, r)</p>
<p>resource[r].acquire()</p>
<p>print «Процесс %s получил ресурс %s» % (n, r)</p>
<p>time.sleep(1)</p>
<p>print «Процесс %s выполняется» % n</p>
<p>for r in rs:</p>
<p>resource[r].release()</p>
<p>print «Процесс %s закончил выполнение» % n</p>
<p>p1 = threading.Thread(target=proc, name=«t1», args=[«1», «AB»])</p>
<p>p2 = threading.Thread(target=proc, name=«t2», args=[«2», «BA»])</p>
<p>p1.start()</p>
<p>p2.start()</p>
<p>p1.join()</p>
<p>p2.join()</p>
<p>В этом примере два потока (t1 и t2) запрашивают замки к одним и тем же ресурсам (A и B), но в
    разном порядке, отчего получается, что ни у того, ни у другого не хватает ресурсов для
    дальнейшей работы, и они оба безнадежно повисают, ожидая освобождения нужного ресурса. Благодаря
    операторам print можно увидеть последовательность событий:</p>
<p>Листинг</p>
<p>Процесс 1 запрашивает ресурс A</p>
<p>Процесс 1 получил ресурс A</p>
<p>Процесс 2 запрашивает ресурс B</p>
<p>Процесс 2 получил ресурс B</p>
<p>Процесс 1 запрашивает ресурс B</p>
<p>Процесс 2 запрашивает ресурс A</p>
<p>Существуют методики, позволяющие избежать подобных тупиков, однако их рассмотрение не входит в
    рамки данной лекции. Можно посоветовать следующие приемы:</p>
<p>построить логику приложения так, чтобы никогда не запрашивать замки к двум ресурсам сразу.
    Возможно, придется определить составной ресурс. В частности, к данному примеру можно было бы
    определить замок «AB» для указания эксклюзивного доступа к ресурсам A и B.</p>
<p>строго упорядочить все ресурсы (например, по цене) и всегда запрашивать их в определенном порядке
    (скажем, начиная с более дорогих ресурсов). При этом перед заказом некоторого ресурса поток
    должен отказаться от заблокированных им более дешевых ресурсов.</p>
<p>Семафоры</p>
<p>Семафоры (их иногда называют семафорами Дийкстры (Dijkstra) по имени их изобретателя) являются
    более общим механизмом синхронизации потоков, нежели замки. Семафоры могут допустить в
    критическую область программы сразу несколько потоков. Семафор имеет счетчик запросов,
    уменьшающийся с каждым вызовом метода acquire() и увеличивающийся при каждом вызове release().
    Счетчик не может стать меньше нуля, поэтому в таком состоянии потокам приходится ждать, как и в
    случае с замками, пока значение счетчика не увеличится.</p>
<p>Конструктор класса threading.Semaphore принимает в качестве (необязательного) аргумента начальное
    состояние счетчика (по умолчанию оно равно 1, что соответствует замку класса Lock). Методы
    acquire() и release() действуют аналогично описанным выше одноименным методам у замков.</p>
<p>Семафор может применяться для охраны ограниченного ресурса. Например, с его помощью можно вести
    пул соединений с базой данных. Пример такого использования семафора (заимствован из документации
    к Python) дан ниже:</p>
<p>Листинг</p>
<p>from threading import BoundedSemaphore</p>
<p>maxconnections = 5</p>
<p># Подготовка семафора</p>
<p>pool_sema = BoundedSemaphore(value=maxconnections)</p>
<p># Внутри потока:</p>
<p>pool_sema.acquire()</p>
<p>conn = connectdb()</p>
<p># … использование соединения …</p>
<p>conn.close()</p>
<p>pool_sema.release()</p>
<p>Таким образом, применяется не более пяти соединений с базой данных. В примере использован класс
    threading.BoundedSemaphore. Экземпляры этого класса отличаются от экземпляров класса
    threading.Semaphore тем, что не дают сделать release() больше, чем сделан acquire().</p>
<p>События</p>
<p>Еще одним способом коммуникации между объектами являются события. Экземпляры класса
    threading.Event могут быть использованы для передачи информации о наступлении некоторого события
    от одного потока одному или нескольким другим потокам. Объекты–события имеют внутренний флаг,
    который может находиться в установленном или сброшенном состоянии. При своем создании флаг
    события находится в сброшенном состоянии. Если флаг в установленном состоянии, ожидания не
    происходит: поток, вызвавший метод wait() для ожидания события, просто продолжает свою работу.
    Ниже приведены методы экземпляров класса threading.Event:</p>
<p>set()Устанавливает внутренний флаг, сигнализирующий о наступлении события. Все ждущие данного
    события потоки выходят из состояния ожидания.</p>
<p>clear()Сбрасывает флаг. Все события, которые вызывают метод wait() этого объекта–события, будут
    находиться в состоянии ожидания до тех пор, пока флаг сброшен, или по истечении заданного
    таймаута.</p>
<p>isSet()Возвращает состояние флага.</p>
<p>wait([timeout])Переводит поток в состояние ожидания, если флаг сброшен, и сразу возвращается,
    если флаг установлен. Аргумент timeout задает таймаут в секундах, по истечении которого ожидание
    прекращается, даже если событие не наступило.</p>
<p>Составить пример работы с событиями предлагается в качестве упражнения.</p>
<p>Условия</p>
<p>Более сложным механизмом коммуникации между потоками является механизм условий. Условия
    представляются в виде экземпляров класса threading.Condition и, подобно только что рассмотренным
    событиям, оповещают потоки об изменении некоторого состояния. Конструктор класса
    threading.Condition принимает необязательный параметр, задающий замок класса threading.Lock или
    threading.RLock. По умолчанию создается новый экземпляр замка класса threading.RLock. Методы
    объекта–условия описаны ниже:</p>
<p>acquire(…)Запрашивает замок. Фактически вызывается одноименный метод принадлежащего
    объекту–условию объекта–замка.</p>
<p>release()Снимает замок.</p>
<p>wait([timeout])Переводит поток в режим ожидания. Этот метод может быть вызван только в том
    случае, если вызывающий его поток получил замок. Метод снимает замок и блокирует поток до
    появления объявлений, то есть вызовов методов notify() и notifyAll() другими потоками.
    Необязательный аргумент timeout задает таймаут ожидания в секундах. При выходе из ожидания поток
    снова запрашивает замок и возвращается из метода wait().</p>
<p>notify()Выводит из режима ожидания один из потоков, ожидающих данные условия. Метод можно
    вызвать, только овладев замком, ассоциированным с условием. Документация предупреждает, что в
    будущих реализациях модуля из целей оптимизации этот метод будет прерывать ожидание сразу
    нескольких потоков. Сам по себе метод notify() не приводит к продолжению выполнения ожидавших
    условия потоков, так как этому препятствует занятый замок. Потоки получают управление только
    после снятия замка потоком, вызвавшим метод notify().</p>
<p>notifyAll()Этот метод аналогичен методу notify(), но прерывает ожидание всех ждущих выполнения
    условия потоков.</p>
<p>В следующем примере условия используются для оповещения потоков о прибытии новой порции данных
    (организуется связь производитель — потребитель, producer — consumer):</p>
<p>Листинг</p>
<p>import threading</p>
<p>cv = threading.Condition()</p>
<p>class Item:</p>
<p>«"«Класс–контейнер для элементов, которые будут потребляться</p>
<p>в потоках»""</p>
<p>def __init__(self):</p>
<p>self._items = []</p>
<p>def is_available(self):</p>
<p>return len(self._items) &gt; 0</p>
<p>def get(self):</p>
<p>return self._items.pop()</p>
<p>def make(self, i):</p>
<p>self._items.append(i)</p>
<p>item = Item()</p>
<p>def consume():</p>
<p>«"«Потребление очередного элемента (с ожиданием его появления)»""</p>
<p>cv.acquire()</p>
<p>while not item.is_available():</p>
<p>cv.wait()</p>
<p>it = item.get()</p>
<p>cv.release()</p>
<p>return it</p>
<p>def consumer():</p>
<p>while True:</p>
<p>print consume()</p>
<p>def produce(i):</p>
<p>«"«Занесение нового элемента в контейнер и оповещение потоков»""</p>
<p>cv.acquire()</p>
<p>item.make(i)</p>
<p>cv.notify()</p>
<p>cv.release()</p>
<p>p1 = threading.Thread(target=consumer, name=«t1»)</p>
<p>p1.setDaemon(True)</p>
<p>p2 = threading.Thread(target=consumer, name=«t2»)</p>
<p>p2.setDaemon(True)</p>
<p>p1.start()</p>
<p>p2.start()</p>
<p>produce(«ITEM1»)</p>
<p>produce(«ITEM2»)</p>
<p>produce(«ITEM3»)</p>
<p>produce(«ITEM4»)</p>
<p>p1.join()</p>
<p>p2.join()</p>
<p>В этом примере условие cv отражает наличие необработанных элементов в контейнере item. Функция
    produce() «производит» элементы, а consume(), работающая внутри потоков, «потребляет». Стоит
    отметить, что в приведенном виде программа никогда не закончится, так как имеет бесконечный цикл
    в потоках, а в главном потоке — ожидание завершения этих потоков. Еще одна особенность — признак
    демона, установленный с помощью метода setDaemon() объекта–потока до его старта.</p>
<p>Очередь</p>
<p>Процесс, показанный в предыдущем примере, имеет значение, достойное отдельного модуля. Такой
    модуль в стандартной библиотеке языка Python есть, и он называется Queue.</p>
<p>Помимо исключений — Queue.Full (очередь переполнена) и Queue.Empty (очередь пуста) - модуль
    определяет класс Queue, заведующий собственно очередью.</p>
<p>Собственно, здесь можно привести аналог примера выше, но уже с использованием класса
    Queue.Queue:</p>
<p>Листинг</p>
<p>import threading, Queue</p>
<p>item = Queue.Queue()</p>
<p>def consume():</p>
<p>«"«Потребление очередного элемента (с ожиданием его появления)»""</p>
<p>return item.get()</p>
<p>def consumer():</p>
<p>while True:</p>
<p>print consume()</p>
<p>def produce(i):</p>
<p>«"«Занесение нового элемента в контейнер и оповещение потоков»""</p>
<p>item.put(i)</p>
<p>p1 = threading.Thread(target=consumer, name=«t1»)</p>
<p>p1.setDaemon(True)</p>
<p>p2 = threading.Thread(target=consumer, name=«t2»)</p>
<p>p2.setDaemon(True)</p>
<p>p1.start()</p>
<p>p2.start()</p>
<p>produce(«ITEM1»)</p>
<p>produce(«ITEM2»)</p>
<p>produce(«ITEM3»)</p>
<p>produce(«ITEM4»)</p>
<p>p1.join()</p>
<p>p2.join()</p>
<p>Следует отметить, что все блокировки спрятаны в реализации очереди, поэтому в коде они явным
    образом не присутствуют.</p>
<p>Модуль thread</p>
<p>По сравнению с модулем threading, модуль thread предоставляет низкоуровневый доступ к потокам.
    Многие функции модуля threading, который рассматривался до этого, реализованы на базе модуля
    thread. Здесь стоит сделать некоторые замечания по применению потоков вообще. Документация по
    Python предупреждает, что использование потоков имеет особенности:</p>
<p>Исключение KeyboardInterrupt (прерывание от клавиатуры) может быть получено любым из потоков,
    если в поставке Python нет модуля signal (для обработки сигналов).</p>
<p>Не все встроенные функции, блокированные ожиданием ввода, позволяют другим потокам работать.
    Правда, основные функции вроде time.sleep(), select.select(), метод read() файловых объектов не
    блокируют другие потоки.</p>
<p>Невозможно прервать метод acquire(), так как исключение KeyboardInterrupt возбуждается только
    после возврата из этого метода.</p>
<p>Нежелательно, чтобы главный поток завершался раньше других потоков, так как не будут выполнены
    необходимые деструкторы и даже части finally в операторах try–finally. Это связано с тем, что
    почти все операционные системы завершают приложение, у которого завершился главный поток.</p>
<p>Визуализация работы потоков</p>
<p>Следующий пример иллюстрирует параллельность выполнения потоков, используя возможности библиотеки
    графических примитивов Tkinter (она входит в стандартную поставку Python). Несколько потоков
    наперегонки увеличивают размеры прямоугольника некоторого цвета. Цветом победившего потока
    окрашивается кнопка Go:</p>
<p>Листинг</p>
<p>import threading, time, sys</p>
<p>from Tkinter import Tk, Canvas, Button, LEFT, RIGHT, NORMAL, DISABLED</p>
<p>global champion</p>
<p># Задается дистанция, цвет полосок и другие параметры</p>
<p>distance = 300</p>
<p>colors = [«Red»,«Orange»,«Yellow»,«Green»,«Blue»,«DarkBlue»,«Violet»]</p>
<p>nrunners = len(colors) # количество дополнительных потоков</p>
<p>positions = [0] * nrunners # список текущих позиций</p>
<p>h, h2 = 20, 10 # параметры высоты полосок</p>
<p>def run(n):</p>
<p>«"«Программа бега n–го участника (потока)»""</p>
<p>global champion</p>
<p>while 1:</p>
<p>for i in range(10000): # интенсивные вычисления</p>
<p>pass</p>
<p>graph_lock.acquire()</p>
<p>positions[n] += 1 # передвижение на шаг</p>
<p>if positions[n] == distance: # если уже финиш</p>
<p>if champion is None: # и чемпион еще не определен,</p>
<p>champion = colors[n] # назначается чемпион</p>
<p>graph_lock.release()</p>
<p>break</p>
<p>graph_lock.release()</p>
<p>def ready_steady_go():</p>
<p>«"«Инициализация начальных позиций и запуск потоков»""</p>
<p>graph_lock.acquire()</p>
<p>for i in range(nrunners):</p>
<p>positions[i] = 0</p>
<p>threading.Thread(target=run, args=[i,]).start()</p>
<p>graph_lock.release()</p>
<p>def update_positions():</p>
<p>«"«Обновление позиций»""</p>
<p>graph_lock.acquire()</p>
<p>for n in range(nrunners):</p>
<p>c.coords(rects[n], 0, n*h, positions[n], n*h+h2)</p>
<p>tk.update_idletasks() # прорисовка изменений</p>
<p>graph_lock.release()</p>
<p>def quit():</p>
<p>«"«Выход из программы»""</p>
<p>tk.quit()</p>
<p>sys.exit(0)</p>
<p># Прорисовка окна, основы для прямоугольников и самих прямоугольников,</p>
<p># кнопок для пуска и выхода</p>
<p>tk = Tk()</p>
<p>tk.title(«Соревнование потоков»)</p>
<p>c = Canvas(tk, width=distance, height=nrunners*h, bg=«White»)</p>
<p>c.pack()</p>
<p>rects = [c.create_rectangle(0, i*h, 0, i*h+h2, fill=colors[i])</p>
<p>for i in range(nrunners)]</p>
<p>go_b = Button(text=«Go», command=tk.quit)</p>
<p>go_b.pack(side=LEFT)</p>
<p>quit_b = Button(text=«Quit», command=quit)</p>
<p>quit_b.pack(side=RIGHT)</p>
<p># Замок, регулирующий доступ к функции пакета Tk</p>
<p>graph_lock = threading.Lock()</p>
<p># Цикл проведения соревнований</p>
<p>while 1:</p>
<p>go_b.config(state=NORMAL), quit_b.config(state=NORMAL)</p>
<p>tk.mainloop() # Ожидание нажатия клавиш</p>
<p>champion = None</p>
<p>ready_steady_go()</p>
<p>go_b.config(state=DISABLED), quit_b.config(state=DISABLED)</p>
<p># Главный поток ждет финиша всех участников</p>
<p>while sum(positions) &lt; distance*nrunners:</p>
<p>update_positions()</p>
<p>update_positions()</p>
<p>go_b.config(bg=champion) # Кнопка окрашивается в цвет победителя</p>
<p>tk.update_idletasks()</p>
<p>Примечание:</p>
<p>Эта программа использует некоторые возможности языка Python 2.3 (встроенную функцию sum() и
    списковые включения), поэтому для ее выполнения нужен Python версии не меньше 2.3.</p>
<p>Заключение</p>
<p>Навыки параллельного программирования необходимы любому профессиональному программисту. Одним из
    вариантов организации (псевдо) параллельного программирования является многопоточное
    программирование (другой вариант, более свойственный Unix–системам — многопроцессное
    программирование — здесь не рассматривается). В обычной (однопоточной) программе действует всего
    один поток управления, а в многопоточной одновременно могут работать несколько потоков.</p>
<p>Параллельное программирование требует тщательной отработки взаимодействия между потоками
    управления. Некоторые участки кода необходимо ограждать от одновременного использования двумя
    различными потоками, дабы не нарушить целостность изменяемых структур данных или логику работы с
    внешними ресурсами. Для ограждения участков кода используются замки и семафоры.</p>
<p>Стандартная библиотека Python предоставляет довольно неплохой набор возможностей для
    многопоточного программирования в модулях threading и thread, а также некоторые полезные
    вспомогательные модули (например, Queue).</p>
<center>
    <div align="center"></div>
</center>

</body>
</html>
