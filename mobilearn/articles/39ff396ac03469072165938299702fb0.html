<!DOCTYPE html>
<html>
<head>

    <title> Лекция 14. Обработка исключительных ситуаций</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<section id="l14_1">
    <h1> 1. Обработка ошибок </h1>
    <p>
        Когда программа конструируется из раздельных модулей, и, особенно, когда эти модули
        находятся в независимо разработанных библиотеках, обработка ошибок должна быть разделена на
        две части:
    </p>
    <ol>
        <li>генерация информации о возникновении ошибочной ситуации, которая не может быть разрешена
            локально;
        </li>
        <li>обработка ошибок, обнаруженных в других местах.</li>
    </ol>
    <p>
        Автор библиотеки может обнаружить ошибки во время выполнения, но, как правило, не имеет
        представления о том, что делать в этом случае. Пользователь библиотеки может знать, как
        поступить в случае возникновения ошибок, но не в состоянии их обнаружить в противном случае,
        ошибки обрабатывались бы в коде пользователя, а их поиск не перепоручался бы библиотеке. Для
        помощи в решении подобных проблем введено понятие <b>исключения</b>.
    </p>
    <p>
        Фундаментальная идея состоит в том, что функция, обнаружившая проблему, но не знающая как её
        решить, <i>генерирует</i> исключение в надежде, что вызвавшая её (непосредственно или
        косвенно) функция сможет решить возникшую проблему. Функция, которая хочет решать проблемы
        данного типа, может указать, что она <i>перехватывает</i> такие исключения.
    </p>
    <p>
        Такой стиль обработки ошибок предпочтительней многих традиционных техник. Рассмотрим
        альтернативы. При обнаружении проблемы, которая не может быть решена локально, функция
        может:
    </p>
    <ol>
        <li>прекратить выполнение;</li>
        <li>возвратить значение, означающее «ошибка»;</li>
        <li>возвратить допустимое значение и оставить программу в ненормальном состоянии.</li>
    </ol>
    <p>
        Вариант 1 – «прекратить выполнение» – это то, что происходит по умолчанию, когда не
        перехватывается исключение. Для большинства ошибок мы должны придумать кое-что получше.
        Библиотека, безусловно завершающая выполнение, не может использоваться в программе, первое
        требование к которой – надёжность.
    </p>
    <p>
        Вариант 2 – «возвратить значение, сигнализирующее об ошибке» – не всегда выполним, потому
        что часто нет приемлемого значения. Даже в тех случаях, когда такой подход применим, он
        часто неудобен, потому что результат каждого вызова должен проверяться на ошибочное
        значение. Это может сильно увеличить размер программы.
    </p>
    <p>
        Вариант 3 – «возвратить допустимое значение и оставить программу в ненормальном состоянии» –
        имеет тот недостаток, что вызывающая функция может не заметить, что программа находится в
        ненормальном состоянии.
    </p>
    <p>
        Механизм обработки исключений предоставляет альтернативу традиционным методам в тех случаях,
        когда они не достаточны, не элегантны и подвержены ошибками. Он предоставляет способ явного
        отделения кода обработки ошибок от «обычного» кода, делая таким образом программу более
        читабельной и лучше подходящей для различных инструментальных средств. Механизм обработки
        исключений предоставляет более регулярный способ обработки ошибок, упрощая в результате
        взаимодействие между отдельно написанными фрагментами кода.
    </p>
    <p>
        Надо понимать, что обработка ошибок остаётся сложной задачей и что механизм обработки
        исключений – несмотря на б&#243;льшую формализацию, чем альтернативные методы – относительно
        менее структурирован по сравнению со средствами языка, обеспечивающими локальное управление
        выполнением. Механизм обработки исключений <span>C++</span> предоставляет программисту
        средство обработки ошибок в том месте, где их наиболее естественно обрабатывать при данной
        структуре системы. Исключения делают сложность обработки ошибок более явной. Однако
        исключения не являются причиной этой сложности.
    </p>
    <p>
        Механизм обработки исключений можно рассматривать в качестве альтернативы механизму возврата
        из функции. Поэтому вполне законно использовать исключения, которые не имеют никакого
        отношения к ошибкам. Однако изначальной целью механизма обработки исключений является
        обработка ошибок и обеспечение устойчивости при возникновении ошибок.
    </p></section>
<section id="l14_2">
    <h1> 2. Генерация и перехват исключений </h1>
    <p>
        Обработка исключительных ситуаций обеспечивает способ передачи управления и информации в
        неопределённую точку, где было выражено желание обрабатывать ситуации данного типа. Ситуации
        любого типа могут <i>возбуждаться</i> (<b>throw</b>) и <i>перехватываться</i> (<b>catch</b>),
        и для функции может быть перечислено множество ситуаций, которые могут быть в ней
        возбуждены.
    </p>
    <p>
        Реакция будет вызвана только в случае исполнения <i>выражения возбуждения</i> внутри <i>блока
        с контролем</i> или в функциях, вызванных из этого блока.
    </p>
    <p>
        Синтаксис блока с контролем:
        <span class="sint">
<b>try</b> { ... } <i>&lt;список реакций&gt;</i>
</span>
    </p>
    <p>
        <i>Список реакций</i> представляет собой следующую конструкцию:
        <span class="sint">
<b>catch</b> (<i>&lt;объявление ситуации&gt;</i>) { ... } [ <b>catch</b> (<i>&lt;объявление ситуации&gt;</i>) { ... } ... ]
</span>
    </p>
    <p>
        <i>Выражение возбуждения</i> имеет следующий синтаксис:
        <span class="sint">
<b>throw</b> <i>&lt;выражение&gt;</i>;
</span>
    </p>
    <p>
        При возбуждении ситуации (т.е. выполнении оператора <span class="sint">throw</span>)
        управление передаётся на реакцию. Тип операнда оператора <span class="sint">throw</span>
        определяет, какие реакции могут перехватывать данную ситуацию.
    </p>
    <p>
        Если среди реакций блока с контролем не найдено подходящей реакции, поиск подходящей реакции
        продолжается в блоке с контролем, охватывающем данный блок с контролем.
    </p>
    <p>
        Если в программе не нашлось подходящей реакции, вызывается функция <i>terminate()</i>.
        Функция <i>terminate()</i> вызывает функцию, заданную при последнем обращении к функции <i>set_terminate()</i>.
        По умолчанию функция, вызываемая из функции <i>terminate()</i>, есть <i>abort()</i>.
        Функция, вызываемая функцией <i>terminate()</i>, должна завершать выполнение программы.
    </p>
    <p>
        Исключение является <b>объектом некоторого класса</b>, являющегося представлением
        исключительного случая. Код, обнаруживший ошибку, генерирует объект инструкций <span
            class="sint">throw</span>. Фрагмент кода выражает своё желание обрабатывать исключение
        при помощи инструкции <span class="sint">catch</span>. Результатом генерации исключения
        инструкцией <span class="sint">throw</span> является раскручивание стека до тех пор, пока не
        будет обнаружен подходящий <span class="sint">catch</span> в функции, которая
        непосредственно или косвенно вызвала функцию, сгенерировавшую исключение.
    </p>
    <p>
        Сам факт генерации исключения передаёт информацию об ошибке и её типе. Кроме того,
        исключение может содержать дополнительную информацию. Фундаментальной целью техники
        обработки исключений является передача информации для восстановления после возникновений
        проблемы и для осуществления этого надёжным и удобным способом.
    </p>
    <h4>Пример 1</h4>
    <p class="code">
        <code>FILE *open(<span class="chiavi">char</span> *fname)
            { FILE *f = fopen(fname, "r");
            <span class="chiavi">if</span> (!f) <span class="chiavi">throw</span> fname;
            <span class="chiavi">return</span> f;
            }
            <span class="chiavi">void</span> main()
            { <span class="chiavi">try</span>
            { FILE *f1 = open("in1.txt");
            FILE *f2 = open("in2.txt");
            }
            <span class="chiavi">catch</span> (<span class="chiavi">char</span> *str)
            { printf("Impossible to open file '%s'!\n", str);
            <span class="chiavi">return</span>;
            }
            ...
            }
        </code>
    </p>
    <h4>Пример 2</h4>
    <p class="code">
        <code><span class="chiavi">class</span> Ex1
            { <span class="chiavi">private</span>:
            <span class="chiavi">int</span> reason;
            <span class="chiavi">public</span>:
            Ex1(<span class="chiavi">int</span> r) : reason(r) { }
            <span class="chiavi">int</span> Reason() { <span class="chiavi">return</span> reason; }
            };
            <span class="chiavi">class</span> Ex2 { };
            <span class="chiavi">void</span> f1()
            { <b>...</b>
            <span class="chiavi">if</span> (<b>...</b>) <span class="chiavi">throw</span> Ex1(0);
            <span class="chiavi">if</span> (<b>...</b>) <span class="chiavi">throw</span> Ex1(2);
            <b>...</b>
            <span class="chiavi">if</span> (<b>...</b>) <span class="chiavi">throw</span> Ex2();
            }
            <span class="chiavi">void</span> f2()
            { <b>...</b>
            <span class="chiavi">if</span> (<b>...</b>) <span class="chiavi">throw</span> Ex2();
            }
            <span class="chiavi">void</span> main()
            { <span class="chiavi">try</span>
            { <b>...</b>
            f1();
            <b>...</b>
            f2();
            <b>...</b>
            }
            <span class="chiavi">catch</span> (Ex1 ex)
            { <span class="chiavi">switch</span> (ex.Reason())
            { <span class="chiavi">case</span> 0: <b>...</b>
            <span class="chiavi">case</span> 1: <b>...</b>
            <span class="chiavi">case</span> 2: <b>...</b>
            }
            }
            <span class="chiavi">catch</span> (Ex2 ex)
            { <b>...</b> }
            }
        </code>
    </p></section>
<section id="l14_3">
    <h1> 3. Перехват исключений </h1>
    <p>
        Рассмотрим пример.
    </p>
    <p class="code">
        <code><span class="chiavi">try</span>
            { <span class="chiavi">throw</span> E(); }
            <span class="chiavi">catch</span> (H)
            { <b>...</b> }
        </code>
    </p>
    <p>
        Обработчик будет вызван, если:
    </p>
    <ol>
        <li>
            <i>Н</i> того же типа, что и <i>Е</i>;
        </li>
        <li>
            <i>Н</i> является однозначно доступным публичным базовым классом для <i>Е</i>;
        </li>
        <li>
            <i>Н</i> и <i>Е</i> являются указателями, и 1 или 2 выполняется для типов, на которые
            они ссылаются;
        </li>
        <li>
            <i>Н</i> является ссылкой, и 1 или 2 выполняется для типа, на который ссылается <i>Н</i>.
        </li>
    </ol>
</section>
<section id="l14_4">
    <h1> 4. Группировка исключений </h1>
    <p>
        Часто исключения естественным образом разбиваются на семейства. Из этого следует, что
        наследование может оказаться полезным для структурирования исключений и помочь при их
        обработке. Например, исключения для математической библиотеки можно организовать следующим
        образом.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">class</span> MathErr { <b>...</b> };
                <span class="chiavi">class</span> Overflow     : <span class="chiavi">public</span>
                MathErr { <b>...</b> };
                <span class="chiavi">class</span> Underflow    : <span class="chiavi">public</span>
                MathErr { <b>...</b> };
                <span class="chiavi">class</span> ZeroDivision : <span class="chiavi">public</span>
                MathErr { <b>...</b> };
            </td>
            <td class="commenti">
                // Переполнение сверху
                // Переполнение снизу
                // Деление на 0
            </td>
        </tr>
    </table>
    <p>
        Это позволяет нам обрабатывать исключение любого класса, производного от <i>MathErr</i>, не
        заботясь о том, какое именно исключение возникло.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">try</span>
                { <b>...</b> }
                <span class="chiavi">catch</span> (Overflow)
                { <b>...</b> }
                <span class="chiavi">catch</span> (MathErr)
                { <b>...</b> }
            </td>

            <td class="commenti">
                // Обработка исключения <i>Overflow</i> и всех производных от него исключений
                // Обработка любого исключения <i>MathErr</i>, не являющегося <i>Overflow</i></td>
        </tr>
    </table>
    <p>
        Организация исключений в виде иерархий может иметь большое значение для надёжности кода. При
        введении нового исключения в математическую библиотеку каждый фрагмент кода, который
        пытается обрабатывать все математические исключения, подлежал бы модификации. Это требует
        огромных затрат труда и в общем случае невозможно.
    </p></section>
<section id="l14_5">
    <h1> 5. Повторная генерация </h1>
    <p>
        Перехватив исключение, обработчик может решить, что у него не получается полностью
        обработать ошибку. В этом случае обработчик делает то, что может, после чего вновь
        генерирует исключение.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">try</span>
                { <b>...</b> }
                <span class="chiavi">catch</span> (MathErr)
                { <span class="chiavi">if</span> (...)
                <b>...</b>
                <span class="chiavi">else</span>
                { <b>...</b>
                <span class="chiavi">throw</span>;
                }
                }
            </td>

            <td class="commenti">
                // Возможно полностью обработать ошибку?
                // Делаем, что возможно
                // Повторная генерация исключения
            </td>
        </tr>
    </table>
    <p>
        Факт повторной генерации отмечается отсутствием операнда у <span class="sint">throw</span>.
        Если осуществлена попытка повторной генерации при отсутствии исключения, будет вызвана
        функция <i>terminate()</i>.
    </p>
    <p>
        Повторно генерируемое исключение является исходным исключением, т.е. даже если обработчик
        работал с объектом , охватывающий блок получит изначально сгенерированный объект .
    </p></section>
<section id="l14_6">
    <h1> 6. Перехват всех исключений </h1>
    <p>
        В объявлении ситуации для обработчика <span class="sint">catch</span> можно задать
        многоточие, которое даёт отождествление с любой ситуацией. Реакция с многоточием, если она
        есть, должна быть последней в списке реакций некоторого блока с контролем.
        <code>
            <span class="chiavi">try</span>
            { <span>// Делаем что-то</span> }
            <span class="chiavi">catch</span> (<b>...</b>)
            { <span>// Обработка всех исключений</span> }
        </code>
    </p></section>
<section id="l14_7">
    <h1> 7. Порядок записи обработчиков </h1>
    <p>
        Поскольку исключения производных классов могут быть перехвачены обработчиками исключений
        базовых классов, порядок, в котором записаны обработчики в инструкции <span
            class="sint">try</span>, имеет большое значение. Обработчики проверяются в порядке их
        записи.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">try</span>
                { <span>// ...</span> }
                <span class="chiavi">catch</span> (std::ios_base::failure)
                { <span>// ...</span> }
                <span class="chiavi">catch</span> (std::exception)
                { <span>// ...</span> }
                <span class="chiavi">catch</span> (<b>...</b>)
                { <span>// ...</span> }
            </td>

            <td class="commenti">
                // Обработка ошибок в потоке ввода/вывода
                // Обработка исключений стандартной библиотеки
                // Обработка всех остальных исключений
            </td>
        </tr>
    </table>
</section>
<section id="l14_8">
    <h1> 8. Исключения в конструкторах </h1>
    <p>
        Исключения предоставляют способ решить проблему, как сообщить об ошибке из конструктора.
        Поскольку конструктор не возвращает значения, которое вызывающая функция могла бы проверить,
        традиционными (т.е. без использования обработки исключений) альтернативами остаются
        следующие.
    </p>
    <ol>
        <li>Возвратить объект в «неправильном» состоянии и полагаться на то, что пользователь
            проверит его состояние.
        </li>
        <li>Присвоить значение нелокальной переменной для указания на неуспешное создание объекта и
            полагаться на то, что пользователь его проверит.
        </li>
        <li>Не осуществлять никакой инициализации в конструкторе и полагаться на то, что
            пользователь вызовет функцию инициализации (которую ещё надо написать!) до первого
            использования объекта.
        </li>
        <li>Пометить объект как неинициализированный и при первом вызове функции-члена класса для
            этого объекта осуществить инициализацию (такая функция может вернуть сообщение об ошибке
            в случае неуспешной инициализации, но пользователь опять-таки должен проверять
            возвращаемое функцией значение).
        </li>
    </ol>
    <p>
        Исключения позволяют передать информацию о неуспешной инициализации из конструктора.
        Например, класс <i>Vector</i> мог бы защититься от запроса слишком большого количества
        памяти, генерируя соответствующее исключение.
        <code>
            <span class="chiavi">class</span> Vector
            { <b>...</b>
            <span class="chiavi">public</span>:
            <span class="chiavi">class</span> Size { <b>...</b> };
            Vector(<span class="chiavi">int</span> n = 0);
            <b>...</b>
            };

            Vector::Vector(<span class="chiavi">int</span> n)
            { <span class="chiavi">if</span> (n &lt; 0 || n &gt; MAX_SIZE) <span class="chiavi">throw</span>
            Size();
            <b>...</b>
            }
        </code>
    </p>
    <p>
        Код, создающий вектора, теперь может перехватить ошибку <i>Vector::Size</i> и попытаться
        сделать что-то осмысленное.
    </p></section>
<section id="l14_9">
    <h1> 9. Исключения, не являющиеся ошибками </h1>
    <p>
        Если исключение ожидается и перехвачено таким образом, что не оказывает отрицательного
        влияния на поведение программы, почему это может считаться ошибкой? Механизмы обработки
        исключений можно рассматривать как ещё одну управляющую структуру.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">void</span> f(Queue q)
                { <span class="chiavi">try</span>
                { <span class="chiavi">for</span> ( <b>; ;</b> )
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"> { <span class="chiavi">int</span> x = q.Get();
                <b>...</b>
                }
                }
                <span class="chiavi">catch</span> (Queue<b>::</b>Empty)
                { <span class="chiavi">return</span>; }
                }
            </td>

            <td class="commenti">// Функция <i>Get</i> генерирует исключение <i>Empty</i>, если
                очередь пуста
            </td>
        </tr>
    </table>
    <p>
        Обработка исключений является менее структурированным механизмом, чем локальные управляющие
        структуры, к тому же обработка исключений часто менее эффективна, если исключение
        действительно генерируется. Поэтому исключения следует использовать в тех случаях, когда
        традиционные управляющие структуры являются неэлегантным решением, или ими невозможно
        воспользоваться.
    </p>
    <p>
        Неумеренное использование исключений ведёт к непонятному коду. Обычно следует придерживаться
        точки зрения «обработка исключений является обработкой ошибок». При таком подходе код
        оказывается понятным образом разделён на две части: обыкновенный код и код обработки ошибок.
    </p></section>
<section id="l14_10">
    <h1> 10. Спецификация исключений </h1>
    <p>
        Генерация и перехват исключений изменяют способ взаимодействия между функциями. Поэтому
        может быть полезно указать в объявлении набор исключений, которые могут быть сгенерированы
        функцией.
        <code>
            <span class="chiavi">int</span> f(<span class="chiavi">int</span> n) <span
                class="chiavi">throw</span> (ex1, ex2);
        </code>
    </p>
    <p>
        Такое объявление означает, что функция <i>f</i> может сгенерировать только исключения
        <i>ex1</i>, <i>ex2</i> и исключения, являющиеся производными от этих типов, но не другие.
        Самым важным преимуществом является то, что <i>объявление</i> функции принадлежит
        интерфейсу, который видят те, кто её вызывает.
    </p>
    <p>
        Предполагается, что функция, объявленная без спецификации исключений, может сгенерировать
        любое исключение.
        <code>
            <span class="chiavi">int</span> g(<span class="chiavi">int</span> n);
        </code>
    </p>
    <p>
        Функцию, которая не генерирует исключений, можно объявить с пустым списком спецификаций
        исключений.
        <code>
            <span class="chiavi">int</span> h(<span class="chiavi">int</span> n) <span
                class="chiavi">throw</span>();
        </code>
    </p></section>
<section id="l14_11">
    <h1> 11. Пример. Класс <i>Stack</i>, генерирующий исключения </h1>
    <p>
        Модифицируем класс <i>Stack</i> (из ) так, чтобы при переполнении стека и попытке взять
        элемент из пустого стека генерировались соответствующие исключения.
        <code>
            <span class="chiavi">#include</span> &lt;cstdio&gt;
            <span class="chiavi">class</span> Stack;
            <span class="chiavi">class</span> StackEmpty
            { <span class="chiavi">private</span>:
            Stack *stack;
            <span class="chiavi">public</span>:
            StackEmpty(Stack *p) <b>:</b> stack(p) { }
            Stack* GetPtr() { <span class="chiavi">return</span> stack; }
            };
            <span class="chiavi">class</span> StackFull
            { <span class="chiavi">private</span>:
            Stack *stack;
            <span class="chiavi">int</span> n;
            <span class="chiavi">public</span>:
            StackFull(Stack *p, <span class="chiavi">int</span> i) <b>:</b> stack(p), n(i) { }
            Stack* GetPtr() { <span class="chiavi">return</span> stack; }
            <span class="chiavi">int</span> GetValue() { <span class="chiavi">return</span> n; }
            };
            <span class="chiavi">class</span> Stack
            { <span class="chiavi">private</span>:
            <span class="chiavi">enum</span> { SIZE = 100 };
            <span class="chiavi">int</span> stack[SIZE];
            <span class="chiavi">int</span> *cur;
            <span class="chiavi">public</span>:
            Stack() { cur = stack; }
            ~Stack() { }
            <span class="chiavi">int</span> Push(<span class="chiavi">int</span> n) <span
                class="chiavi">throw</span> (StackFull);
            <span class="chiavi">int</span> Pop() <span class="chiavi">throw</span> (StackEmpty);
            <span class="chiavi">int</span> IsEmpty() <span class="chiavi">const</span> { <span
                class="chiavi">return</span> cur == stack; }
            <span class="chiavi">int</span> operator &gt;&gt; (<span class="chiavi">int</span>&amp;
            s) { s = Pop(); <span class="chiavi">return</span> s; }
            <span class="chiavi">int</span> operator &lt;&lt; (<span class="chiavi">int</span> s) {
            <span class="chiavi">return</span> Push(s); }
            };
            <span class="chiavi">int</span> Stack<b>::</b>Push(<span class="chiavi">int</span> n)
            <span class="chiavi">throw</span> (StackFull)
            { <span class="chiavi">if</span> (cur - stack &lt; SIZE)
            { *cur++ = n; <span class="chiavi">return</span> n; }
            <span class="chiavi">else</span>
            <span class="chiavi">throw</span> StackFull(<span class="chiavi">this</span>, n);
            }
            <span class="chiavi">int</span> Stack<b>::</b>Pop() <span class="chiavi">throw</span>
            (StackEmpty)
            { <span class="chiavi">if</span> (cur != stack)
            <span class="chiavi">return</span> *--cur;
            <span class="chiavi">else</span>
            <span class="chiavi">throw</span> StackEmpty(<span class="chiavi">this</span>);
            }
            <span class="chiavi">void</span> main()
            { Stack s;
            <span class="chiavi">int</span> n;
            <span class="chiavi">try</span>
            { s &lt;&lt; 1;
            s &lt;&lt; 2;
            s &lt;&lt; 3;
            s &lt;&lt; 4;
            s &lt;&lt; 5;
            s &gt;&gt; n;
            printf("%d\n", n);
            s &gt;&gt; n;
            printf("%d\n", n);
            s &gt;&gt; n;
            printf("%d\n", n);
            s &gt;&gt; n;
            printf("%d\n", n);
            }
            <span class="chiavi">catch</span> (StackFull s)
            { printf("Attempt to put a value %d to the full stack at the address %p\n",
            s.GetValue(), s.GetPtr()); }
            <span class="chiavi">catch</span> (StackEmpty s)
            { printf("Attempt to get a value from the empty stack at the address %p\n", s.GetPtr());
            }
            }
        </code>
    </p>
    <p>
    </p>
    <p>
    </p></section>

</body>
</html>
