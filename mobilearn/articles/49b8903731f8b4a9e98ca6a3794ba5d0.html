<!DOCTYPE html>
<html>
<head>

    <title>Лекция 15. Пакет java.io</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<div class="left">
    <p></p>
    <p></p>
    <center><h2>Лекция 15. Пакет java.io</h2></center>
    <p>
    </p>
    <p>
    </p>
    <p>Эта лекция описывает реализованные в Java возможности
        передачи ин­формации, что является важной функцией для большинства программных
        систем. Сюда входит работа с файлами, сетью, долговременное сохранение
        объектов, обмен данными между потоками исполнения и т.п. Все эти действия
        базируются на потоках байт (представлены классами InputStream и OutputStream) и потоках
        символов (Reader и Writer). В библиотеке java.io со­держатся все эти классы и их
        многочисленные наследники,
        предоставляющие полезные возможности. Отдельно рассматривается механизм
        сериализации объектов и работа с файлами.
    </p>
    <p>
    </p>
    <p>Ключевые слова:
        сериализация, поток данных, stream.
    </p>
    <p>
    </p>
    <p>Система ввода/вывода. Потоки
        данных (stream)
    </p>
    <p>Подавляющее большинство программ обменивается данными с внешним миром.
        Это, безусловно, делают любые сетевые приложения — они передают и получают
        информацию от других компьютеров и специ­альных устройств, подключенных к сети.
        Оказывается, можно точно та­ким же образом представлять обмен данными между
        устройствами внут­ри одной машины. Так, например, программа может считывать
        данные с клавиатуры и записывать их в файл, или же наоборот - считывать данные
        из файла и выводить их на экран. Таким образом, устройства, откуда мо­жет
        производиться считывание информации, могут быть самыми разно­образными — файл,
        клавиатура, входящее сетевое соединение и т.д. То же касается и устройств
        вывода — это может быть файл, экран монитора, принтер, исходящее сетевое
        соединение и т.п. В конечном счете, все дан­ные в компьютерной системе в
        процессе обработки передаются от уст­ройств ввода к устройствам вывода.
    </p>
    <p>Обычно часть вычислительной платформы, которая отвечает за об­мен
        данными, так и называется — система ввода/вывода. В Java она пред­ставлена пакетом java.io
        (input/output). Реализация
        системы ввода/выво-Да осложняется не только широким спектром источников и
        получателей Данных, но еще и различными форматами передачи информации Ею мож­но обмениваться
        в двоичном представлении, символьном или текстовом, с применением некоторой
        кодировки (только для русского языка их насчи­тывается более 4 штук), или
        передавать числа в различных представлениях. Доступ к данным может
        потребоваться как последовательный (например, считывание HTML-страницы), так и
        произвольный (сложная работа с не­
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <table align="left" cellpadding="0" cellspacing="0">
        <tr>
            <td height="0" width="469"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <center><img height="431" src="http://kufas.ru/java.files/image046.png" width="458">
                </center>
            </td>
        </tr>
    </table>
    <p>
    </p>
    <p>сколькими частями одного файла). Зачастую для повышения производи,
        тельности применяется буферизация.
    </p>
    <p>В Java для описания работы
        по вводу/выводу используется специадь. ное понятие поток данных (stream). Поток данных
        связан с некоторым ис­точником, или приемником, данных, способным получать или
        предостав­лять информацию. Соответственно, потоки делятся на входящие — читаю­щие
        данные и выходящие - передающие (записывающие) данные. Введе­ние концепции stream позволяет
        отделить основную логику программы, обменивающейся информацией
        с любыми устройствами одинаковым об­разом, от низкоуровневых операций с такими
        устройствами ввода/вывода.
    </p>
    <p>В Java потоки естественным
        образом представляются объектами. Описывающие их классы как раз и составляют
        основную часть пакета java.io. Они довольно разнообразны и отвечают за различную
        функцио­нальность. Все
        классы разделены на две части — одни осуществляют ввод данных, другие — вывод.
    </p>
    <p>Существующие стандартные классы помогают решить большинст­во типичных
        задач. Минимальной "порцией" информации является, как известно, бит,
        принимающий значение 0 или 1 (это понятие также удобно
        применять на самом низком уровне, где данные передаются электрическим сигналом;
        условно говоря, 1 представляется прохожде­нием
        импульса, 0 — его отсутствием). Традиционно используется более крупная единица
        измерения - байт, объединяющая 8 бит. Таким обра­зом, значение, представленное
        одним байтом, находится в диапазоне от 0 до 2s-1 =255, или, если использовать знак, — от
        -128 до +127. При­митивный тип byte в Java в точности
        соответствует последнему — зна­ковому диапазону.
    </p>
    <p>Базовые, наиболее универсальные, классы позволяют считывать и записывать
        информацию именно в виде набора байт. Чтобы их было удобно применять в
        различных задачах, java.io содержит также классы, преобразующие любые данные в набор байт.
    </p>
    <p>Например, если нужно сохранить результаты вычислений — набор значений
        типа double — в файл, то их
        можно сначала превратить в набор байт, а затем эти байты записать в файл.
        Аналогичные действия соверша­ются и в ситуации, когда требуется сохранить
        объект (т.е. его состояние) - преобразование в набор байт и
        последующая их запись в файл. Понятно, что при восстановлении данных в обоих рассмотренных
        случаях проделы-ваются обратные действия — сначала считывается последовательность
        байт, а затем она преобразуется в нужный формат.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>На рисунке 15.1 представлены иерархии классов ввода/вывода. Как и
        говорилось, все типы поделены на две группы. Представляющие вход­ные потоки
        классы наследуются от InputStream,
        а выходные - of OutputStream.
    </p>
    <p>Классы
        InputStream и OutputStream
    </p>
    <p>InputStream - это базовый класс для потоков ввода, т.е. чтения. Соот­ветственно, он
        описывает базовые методы для работы с байтовыми потока­ми данных. Эти методы
        необходимы всем классам, которые наследуются от InputStream.
    </p>
    <p>Простейшая операция представлена методом read() (без аргументов).
        Он является абстрактным и, соответственно, должен быть определен в Классах-наследниках.
        Этот метод предназначен для считывания ровно од­ного байта из потока, однако
        возвращает при этом значение типа int. В том случае,
        если считывание произошло успешно, возвращаемое значение ле­жит в диапазоне от
        0 до 255 и представляет собой полученный байт (значе­ние int содержит 4 байта и получается
        простым дополнением нулями в Двоичном представлении).
        Обратите внимание, что полученный таким об­разом байт не обладает знаком и не
        находится в диапазоне от -128 до + • 27, как примитивный тип byte в Java.
    </p>
    <p>Если достигнут конец потока, то есть в нем больше нет информации для
        чтения, то возвращаемое значение равно -1.
    </p>
    <p>Если же считать из потока данные не удается из-за каких-то ошибок, или
        сбоев, будет брошено исключение java.io.lOException.
        Этот класс на­следуется от
        Exception, т.е. его всегда необходимо обрабатывать явно. Дело в том, что каналы передачи
        информации, будь то Internet или, например, жесткий диск, могут давать сбои независимо от
        того,
        насколько хорошо на­писана программа. А это означает, что нужно быть готовым к
        ним, чтобы пользователь не потерял нужные данные.
    </p>
    <p>Метод read() - это абстрактный метод, но именно с соблюдением всех указанных условий
        он должен быть реализован в классах-наследниках На практике обычно приходится
        считывать не один, а сраз\ несколько байт — то есть массив байт. Для этого
        используется метол read(), где в качестве параметров передается массив byte[]. При
        выполнении
        этого метода в цикле производится вызов абстрактною метода read() (определенного без
        параметров) и результатами заполняется переданный массив. Количество байт,
        считываемое таким образом, равно длине переданного массива. Но при этом может
        так получиться, что данные в потоке закончатся еще до того, как будет заполнен
        весь массив
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> То есть возможна ситуация, когда в потоке данных (байт) содержится
        меньше, чем длина массива. Поэтому метол возвращает значение int, указывающее,
        сколько байт было реально считано. Понятно, что это значение может быть от 0 до
        величины длины переданного массива.
    </p>
    <p>Если же мы изначально хотим заполнить не весь массив, а только ею часть,
        то для этих целей используется метод read(), которому, кроме
        масси­ва byte[], передаются еще два int значения. Первое - это позиция в масси­ве, с которой
        следует начать
        заполнение, второе — количество байт, которое нужно считать. Такой подход,
        когда для получения данных передается мас­сив и два int числа — offset (смещение) и length
        (длина), является
        довольно распространенным и часто встречается не только в пакете java.io.
    </p>
    <p>При вызове методов read() возможно возникновение такой ситуации, когда запрашиваемые данные
        еще не
        готовы к считыванию. Например, если мы считываем данные, поступающие из сети, и
        они еше просто не пришли. В таком случае нельзя сказать, что данных больше нет.
        но и считать тоже нечего - выполнение останавливается на вызове метода read() и получается
        "зависание".
    </p>
    <p>Чтобы узнать, сколько байт в потоке готово к считыванию, применя­ется
        метод available(). Этот метод возвращает значение типа int, которое показывает,
        сколько байт в потоке готово к считыванию. При этом не сто­ит путать количество
        байт, готовых к считыванию, с тем количеством байт, которые вообще можно будет
        считать из этого потока. Метод available() возвращает число - количество байт, именно на
        данный момент готовых к
        считыванию.
    </p>
    <p>Когда работа с входным потоком данных окончена, его следует за­крыть.
        Для этого вызывается метод close(). Этим вызовом будут освобож­дены все системные ресурсы,
        связанные с
        потоком.
    </p>
    <p>Точно так же, как InputStream - это базовый класс
        для потоков ввода, класс OutputStream - это базовый класс
        для потоков вывода.
    </p>
    <p>В классе OutputStream аналогичным образом
        определяются три ме­тода write() — один принимающий в качестве параметра int. второй -byte[]
        и третий - byte[], плюс два int-числа. Все эти
        методы ничего не возвращают (void).
    </p>
    <p>Метод write(int) является абстрактным и должен быть реализован в классах-наследниках.
        Этот метод принимает в качестве параметра int, но реально
        записывает в поток только byte — младшие 8 бит в двоичном представлении
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Остальные 24 бита будут
        проигнорированы. В случае воз­никновения ошибки этот метод бросает java.io.lOException, как,
        впрочем, и большинство методов, связанных с вводом-выводом.
    </p>
    <p>Для записи в поток сразу некоторого количества байт методу write() передается массив
        байт. Или, если мы хотим записать только часть масси­ва, то передаем массив byte[] и два
        int-числа — отступ и
        количество байт для записи. Понятно, что если указать неверные параметры -
        например, отрицательный отступ, отрицательное количество байт для записи, либо
        если сумма отступ плюс длина будет больше длины массива, — во всех этих случаях
        кидается исключение IndexOutOfBoundsException.
    </p>
    <p>Реализация потока может быть такой, что данные записываются не сразу, а
        хранятся некоторое время в памяти. Например, мы хотим запи­сать в файл какие-то
        данные, которые получаем порциями по 10 байт, и так 200 раз подряд. В таком
        случае вместо 200 обращений к файлу удоб­ней будет скопить все эти данные в
        памяти, а потом одним заходом запи­сать все 2000 байт. То есть класс выходного
        потока может использовать не­который внутренний механизм для буферизации
        (временного хранения перед отправкой) данных. Чтобы убедиться, что данные
        записаны в поток, а не хранятся в буфере, вызывается метод flush(), определенный в
        OutputStream.
        В этом классе его
        реализация пустая, но если какой-либо из наследников использует буферизацию
        данных, то этот метод должен быть в нем переопределен.
    </p>
    <p>Когда работа с потоком закончена, его следует закрыть. Для этого
        вызывается метод close(). Этот метод сначала освобождает буфер (вызо­вом метода flush),
        после чего поток
        закрывается и освобождаются все свя­занные с ним системные ресурсы. Закрытый
        поток не может выполнять операции вывода и не может быть открыт заново. В
        классе OutputStream реализация метода close() не производит
        никаких действий.
    </p>
    <p>Итак, классы InputStream и OutputStream определяют
        необходимые методы для работы с байтовыми потоками данных. Эти классы являются
        абстрактными. Их задача — определить общий интерфейс для классов, ко­торые
        получают данные из различных источников. Такими источниками могут быть,
        например, массив байт, файл, строка и т.д. Все они, или, по крайней мере,
        наиболее распространенные, будут рассмотрены далее.
    </p>
    <p>
    </p>
    <p>Классы-реализации потоков данных
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>Классы ByteArraylnputStream и ByteArrayOutputStream
    </p>
    <p>Самый естественный и простой источник, откуда можно считывать байты, -
        это, конечно, массив байт. Класс ByteArraylnputStream пред­ставляет
        поток, считывающий данные из массива байт. Этот класс имеет конструктор,
        которому в качестве параметра передается массив byte[]. Соответственно,
        при вызове методов read() возвращаемые данные будут браться именно из этого массива.
        Например:
    </p>
    <p>
    </p>
    <p>byte[] bytes = {1,-1,0};
    </p>
    <p>ByteArraylnputStream in = new
        ByteArraylnputStream(bytes); int readedlnt = in.read(); // readedlnt=1
        System.out.println("first
        element read is: " +readedlnt); readedlnt = in.read();
    </p>
    <p>// readedlnt=255. Однако (byte)readedlnt
        даст значение -1 System.out.println("second element read is: "
        +readedlnt); readedlnt = in.read(); // readedlnt=0 System.out.println("third
        element read is: " +readedlnt);
    </p>
    <p>
    </p>
    <p>Если запустить такую
        программу, на экране отобразится следующее:
    </p>
    <p>first element read is: 1 second
        element read is: 255 third element read is: 0
    </p>
    <p>
    </p>
    <p>При вызове метода read() данные считывались из массива bytes, переданного в
        конструктор ByteArraylnputStream. Обратите внимание, в данном примере второе считанное
        значение равно
        255, а не -1, как можно было бы ожидать. Чтобы понять, почему это произошло, нужно
        вспомнить, что метод read считывает byte, но возвращает
        значение int, полученное добавлением необходимого числа нулей (в двоичном
        представлении). Байт, равный -1, в двоичном представлении имеет вид 11111111
        и, соответственно, число
        типа int, получаемое приставкой 24-х нулей, равно 255 (в десятичной системе).
        Однако если явно привести его к byte, получим исходное значение.
    </p>
    <p>Аналогично, для записи байт в массив применяется класс ByteArrayOutputStream. Этот класс
        использует внутри себя объект byte[], куда записывает
        данные, передаваемые при вызове методов write(). Чтобы получить записанные в массив данные,
        вызывается метод toByteArray(). Пример:
    </p>
    <p>ByteArrayOutputStream
        out = new ByteArrayOutputStream();
    </p>
    <p>out.write(IO);
    </p>
    <p>out.write(11 );
    </p>
    <p>byte[] bytes = out.toByteArrayO;
    </p>
    <p>В этом примере в результате массив bytes будет состоять из двух элементов: 10
        и 11.
    </p>
    <p>Использовать классы ByteArraylnputStream и ByteArrayOutputStream может быть очень
        удобно, когда нужно проверить, что именно записывается в выходной поток
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>
        Например, при отладке и тестировании сложных процессов записи и чтения из
        потоков. Эти классы хороши тем, что позволяют сразу про­смотреть результат и не
        нужно создавать ни файл, ни сетевое соединение, ни что-либо еще.
    </p>
    <p>
    </p>
    <p>Классы FilelnputStream и FileOutputStream
    </p>
    <p>Класс FilelnputStream используется для
        чтения данных из файла. Конструктор такого класса в качестве параметра
        принимает название файла, из которого будет производиться считывание. При
        указании строки имени файла нужно учитывать, что она будет напрямую передана
        операционной системе, поэтому формат имени файла и пути к нему может
        различаться на разных платформах. Если при вызове этого конструктора передать
        строку, указывающую на несуществующий файл или каталог, то будет брошено
        java.io.FileNotFoundException. Если же объект успешно создан, то при вызове его методов
        read() возвращаемые
        значения будут считываться из указанного файла.
    </p>
    <p>Для записи байт в файл используется класс FileOutputStream. При создании объектов этого
        класса, то есть при вызовах его
        конструкторов, кроме имени файла, также можно указать, будут ли данные
        дописываться в конец файла, либо файл будет перезаписан. Если указанный файл не
        существует, то сразу после создания FileOutputStream он будет создан.
        При вызовах методов write() передаваемые значения будут записываться в этот файл. По
        окончании
        работы необходимо вызвать метод close(), чтобы сообщить системе, что работа по записи файла
        закончена. Пример: byte[]
        bytesToWrite = {1,2,3}; byte[] bytesReaded = new byte[10]; String fileName = "d:
        \\test.txt";
        try{
    </p>
    <p>// Создать выходной поток
    </p>
    <p>FileOutputStream outFile = new
        FileOutputStream(fileName); System.out.println("Фaйл открыт для записи"); // Записать массив
        outFile.
        write(bytesToWrite);
    </p>
    <p>System.out.println("3anncaHO:" + bytesToWrite.length + " байт"); // По окончании
        использования должен быть закрыт outFile.
        close();
    </p>
    <p>System.out.println("BbixoflHOH поток
        закрыт"); // Создать входной поток
    </p>
    <p>FilelnputStream inFile = new FilelnputStream(fileName); System.out.рппАп("Файл открыт для
        чтения"); // Узнать, сколько байт
        готово к считыванию int
        bytesAvailable = inFile.available();
    </p>
    <p>System.out.pnntln(ToTOBo к считыванию: " + bytesAvailable
        +
    </p>
    <p>" байт"); // Считать в массив
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>int count = inFile.read(bytesReaded,0,bytesAvailable);
        System.out.рппт1п("Считано:" + count + " байт"); for (int i=0;
        kcount; i++)
    </p>
    <p>System .out. print(bytesReaded [i]+",");
        System.out.println(); inFile.close();
    </p>
    <p>System.о^.рпп:1п("Входной поток закрыт"); } catch (FileNotFoundException e) {
    </p>
    <p>System.out.рпппп("Невозможно произвести запись в файл: " + fileName);
        } catch (lOException e) {
    </p>
    <p>System.out.рппг1п("Ошибка ввода/вывода:" + e.toString());
    </p>
    <p>
    </p>
    <p>Результатом работы
        программы будет:
    </p>
    <p>файл открыт для записи Записано: 3 байт Выходной поток закрыт Файл
        открыт для чтения Готово к считыванию: 3 байт
    </p>
    <p>Считано: 3 байт 1,2,3,
    </p>
    <p>Входной поток закрыт
    </p>
    <p>При работе с FilelnputStream метод available() практически наверняка вернет дпину файла, то
        есть число байт, сколько
        вообще из него можно считать. Но не стоит закладываться на это при написании
        программ, которые должны устойчиво работать на различных платформах,— метод available()
        возвращает число байт, которое может быть на данный момент считано
        без блокирования. Тот факт, что, скорее всего, это число и будет длиной файла,
        является всего лишь частным случаем работы на некоторых платформах.
    </p>
    <p>В приведенном примере для наглядности закрытие потоков производилось
        сразу же после окончания их использования в основном блоке. Однако лучше
        закрывать потоки в finally блоке.
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>} finally {
    </p>
    <p>try{inFile.close();}catch(IOException е){}; }
    </p>
    <p>Такой подход гарантирует, что поток будет закрыт и будут освобождены все
        связанные с ним системные ресурсы.
    </p>
    <p>
    </p>
    <p>PipedlnputStream и PipedOutputStream
    </p>
    <p>Классы PipedlnputStream и PipedOutputStream характеризуются
        тем, что их объекты всегда используются в паре - к одному объекту PipedlnputStream
        привязывается
        (подключается) один объект PipedOutputStream. Они могут быть полезны, если в программе
        необхо­димо организовать
        обмен данными между модулями (например, между потоками выполнения).
    </p>
    <p>Эти классы применяются следующим образом: создается по объекту PipedlnputStream и
        PipedOutputStream, после чего они могут быть соеди­нены между собой. Один объект
        PipedOutputStream может быть соединен
        с ровно одним объектом PipedlnputStream, и наоборот. Затем в объект PipedOutputStream
        записываются
        данные, после чего они могут быть счи­таны именно в подключенном объекте PipedlnputStream
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Такое соедине­ние можно обеспечить либо вызовом метода connect() с передачей
        соот­ветствующего
        объекта Pipedl/OStream (будем так кратно
        обозначать пару классов, в данном случае PipedlnputStream и PipedOutputStream), либо
        передать этот объект еще при вызове конструктора.
    </p>
    <p>Использование связки PipedlnputStream и PipedOutputStream показано в
        следующем примере:
    </p>
    <p>try {
    </p>
    <p>int countRead = 0;
    </p>
    <p>byte[] toRead = new byte[100];
    </p>
    <p>PipedlnputStream
        pipeln = new PipedlnputStream();
    </p>
    <p>PipedOutputStream
        pipeOut= new PipedOutputStream(pipeln);
    </p>
    <p>// Считывать в массив,
        пока он полностью не будет заполнен
    </p>
    <p>while(countRead&lt;toRead.length) {
    </p>
    <p>// Записать в поток некоторое количество байт
    </p>
    <p>for(inti=0; i&lt;(Math.random()*10); i++) {
    </p>
    <p>pipeOut.write((byte)(Math.random()*127));
    </p>
    <p>}
    </p>
    <p>// Считать из потока доступные данные,
    </p>
    <p>// добавить их к уже считанным.
    </p>
    <p>int willRead = pipeln.availableO;
    </p>
    <p>if (willRead+countReadMoRead.length)
    </p>
    <p>//Нужно считать только до предела массива
    </p>
    <p>willRead = toRead.length-countRead;
    </p>
    <p>countRead += pipeln.read(toRead, countRead, willRead);
    </p>
    <p>}
    </p>
    <p>} catch
        (lOException e) {
    </p>
    <p>System.out.println
        ("Impossible lOException occur: "); e. printStackTrace(
        ) ;
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Данный пример носит чисто демонстративный характер (в результа­те его
        работы массив toRead будет заполнен
        случайными числами). Более явно выгода от использования Pipedl/OStream в основном
        проявляется при разработке многопоточного приложения. Если в
        программе запуска­ется несколько потоков исполнения, организовать передачу
        данных меж­ду ними удобно с помощью этих классов. Для этого нужно создать
        связан­ные объекты Pipedl/OStream, после чего передать ссылки на них в соот­ветствующие
        потоки. Поток
        выполнения, в котором производится чтение данных, может содержать подобный код:
    </p>
    <p>
    </p>
    <p>// inStream - объект класса PipedlnputStream
        try {
    </p>
    <p>while(true) {
    </p>
    <p>byte[] readedBytes = null; synchronized(inStream) { int bytesAvailable =
        inStream.available();
        readedBytes = new byte[bytesAvailable]; inStream.read(readedBytes);
    </p>
    <p>}
    </p>
    <p>// обработка полученных данных из readedBytes
    </p>
    <p>II-
    </p>
    <p>) catch(IOException
        e) {
    </p>
    <p>/* lOException будет брошено, когда поток inStream, либо связанный с ним PipedOutputStream,
        уже закрыт, и при этом производится попытка считывания из inStream */
        System.out.println("pa6oTa с потоком inStream завершена");
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>}
    </p>
    <p>Если с объектом inStream одновременно могут
        работать несколько потоков выполнения, то необходимо использовать блок synchronized (как и
        сделано в
        примере), который гарантирует, что в период между вызо­вами inStream.availableO и
        inStream.read(...) ни в каком
        другом потоке выполнения не будет производиться считывание из inStream. Поэтому вызов
        inStream.read(readedBytes) не приведет к блокировке и все дан­ные, готовые к считыванию,
        будут
        считаны.
    </p>
    <p>
    </p>
    <p>StringBufferlnputStream
    </p>
    <p>Иногда бывает удобно работать с текстовой строкой String как с потоком байт. Для этого можно
        воспользоваться классом StringBufferlnputStream. При создании объекта этого класса
        необходимо передать конструктору
        объект String. Данные, возвращаемые методом read(), будут
        считываться именно из этой строки. При этом символы будут преобразовываться в
        байты с потерей точности - старший байт отбрасы­вается (напомним, что символ char состоит из
        двух байт).
    </p>
    <p>
    </p>
    <p>SequencelnputStream
    </p>
    <p>Класс SequencelnputStream объединяет поток
        данных из других двух и более входных потоков. Данные будут вычитываться
        последовательно -сначала все данные из первого потока в списке, затем из
        второго, и так далее. Конец потока SequencelnputStream будет достигнут
        только тогда, когда будет достигнут конец потока, последнего в списке.
    </p>
    <p>В этом классе имеется два конструктора — принимающий два пото­ка и
        принимающий Enumeration (в котором,
        конечно, должны быть толь­ко экземпляры InputStream и его наследников).
        Когда вызывается метод read(), SequencelnputStream пытается считать
        байт из текущего входно­го потока. Если в нем больше данных нет (считанное из
        него значение равно -1), у него вызывается метод close() и следующий входной
        поток становится текущим. Так продолжается до тех пор, пока не будут получе­ны
        все данные из последнего потока. Если при считывании обнаружива­ется, что
        больше входных потоков нет, SequencelnputStream
        возвращает -1. Вызов
        метода close() у SequencelnputStream
        закрывает все содержа­щиеся
        в нем входные потоки. Пример:
    </p>
    <p>
    </p>
    <p>FilelnputStream
        inFilel = null; FilelnputStream inFile2 = null;
        SequencelnputStream sequenceStream = null;
        FileOutputStream outFtte = null; try{
    </p>
    <p>inFilel = new
        FilelnputStream("file1 .txt");
    </p>
    <p>inFile2 = new FilelnputStream("file2.txt");
    </p>
    <p>sequenceStream = new
        SequencelnputStream(inFile1, inFile2);
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>outFile = new FileOutputStreamCfile3.txt");
    </p>
    <p>int readedByte = sequenceStream.read();
    </p>
    <p>while( readedByte!—1){
    </p>
    <p>outFile.write(readedByte);
    </p>
    <p>readedByte = sequenceStream.read();
    </p>
    <p>}
    </p>
    <p>} catch
        (lOException e) {
    </p>
    <p>System.out.println("IOException: " + e.toStringO); } finally {
    </p>
    <p>try{sequenceStrearn.close();}catch(IOException e){};
        try{outFile.close();}catch(IOException e){};
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>В результате выполнения этого примера в файл file3.txt будет запи­сано содержимое файлов
        filel .txt и file2.txt — сначала полностью
        filel .txt, потом file2.txt. Закрытие потоков производится в блоке finally. Посколь­ку при
        вызове метода close() может возникнуть lOException, необходим try-catch блок. Причем, каждый
        вызов метода close() взят в отдельный try-catch блок - для того, чтобы возникшее исключение
        при закрытии од­ного потока
        не помешало закрытию другого. При этом нет необходимос­ти закрывать потоки inFilel и inFile2
        - они будут
        автоматически закрыты при использовании в sequnceStream - либо когда в них закончатся
        дан­ные, либо при вызове у sequenceStream метода close().
    </p>
    <p>Объект SequencelnputStream
        можно было создать и
        другим спосо­бом: сначала получить объект Enumeration, содержащий все потоки, п передать его
        в конструктор SequencelnputStream:
    </p>
    <p>Vector vector = new Vector();
    </p>
    <p>vector.add(new StringBufferlnputStreamf'Begin
        filel\n")); vector.add(new FilelnputStream("file1 .txt"));
    </p>
    <p>vector.add(new StringBufferlnputStream("\nEnd of
        filel, begin file2\n")); vector.add(new
        FilelnputStream("file2.txt")); vector.add(new
        StringBufferlnputStream("\nEnd of file2")); Enumeration enum = vector.elements();
        sequenceStream = new SequencelnputStream(enum);
    </p>
    <p>Если заменить в предыдущем примере инициализацию sequenceStream на приведенную
        здесь, то в файл file3.txt, кроме содержимого файлов filet .txt и file2.txt, будут записаны
        еще три строки -одна в начате файла, одна между
        содержимым файлов filel .txt и file2.txt и еще одна в конце file3.txt.
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>Классы FilterlnputStreeam и FilterOutputStream и их наследники
    </p>
    <p>Задачи, возникающие при вводе/выводе весьма разнообразны - это может
        быть считывание байт из файлов, объектов из файлов, объектов из массивов,
        буферизованное считывание строк из массивов и т.д. В такой ситуации решение с использованием
        простого наследования приводит к возникновению слишком большого числа
        подклассов
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Более эффективно применение надстроек (в ООП этот шаблон называется
        адаптер) Надст­ройки — наложение дополнительных объектов для получения новых
        свойств и функций. Таким образом, необходимо создать несколько до­полнительных
        объектов - адаптеров к классам ввода/вывода. В java.io их еще называют фильтрами. При этом
        надстройка-фильтр включает в себя
        интерфейс объекта, на который надстраивается, поэтому может быть, в свою
        очередь, дополнительно надстроена.
    </p>
    <p>В java.io интерфейс для таких
        надстроек ввода/вывода предоставля­ют классы FilterlnputStream (для входных
        потоков) и FilterOutputStream (для выходных
        потоков). Эти классы унаследованы от основных базовых классов ввода/вывода - InputStream и
        OutputStream, соответственно. Конструктор FilterlnputStream принимает в
        качестве параметра объект InputStream и имеет модификатор
        доступа protected.
    </p>
    <p>Классы Filterl/OStream являются базовыми
        для надстроек и опреде­ляют общий интерфейс для надстраиваемых объектов.
        Потоки-надстройки не являются источниками данных. Они лишь модифицируют
        (расширяют) работу надстраиваемого потока.
    </p>
    <p>BufferedlnputStream и BufferedOutputStream
    </p>
    <p>На практике при считывании с внешних устройств ввод данных поч­ти всегда
        необходимо буферизировать. Для буферизации данных служат классы BufferedlnputStream и
        BufferedOutputStream.
    </p>
    <p>BufferedlnputStream содержит массив
        байт, который служит буфе­ром для считываемых данных. То есть когда байты из
        потока считываются либо пропускаются (метод skipQ), сначала
        заполняется буферный массив, причем, из надстраиваемого потока загружается
        сразу много байт, чтобы не требовалось обращаться к нему при каждой операции read или skip.
        Также класс BufferedlnputStream добавляет поддержку
        методов mark() и reset(). Эти методы определены еще в классе InputStream, но там их
        реа­лизация по умолчанию бросает исключение lOException. Метод mark() запоминает точку во
        входном потоке, а вызов метода reset() приводит к тому,
        что все байты, полученные после последнего вызова mark(), будут
        считываться повторно, прежде, чем новые байты начнут поступать из надстроенного
        входного потока.
    </p>
    <p>BufferedOutputStream предоставляет
        возможность производить многократную запись небольших блоков данных без
        обращения к устрой­ству вывода при записи каждого из них
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Сначала данные
        записываются во внутренний буфер. Непосредственное обращение к устройству
        вывода и, соответственно, запись в него, произойдет, когда буфер заполнится.
        Ини­циировать передачу содержимого буфера на устройство вывода можно и явным
        образом, вызвав метод flush(). Так же буфер освобождается перед закрытием потока. При этом
        будет
        закрыт и надстраиваемый поток (так же поступает BufferedlnputStream).
    </p>
    <p>Следующий пример наглядно демонстрирует повышение скорости считывания
        данных из файла с использованием буфера:
    </p>
    <p>try {
    </p>
    <p>String fileName = "d:\\file1"; InputStream
        inStream = null; OutputStream outStream = null; //Записать в файл некоторое количество байт
        long
        timeStart = System.currentTimeMillis(); outStream = new FileOutputStream(fileName);
        outStream = new BufferedOutputStream(outStream); for(int &#161;=1000000; -i&gt;=0;) {
        outStream.write(i);
    </p>
    <p>}
    </p>
    <p>long time = System.currentTimeMillis() - timeStart;
        System.out.println("Writing time: " + time + " millisec"); outStream.close();
    </p>
    <p>// Определить
        время считывания без буферизации
    </p>
    <p>timeStart = System.currentTimeMillis();
    </p>
    <p>inStream
        = new FilelnputStream(fileName);
    </p>
    <p>while(inStream.read()!=-1){
    </p>
    <p>}
    </p>
    <p>time = System.currentTimeMillis() - timeStart;
        inStream.close();
    </p>
    <p>System.out.println("Direct
        read time:" + (time) + " millisec");
    </p>
    <p>// Теперь применим буферизацию
    </p>
    <p>timeStart
        = System.currentTimeMillis();
    </p>
    <p>inStream
        = new FilelnputStream(fileName);
    </p>
    <p>inStream
        = new BufferedlnputStream(inStream);
    </p>
    <p>while(inStream.read()!=-1){
    </p>
    <p>}
    </p>
    <p>time = System.currentTimeMillis() - timeStart;
        inStream.close();
    </p>
    <p>System.out.printlnf'Buffered read time:"
        + (time) + " millisec"); } catch (lOException e) {
    </p>
    <p>System.out.printlnf'IOException:"
        + e.toStringO); e. pri ntStackTrace();
    </p>
    <p>}
    </p>
    <p>Результатом могут быть,
        например, такие значения:
    </p>
    <p>
    </p>
    <p>Writing time: 359 millisec Direct read time: 6546 millisec
        Buffered read time: 250 millisec
    </p>
    <p>В данном случае не производилось никаких дополнительных вычис­лений,
        занимающих процессорное время, только запись и считывание из файла. При этом
        считывание с использованием буфера заняло в 10 (!) раз меньше времени, чем
        аналогичное без буферизации. Для более быстрого
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>выполнения программы запись в
        файл производилась с буферизацией, однако ее влияние на скорость записи
        нетрудно проверить, убрав из про­граммы строку, создающую BufferedOutputStream.
    </p>
    <p>Классы Bufferedl/OStream добавляют только
        внутреннюю логику обработки запросов, но не добавляют никаких новых методов.
        Следующие два фильтра предоставляют некоторые дополнительные возможности для
        работы с потоками.
    </p>
    <p>LineNumberlnputStream
    </p>
    <p>Класс LineNumberlnputStream во время чтения
        данных производит подсчет, сколько строк было считано из потока. Номер строки,
        на которой в данный момент происходит чтение, можно узнать путем вызова метода
        getLineNumber(). Также можно и перейти к определенной строке вызовом метода
        setLineNumber(int lineNumber).
    </p>
    <p>Под строкой при этом понимается набор байт, оканчивающийся ли­бо '\п\
        либо 'У, либо их комбинацией '\г\п', именно в этой последова­тельности.
    </p>
    <p>Аналогичный класс для исходящего потока отсутствует. LineNumberlnputStream, начиная с версии
        1.1, объявлен deprecated, то есть использовать его не рекомендуется. Его заменил класс
        LineNumberReader (рассматривается
        ниже), принцип работы которого точно такой же.
    </p>
    <p>
    </p>
    <p>PushBacklnputStream
    </p>
    <p>Этот фильтр позволяет вернуть во входной поток считанные из него данные.
        Такое действие производится вызовом метода unread(). Понят­но, что
        обеспечивается подобная функциональность за счет наличия в классе специального
        буфера - массива байт, который хранит считанную информацию. Если будет произведен
        откат (вызван метод unread), то во время следующего считывания эти данные будут выдаваться
        еще раз
        как только полученные. При создании объекта можно указать размер буфера.
    </p>
    <p>
    </p>
    <p>PrintStream
    </p>
    <p>Этот класс используется для конвертации и записи строк в байтовый поток.
        В нем определен метод print(...), принимающий в качестве аргу­мента различные примитивные
        типы Java, а также тип Object. При вызове
        передаваемые данные будут сначала преобразованы в строку вызовом ме­тода String.valueOf(),
        после чего
        записаны в поток. Если возникает ис­ключение, оно обрабатывается внутри метода print и
        дальше не бросается (узнать, произошла ли ошибка, можно с помощью
        метода checkError()). При записи символов в виде байт используется кодировка, принятая по
        умолчанию в операционной системе (есть возможность задать ее явно при запуске JVM).
    </p>
    <p>Этот класс также является
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>deprecated, поскольку работа с кодиров­ками требует особого подхода (зачастую у
        двухбайтовых символов Java старший байт просто
        отбрасывается). Поэтому в версии Java 1.1 появился
        дополнительный набор классов, основывающийся на типах Reader и Writer. Они будут рассмотрены
        позже. В частности, вместо PrintStream те­перь
        рекомендуется применять PrintWriter. Однако старый класс продолжает активно использоваться,
        поскольку статические
        поля out и err класса System имеют именно этот
        тип.
    </p>
    <p>
    </p>
    <p>DatalnputStream и DataOutputStream
    </p>
    <p>До сих пор речь шла только о считывании и записи в поток данных в виде byte. Для работы с
        другими примитивными типами данных Java определены
        интерфейсы Datalnput и DataOutput и их реализации -классы-фильтры DatalnputStream и
        DataOutputStream. Их место в иерархии классов ввода/вывода можно увидеть на рис. 15.1.
    </p>
    <p>Интерфейсы Datalnput и DataOutput определяют, а классы DatalnputStream
        и DataOutputStream, соответственно, реализуют методы считывания и записи значений всех
        примитивных типов. При этом проис­ходит конвертация этих данных в набор byte и обратно.
        Чтение
        необходи­мо организовать так, чтобы данные запрашивались в виде тех же типов, в
        той же последовательности, как и производилась запись. Если записать, например,
        int и long, а потом считывать их как short, чтение будет выпол­нено корректно, без
        исключительных ситуаций, но числа
        будут получены совсем другие.
    </p>
    <p>Это наглядно показано в
        следующем примере:
    </p>
    <p>
    </p>
    <p>try {
    </p>
    <p>ByteArrayOutputStream
        out = new ByteArrayOutputStream(); DataOutputStream outData = new
        DataOutputStream(out); outData.writeByte(128);
    </p>
    <p>// этот метод принимает аргумент int, но записывает
    </p>
    <p>// лишь младший байт
    </p>
    <p>outData.writelnt(128);
    </p>
    <p>outData.writeLong( 128);
    </p>
    <p>outData.writeDouble(128);
    </p>
    <p>outData. closeO;
    </p>
    <p>byte[] bytes = out.toByteArrayO; InputStream in = new ByteArraylnputStream(bytes);
        DatalnputStream inData = new DatalnputStream(in); System.out.println("4TeHne в правильной
        последовательности: "); System.out.println("readByte: " + inData.readByte());
        System.out.printlnf'readlnt:
        " + inData.readlntO); System.out.printlnfreadLong: " + inData.readLongO);
        System.out.printlnfreadDouble: " + inData.readDouble()); inData.close();
    </p>
    <p>System.ои!рппт1п("Чтение
        в измененной последовательности:");
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>in = new ByteArraylnputStream(bytes);
    </p>
    <p>inData = new DatalnputStream(in);
    </p>
    <p>System.out.println("readlnt: " + inData.readlnt());
    </p>
    <p>System.out.printlnf'readDouble: " + inData.readDouble());
    </p>
    <p>System.out.println("readLong: " + inData.readLong());
    </p>
    <p>inData.close();
    </p>
    <p>} catch (Exception e) {
    </p>
    <p>System.out.printlnf'lmpossible lOException occurs: "
        + e.toStringO); e.printStackTrace();
    </p>
    <p>}
    </p>
    <p>Результат выполнения профаммы: Чтение в правильной последовательности:
    </p>
    <p>
    </p>
    <p>read Byte: -128 readlnt: 128 readLong: 128 readDouble: 128.0
    </p>
    <p>
    </p>
    <p>Чтение в измененной последовательности:
    </p>
    <p>
    </p>
    <p>readlnt: -2147483648 readDouble: -0.0
    </p>
    <p>readLong:-9205252085229027328
    </p>
    <p>
    </p>
    <p>Итак, значение любого примитивного типа может быть передано и считано из
        потока данных.
    </p>
    <p>
    </p>
    <p>Сериализация объектов (serialization)
    </p>
    <p>Для объектов процесс преобразования в последовательность байт и обратно
        организован несколько сложнее - объекты имеют различную структуру, хранят
        ссылки на другие объекты и т.д. Поэтому такая процеду­ра получила специальное
        название - сериализация (serialization), обратное действие, — то есть воссоздание объекта из
        последовательности байт — де-сериализация.
    </p>
    <p>Поскольку сериализованный объект - это последовательность байт, которую
        можно легко сохранить в файл, передать по сети и т.д., то и объ­ект затем можно
        восстановить на любой машине, вне зависимости от того, где проводилась
        сериализация. Разумеется, Java позволяет не
        задумывать­ся при этом о таких факторах, как, например, используемая
        операционная система на машине-отправителе и получателе. Такая гибкость
        обусловила широкое применение сериализации при создании распределенных прило­жений,
        в том числе и корпоративных (enterprise) систем.
    </p>
    <p>
    </p>
    <p>Стандартная сериализация
    </p>
    <p>Для представления объектов в виде последовательности байт опре­делены
        унаследованные от Datalnput и DataOutput интерфейсы Objectlnput и ObjectOutput,
        соответственно. В java.io имеются реализа­ции
        этих интерфейсов — классы ObjectlnputStream и ObjectOutputStream.
    </p>
    <p>Эти классы используют стандартный механизм сериализации, который
        предлагает JVM. Для того, чтобы объект мог быть сериализован, класс, от которого он
        порожден, должен реализовывать интерфейс java.io.Serializable. В этом интерфейсе не
        определен ни один метод. Он нужен лишь для
        указания, что объекты класса могут участвовать в сериализации
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> При попытке
        сериализовать объект, не имеющий такого интерфейса, будет брошен
        java.io.NotSerializableException.
    </p>
    <p>Чтобы начать сериализацию объекта, нужен выходной поток OutputStream, в который и будет
        записываться сгенерированная последова­тельность
        байт. Этот поток передается в конструктор ObjectOutputStream. Затем вызовом метода
        writeObject() объект сериализуется и записывается в выходной поток. Например:
    </p>
    <p>ByteArrayOutputStream
        os = new
        ByteArrayOutputStream(); Object objSave = new lnteger(1 );
    </p>
    <p>ObjectOutputStream oos = new ObjectOutputStream(os);
        oos.writeObject(objSave);
    </p>
    <p>Чтобы увидеть, во что превратился объект objSave, можно просмот­реть
        содержимое массива:
    </p>
    <p>
    </p>
    <p>byte[] bArray = os.toByteArray();
    </p>
    <p>
    </p>
    <p>А чтобы восстановить объект, его нужно десериализовать из этого массива:
    </p>
    <p>
    </p>
    <p>ByteArraylnputStream is = new
        ByteArraylnputStream(bArray); ObjectlnputStream ois = new
        ObjectlnputStream(is); Object objRead = ois.readObject();
    </p>
    <p>Теперь можно убедиться, что восстановленный объект идентичен Исходному:
    </p>
    <p>System.out.println("readed object is:" + objRead.toString());
        System.out.println("Object equality is:" +
    </p>
    <p>(objSave.equals(objRead)));
        System.out.println("Reference equality is:" + (objSave==objRead));
    </p>
    <p>Результатом выполнения приведенного выше кода будет:
    </p>
    <p>readed object is: 1 Object
        equality is: true Reference equality is: false
    </p>
    <p>
    </p>
    <p>Как мы видим, восстановленный объект не совпадает с исходным (что
        очевидно — ведь восстановление могло происходить и на другой ма­шине), но равен
        сериализованному по значению.
    </p>
    <p>Как обычно, для упрощения в примере была опущена обработка ошибок.
        Однако, сериализация (десериализация) объектов довольно сложная процедура,
        поэтому возникающие сложности не всегда очевидны. Рассмотрим основные
        исключения, которые может генерировать метод readObject() класса ObjectlnputStream.
    </p>
    <p>Предположим, объект некоторого класса TestClass был сериализован и
        передан по сети на другую машину для восстановления. Может случить­ся так, что
        у считывающей JVM на локальном диске
        не окажется описания этого класса (файл TestClass.class). Поскольку стандартный механизм
        се-риализации записывает в поток байт
        лишь состояние объекта, для успеш­ной десериализации необходимо наличие
        описание класса. В результате будет брошено исключение ClassNotFoundException.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Причина появления java.io.StreamCorruptedException вполне оче­видна из
        названия - неправильный формат входного потока. Предполо­жим, происходит
        попытка считать сериализованный объект из файла. Если этот файл испорчен (для
        эксперимента можно открыть его в текстовом ре­дакторе и исправить несколько
        символов), то стандартная процедура десе­риализации даст сбой. Эта же ошибка
        возникнет, если считать некоторое количество байт (с помощью метода read) непосредственно
        из надстраива­емого потока InputStream. В таком случае ObjectlnputStream снова обна­ружит
        сбой в формате данных и будет брошено исключение java.io.StreamCorruptedException.
    </p>
    <p>Поскольку ObjectOutput наследуется от DataOutput, ObjectOutputStream может быть
        использован для последовательной записи нескольких значений как объектных, так
        и примитивных типов в произвольной последовательности. Если при считывании
        будет вызван метод readObject, а в исходном пото­ке следующим на очереди записано значение
        примитивного типа, будет брошено исключение java.io.OptionalDataException. Очевидно, что для
        корректного восстановления данных из потока их нужно
        считывать именно в том порядке, в каком были записаны.
    </p>
    <p>
    </p>
    <p>Восстановление состояния
    </p>
    <p>Итак, сериализация объекта заключается в сохранении и восстановле­нии
        состояния объекта. В Java в большинстве
        случаев состояние описыва­ется значениями полей объекта. Причем, что важно, не
        только тех полей, которые были явно объявлены в классе, от которого порожден
        объект, но и унаследованных полей.
    </p>
    <p>Предположим, мы бы попытались своими силами реализовать стан­дартный
        механизм сериализации. Нам передается выходной поток, в ко­торый нужно записать
        состояние нашего объекта. С помощью DataOutput интерфейса можно
        легко сохранить значения всех доступных полей (будем для простоты считать, что
        они все примитивного типа). Од­нако в большинстве случаев в родительских
        классах могут быть объявле­ны недоступные нам поля (например, private). Тем не менее,
        такие поля, как правило, играют важную роль в определении состояния объекта,
        так как они могут влиять на результат работы унаследованных методов. Как же
        сохранить их значения?
    </p>
    <p>С другой стороны, не меньшей проблемой является восстановление объекта.
        Как говорилось раньше, объект может быть создан только вызо­вом его
        конструктора
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> У класса, от которого порожден десериализуемый объект, может быть
        несколько конструкторов, причем, некоторые из них, или все, могут иметь
        аргументы. Какой из них вызвать? Какие значения передать в качестве аргументов?
    </p>
    <p>После создания объекта необходимо установить считанные значе­ния его
        полей. Однако многие классы имеют специальные set-методы для этой
        цели. В таких методах могут происходить проверки, могут меняться значения
        вспомогательных полей. Пользоваться ли этими методами? Если их несколько, то
        как выбрать правильный и какие параметры ему пере­дать? Снова возникает
        проблема работы с недоступными полями, полу­ченными по наследству. Как же в
        стандартном механизме сериализации решены все эти вопросы?
    </p>
    <p>Во-первых, рассмотрим подробнее работу с интерфейсом Serializable. Заметим, что класс Object
        не реализует этот
        интерфейс. Та­ким образом, существует два варианта - либо сериализуемый класс
        на­следуется от Serializable-класса, либо нет. Первый вариант довольно прост. Если
        родительский
        класс уже реализовал интерфейс Serializable, то наследникам это свойство передается
        автоматически, то есть все объ­екты,
        порожденные от такого класса, или любого его наследника, могут быть
        сериализованы.
    </p>
    <p>Если же наш класс впервые реализует Serializable в своей ветке насле­дования,
        то его суперкласс должен отвечать специальному требованию — у него должен быть
        доступный конструктор без параметров. Именно с помо­щью этого конструктора
        будет создан десериализуемый объект и будут про-инициализированы все поля,
        унаследованные от классов, не наследующих Serializable.
    </p>
    <p>Рассмотрим пример:
    </p>
    <p>
    </p>
    <p>// Родительский класс, не реализующий Serializable public class Parent {
    </p>
    <p>public String
        firstName; private String lastName; public Parent(){
    </p>
    <p>System.out.printlnf'Create Parent");
        firstName="old_first"; lastName-'oldjast";
    </p>
    <p>}
    </p>
    <p>public void changeNames() { firstName="new_first";
        lastName="new_last";
    </p>
    <p>}
    </p>
    <p>public String toString() {
    </p>
    <p>return
        super.toString()+",first="+firstName+",last="+lastName;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>// Класс Child, впервые реализовавший Serializable
        public class Child extends Parent implements Serializable { private int age;
        public Child(int age) {
    </p>
    <p>System.out.println("Create Child");
        this.age=age;
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>}
    </p>
    <p>public String toString() {
    </p>
    <p>return super. toString()+",age="+age;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>// Наследник Serializable-класса public
        class Child2 extends Child { private int size;
    </p>
    <p>public Child2(int age, int size) { super(age);
    </p>
    <p>System.out.println("Create Child2");
    </p>
    <p>this.size=size;
    </p>
    <p>}
    </p>
    <p>public String toString() {
    </p>
    <p>return super.toString()+",size="+size;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>// Запускаемый класс для теста public class Test {
    </p>
    <p>public static void main(String[] arg) { try {
    </p>
    <p>FileOutputStream fos=new
        FileOutputStream("output.bin");
    </p>
    <p>ObjectOutputStream oos=new ObjectOutputStream(fos);
    </p>
    <p>Child c=new
        Child(2);
    </p>
    <p>c.changeNames();
    </p>
    <p>System.out.println(c);
    </p>
    <p>oos.writeObject(c);
    </p>
    <p>oos.writeObject(new Child2(3, 4));
    </p>
    <p>oos.closeO;
    </p>
    <p>System.out.println("Read objects:");
    </p>
    <p>FilelnputStream fis=new FilelnputStreamf'output.bin");
    </p>
    <p>ObjectlnputStream ois=new ObjectlnputStream(fis);
    </p>
    <p>System.out.println(ois.readObject());
    </p>
    <p>System.out.println(ois.readObject());
    </p>
    <p>ois.close();
    </p>
    <p>} catch (Exception e) {// упрощенная обработка для // краткости e.printStackTrace();
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>В этом примере объявлено 3 класса. Класс Parent не реализует Serializable и, следовательно,
        не может быть сериализован. В нем объяв­лено 2 поля, которые при создании
        получают значения, содержащие сло­во "old" ("старый").
        Кроме этого, объявлен метод, позволяющий модифи­цировать эти поля. Он
        выставляет им значения, содержащие слово "new" ("новый').
        Также переопределен метод toString(), чтобы дать возмож­ность узнать значения этих полей.
    </p>
    <p>Поскольку класс Parent имеет доступный
        конструктор по умолча­нию, его наследник может реализовать интерфейс Serializable. Обратите
        внимание, что у самого класса Child такого конструктора уже нет. Также объявлено поле и
        модифицирован метод toString().
    </p>
    <p>Наконец, класс Child2 наследуется от Child, а потому автоматически является допустимым для
        сериализации.
        Аналогично, имеет новое поле, значение которого отображает toString().
    </p>
    <p>Запускаемый класс Test сериализует в файл output.bin два объекта. Обратите внимание, что у
        первого из них предварительно
        вызывается метод changeNames(), который модифицирует значения полей, унаследованных от
        класса Parent.
    </p>
    <p>Результат выполнения примера:
    </p>
    <p>Create Parent Create Child
    </p>
    <p>Child@ad3ba4,tirst=new
        first,last=new_last,age=2
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Create Parent
    </p>
    <p>Create Child
    </p>
    <p>Create Child2
    </p>
    <p>Read objects:
    </p>
    <p>Create Parent
    </p>
    <p>Child@723d7c,first=old_first,last=old_last,age=2 Create
        Parent
    </p>
    <p>Child2@22c95b,first=old__first,last=old_last,age=3,size=4
    </p>
    <p>Во всех конструкторах вставлена строка, выводящая сообщение на консоль.
        Так можно отследить, какие конструкторы вызываются во время десериализации.
        Видно, что для объектов, порожденных от Serializable-классов, конструкторы не вызываются
        вовсе. Идет обращение лишь к
        конструктору без параметров He-Serializable-суперкласса.
    </p>
    <p>Сравним значения полей первого объекта и его копии, получен­ной
        десериализацией. Поля, унаследованные от He-Serializable-клас-са (firstName, lastName), не
        восстановились. Они имеют значения, полученные в конструкторе Parent без параметров. Поля,
        объявлен­ные в Serializable-классе, свои значения сохранили. Это верно и для второго объекта
        —
        собственные поля Child2 и унаследованные от Child имеют точно такие
        же значения, что и до сериализации. Их зна­чения были записаны, а потом считаны
        и напрямую установлены из потока данных.
    </p>
    <p>Иногда в классе есть поля, которые не должны участвовать в сериа­лизации.
        Тому может быть несколько причин. Например, это поле малосу­щественно
        (временная переменная) и сохранять его нет необходимости. Если сериализованный
        объект передается по сети, то исключение такого поля из сериализации позволяет
        уменьшить нагрузку на сеть и ускорить работу приложения.
    </p>
    <p>Некоторые поля хранят значения, которые не будут иметь смысла при
        пересылке объекта на другую машину, или при воссоздании его спус­тя какое-то
        время. Например, сетевое соединение, или подключение к ба­зе данных, в таких
        случаях нужно устанавливать заново.
    </p>
    <p>Затем, в объекте может храниться конфиденциальная информация, например,
        пароль. Если такое поле будет сериализовано и передано по сети, его значение
        может быть перехвачено и прочитано, или даже подменено.
    </p>
    <p>Для исключения поля объекта из сериализации его необходимо объ­явить с
        модификатором transient. Например, следующий класс:
    </p>
    <p>class Account implements
        java.io.Serializable { private String name; private String login; private
        transient String password; /* объявление других элементов класса
    </p>
    <p>
    </p>
    <p>7
    </p>
    <p>}
    </p>
    <p>У такого класса поле password в сериализации
        участвовать не будет и при восстановлении оно получит значение по умолчанию (в
        данном случае null).
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Особого внимания требуют статические поля. Поскольку они принадлежат
        классу, а не объекту, они не участвуют в сериализации. При восстановлении
        объект будет работать с таким значением static-поля, которое уже
        установлено для его класса в этой JVM.
    </p>
    <p>
    </p>
    <p>Граф сериализации
    </p>
    <p>До этого мы рассматривали объекты, которые имеют поля лишь примитивных
        типов. Если же сериализуемый объект ссылается на другие объекты, их также
        необходимо сохранить (записать в поток байт), а при десериализации —
        восстановить. Эти объекты, в свою очередь, также могут ссылаться на следующие
        объекты. При этом важно, что если несколько ссылок указывают на один и тот же
        объект, то этот объект должен быть сериализован лишь однажды, а при
        восстановлении все ссылки должны вновь указывать на него одного. Например,
        сериализуемый объект А ссылается на объекты В и С, каждый из которых, в свою очередь,
        ссылается на один и тот же
        объект D. После десериализации не должно возникать ситуации, когда В ссылается на D1, а С -
        на D2, где D1 и D2 — равные, но все же различные объекты.
    </p>
    <p>Курс
    </p>
    <p>Лекция 15
    </p>
    <p>Пакет
        java, io
    </p>
    <p>
    </p>
    <p>Для организации такого процесса стандартный механизм сериали-зации
        строит граф, включающий в себя все участвующие объекты и ссылки между ними.
        Если очередная ссылка указывает на некоторый объект, сначала проверяется - нет
        ли такого объекта в графе. Если есть -объект второй раз не сериализуется. Если
        нет - новый объект добавляет­ся в граф.
    </p>
    <p>При построении графа может встретиться объект, порожденный от класса, не
        реализующего интерфейс Serializable. В этом случае сериализация прерывается, генерируется
        исключение java.io.NotSerializableException.
    </p>
    <p>Рассмотрим пример:
    </p>
    <p>
    </p>
    <p>import Java.io.*;
    </p>
    <p>class Point implements Serializable { double x; double
        y;
    </p>
    <p>public Point(double x, double y) { this.x = x;
        this.у = у;
    </p>
    <p>}
    </p>
    <p>public String toString() {
    </p>
    <p>return
        "("+x+","+y+") reference-'+super.toString();
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>class Line implements Serializable { Point pointl;
        Point point2; int index; public Line() {
    </p>
    <p>System.out.println("Constructing empty
        line");
    </p>
    <p>}
    </p>
    <p>Line( Point p1, Point p2, int index) {
    </p>
    <p>System.out.println("Constructing line:" + index);
        this.pointl = p1; this.point2 = p2; this.index = index;
    </p>
    <p>}
    </p>
    <p>public int getlndex() {return index;}
    </p>
    <p>public void setlndexfint newlndex) {index = newlndex;}
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>public void printlnfo() {
    </p>
    <p>System.out.println("Line:" + index);
    </p>
    <p>System.out.printlnf Object reference: " + super.toString());
        System.out.printlnf' from point "+point1);
    </p>
    <p>System.out.printlnf'
        to point "+point2);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>public
        class Main {
    </p>
    <p>public static void main(java.lang.String[]
        args) { Point p1 = new Point(1.0,1.0); Point p2 = new Point(2.0,2.0); Point p3 =
        new Point(3.0,3.0); Line linei = new Line(p1 ,p2,1 ); Line Iine2 = new Line(p2,p3,2);
        System, out. printlnf'line 1 = " + linei); System.out.printlnf'line
        2 = " + Iine2); String fileName = "d:\\file"; try{
    </p>
    <p>// записываем объекты в файл
    </p>
    <p>FileOutputStream os = new FileOutputStream(fileName);
    </p>
    <p>ObjectOutputStream oos = new ObjectOutputStream(os);
    </p>
    <p>oos.writeObject(linel);
    </p>
    <p>oos.writeObject(line2);
    </p>
    <p>// меняем состояние linei и записываем его еще раз
    </p>
    <p>Iine1.setlndex(3);
    </p>
    <p>//oos.reset();
    </p>
    <p>oos.writeObject(line1 );
    </p>
    <p>// закрываем потоки
    </p>
    <p>// достаточно закрыть только поток-надстройку
    </p>
    <p>oos.closeO;
    </p>
    <p>// считываем объекты
    </p>
    <p>System.out.printlп("Read оbjects:");
    </p>
    <p>FilelnputStream is = new FilelnputStream(fileName);
    </p>
    <p>ObjectlnputStream ois = new ObjectlnputStream(is);
    </p>
    <p>for (int i=0; КЗ; i++) {// Считываем 3
        объекта
    </p>
    <p>Line line = (Line)ois.readObject();
    </p>
    <p>line.printlnfoQ;
        } ois.close(); } catch(ClassNotFoundException e) {
    </p>
    <p>e.printStackTrace(); } catch(IOException e) { e.printStackTrace();
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>В этой программе работа идет с классом Line (линия), который име­ет 2 поля типа Point (линия
        описывается двумя точками). Запускаемый класс Main создает два объекта класса Line, причем,
        одна из
        точек у них общая. Кроме этого, линия имеет номер (поле index). Созданные линии
        (номера 1 и 2) записываются в поток, после чего одна из них получает но­вый
        номер (3) и вновь сериализуется.
    </p>
    <p>Выполнение этой программы приведет к выводу на экран примерно
        следующего:
    </p>
    <p>
    </p>
    <p>Constructing line: 1 Constructing line: 2 line 1 = Line@7d39
        line 2 = Line@4ec Read objects: Line: 1
    </p>
    <p>Object reference: Line@331e from point (1.0,1.0) reference=Point@36bb
        to point (2.0,2.0) reference=Point@386e Line: 2
    </p>
    <p>Object reference: Line@6706 from point (2.0,2.0) reference=Point@386e
        to point (3.0,3.0) reference=Point@68ae Line: 1
    </p>
    <p>Object reference: Line@331e
    </p>
    <p>from point (1.0,1.0) reference=Point@36bb
    </p>
    <p>to point (2.0,2.0) reference=Point@386e
    </p>
    <p>
    </p>
    <p>Из примера видно, что после восстановления у линий сохраняется общая
        точка, описываемая одним и тем же объектом (хеш-код 386е).
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Третий записанный объект идентичен первому, причем, совпадают даже
        объектные ссылки. Несмотря на то, что при записи третьего объекта значение index было
        изменено на 3, в десериализованном объекте оно ос­талось равным 1.
        Так произошло потому, что объект, описывающий первую линию, уже был
        задействован в сериализации и, встретившись во второй раз, повторно записан не был.
    </p>
    <p>Чтобы указать, что сеанс сериализации завершен, и получить воз­можность
        передавать измененные объекты, у ObjectOutputStream нужно вызвать метод
        reset(). В рассматриваемом примере для этого достаточно убрать комментарий в
        строке
    </p>
    <p>
    </p>
    <p>//oos.reset();
    </p>
    <p>Если теперь запустить
        программу, то можно увидеть, что третий объект получит номер 3.
    </p>
    <p>Constructing line: 1 Constructing line: 2 line 1 = Line@ea2dfe
        Nne2 = Line@7182c1 Read objects: Line: 1
    </p>
    <p>Object reference: Line@a981ca from point (1.0,1.0) reference=Point@1503a3
        to point (2.0,2.0) reference=Point@a1c887 Line: 2
    </p>
    <p>Object reference: Line@743399 from point (2.0,2.0) reference=Point@a1c887
        to point (3.0,3.0) reference=Point@e7b241 Line: 3
    </p>
    <p>Object reference: Line@67d940
    </p>
    <p>from point (1.0,1.0) reference=Point@e83912
    </p>
    <p>to point (2.0,2.0) reference=Point@fae3c6
    </p>
    <p>Однако это будет уже новый объект, ссылка на который отличается от
        первой считанной линии. Более того, обе точки будут также описы­ваться новыми
        объектами. То есть в новом сеансе все объекты были запи­саны, а затем восстановлены
        заново.
    </p>
    <p>
    </p>
    <p>Расширение стандартной сериализации
    </p>
    <p>Некоторым сложно организованным классам требуется особый подход для
        сериализации. Для расширения стандартного механизма можно объявить в классе два
        метода с точно такой сигнатурой:
    </p>
    <p>private void
        writeObject(java.io.ObjectOutputStream out)
    </p>
    <p>throws lOException; private void
        readObject(java.io.ObjectlnputStream in)
    </p>
    <p>throws lOException, ClassNotFoundException;
    </p>
    <p>Если в классе объявлены такие методы, то при сериализации объекта Для
        записи его состояния будет вызван writeObject, который должен сгене­рировать
        последовательность байт и записать ее в
        поток out, полученный в качестве аргумента. При этом можно вызвать стандартный
        механизм записи объекта путем вызова метода
    </p>
    <p>out.defaultWriteObject();
    </p>
    <p>
    </p>
    <p>Этот метод запишет все не-transient и не-static поля в поток данных.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>В свою очередь, при десериализации метод readObject должен счи­тать
        данные из потока in (также полученного
        в качестве аргумента) и вос­становить значения полей класса. При реализации
        этого метода можно обратиться к стандартному механизму с помощью метода:
    </p>
    <p>
    </p>
    <p>in.defaultReadObject();
    </p>
    <p>
    </p>
    <p>Этот метод считывает описание объекта из потока и присваивает значения
        соответствующих полей в текущем объекте.
    </p>
    <p>Если же процедура сериализации в корне отличается от стандарт­ной, то для
        таких классов предназначен альтернативный интерфейс java.io.Externalizable.
    </p>
    <p>При использовании этого интерфейса в поток автоматически записы­вается
        только идентификация класса. Сохранить и восстановить всю ин­формацию о
        состоянии экземпляра должен сам класс. Для этого в нем должны быть объявлены
        методы writeExternalO и readExtemal() интерфей­са Externalizable. Эти методы должны
        обеспечить сохранение состояния, описываемого полями
        самого класса и его суперкласса.
    </p>
    <p>При восстановлении Extemalizable-объекта экземпляр создается путем вызова конструктора без
        аргументов,
        после чего вызывается метод readExternal.
    </p>
    <p>Метод writeExternal имеет сигнатуру:
    </p>
    <p>
    </p>
    <p>void
        writeExternal( Object-Output out) throws lOException;
    </p>
    <p>Для сохранения состояния вызываются методы Objectlnput, с помо­щью которых можно записать как
        примитивные, так и объектные
        значения. Для корректной работы в соответствующем методе
    </p>
    <p>void
        readExternal(Objectlnput in) throws lOException,ClassNotFoundException;
    </p>
    <p>
    </p>
    <p>эти значения должны быть считаны в том же самом порядке.
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>Классы Reader и Writer и их
        наследники
    </p>
    <p>Рассмотренные классы - наследники InputStream и OutputStream — работают с
        байтовыми данными. Если с их помощью записывать или считывать текст, то сначала
        необходимо сопоставить каждому символу его числовой код. Такое
        соответствие называется кодировкой.
    </p>
    <p>Известно, что Java использует
        кодировку Unicode, в которой симво­лы представляются двухбайтовым кодом. Байтовые потоки
        зачастую ра­ботают с
        текстом упрощенно — они просто отбрасывают старший байт каждого символа. В реальных
        же приложениях могут использовать раз­личные кодировки (даже для русского языка
        их существует несколько). Поэтому в версии Java 1.1 появился дополнительный набор классов,
        ос­новывающийся на типах Reader и Writer. Их иерархия представлена на рис. 15.2.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Эта иерархия очень схожа с аналогичной для байтовых потоков InputStream и OutputStream.
        Главное отличие между ними - Reader и Writer работают с потоком
        символов (char). Только, чтение массива символов в Reader описывается методом read(charfj),
        а запись в Writer -write(chartl).
    </p>
    <p>В таблице 15.1 приведены
        соответствия классов для байтовых и
    </p>
    <p>символьных потоков.
    </p>
    <p>Как видно из таблицы,
        различия крайне незначительны и предсказуемы.
    </p>
    <p></p>
    <center><img align="left" height="338" src="http://kufas.ru/java.files/image047.png"
                 width="428"></center>
    Например, конечно
    же, отсутствует преобразование в символьное представление примитивных типов Java и объектов
    (Datalnput/Output,
    <p>—                                                 I
    </p>
    <p></p>
    <center><img height="666" src="http://kufas.ru/java.files/image048.png" width="434"></center>
    Objectlnput/Output). Добавлены классы-мосты, преобразующие сим­вольные потоки в байтовые:
    InputStreamReader и OutputStreamWriter. Именно на их основе реализованы FileReader и FileWriter.
    Метод avail­able.;) класса InputStream в классе Reader отсутствует, он заменен мето­дом ready(),
    возвращающим
    булевое значение, - готов ли поток к считы­ванию (то есть будет ли считывание
    произведено без блокирования).
    <p>В остальном же использование символьных потоков идентично рабо­те с
        байтовыми потоками. Так, программный код для записи символьных данных в файл
        будет выглядеть примерно следующим образом:
    </p>
    <p>String fileName
        = "d:\Yfile.txt";
    </p>
    <p>//Строка, которая будет
        записана в файл
    </p>
    <p>String data = "Some
        data to be written and read.\n";
    </p>
    <p>try{
    </p>
    <p>FileWriter fw = new FileWriter(fileName);
    </p>
    <p>BufferedWriter bw = new BufferedWriter(fw);
    </p>
    <p>System.out.println("Write some data to file:"
        + fileName);
    </p>
    <p>// Несколько раз записать строку
    </p>
    <p>for(int i=(int)(Math.random()*10);--i&gt;=0;)
    </p>
    <p>bw.write(data); bw.close();
    </p>
    <p>// Считываем результат
    </p>
    <p>FileReader fr = new
        FileReader(fileName);
    </p>
    <p>BufferedReader br = new BufferedReader(fr);
    </p>
    <p>String s = null;
    </p>
    <p>int count = 0;
    </p>
    <p>System. out.printlnfRead data from file:" + fileName);
        // Считывать данные, отображая на экран while((s=br.readLine())!=null)
    </p>
    <p>System.out.printlnfrow"
        + ++count +
        " read:" + s); br.close(); } catch (Exception e) { e.printStackTrace();
    </p>
    <p>}
    </p>
    <p>Классы-мосты InputStreamReader и OutputStreamWriter при пре­образовании
        символов также используют некоторую кодировку. Ее мож­но задать, передав в
        конструктор в качестве аргумента ее название. Если оно не будет соответствовать
        никакой из известных кодировок, будет бро­шено исключение UnsupportedEncodingException
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Вот некоторые из корректных значений этого аргумента (чувствительного
        к регистру!) для распространенных кодировок: "Ср1521", "UTF-8", "8859_1"
        и т.д.
    </p>
    <p>Курс
    </p>
    <p>Программирование
        на Java
    </p>
    <p>Лекция 15
    </p>
    <p>Пакет
        java.io
    </p>
    <p>
    </p>
    <p>Класс StreamTokenizer
    </p>
    <p>Экземпляр StreamTokenizer создается поверх
        существующего объ­екта, либо InputStream, либо Reader. Как HJava.util.StringTokeznier, этот
        класс позволяет разбивать данные на лексемы (token), выделяемые из по­тока
        по определенным свойствам. Поскольку работа ведется со словами, конструктор,
        принимающий InputStream, объявлен как deprecated (предлагается
        оборачивать байтовый поток классом InputStreamReader и вызывать второй
        конструктор). Общий принцип работы такой же, как и у StringTokenizer, - задаются параметры
        разбиения, после чего вызывается метод nextToken(), пока не будет достигнут конец потока.
        Способы зада­ния разбиения у StreamTokenizer довольно
        разнообразны, но просты, и поэтому здесь не рассматриваются.
    </p>
    <p>Работа
        с файловой системой Класс File
    </p>
    <p>Если классы потоков осуществляют реальную запись и чтение дан­ных, то класс
        File — это
        вспомогательный инструмент, призванный обес­печить работу с файлами и
        каталогами.
    </p>
    <p>Объект класса File является
        абстрактным представлением файла и пути к нему. Он
        устанавливает только соответствие с ним, при этом для создания объекта неважно,
        существует ли такой файл на диске. После со­здания можно выполнить проверку,
        вызвав метод exists, который возвра­щает значение true, если файл
        существует. Создание или удаление объекта класса File никоим образом не отображается на
        реальных файлах. Для ра­боты с
        содержимым файла можно получить экземпляры Filel/OStream.
    </p>
    <p>Объект File может указывать на
        каталог (узнать это можно путем вы­зова метода isDirectory). Метод list возвращает список
        имен (массив String) содержащихся в нем файлов (если объект File не указывает на каталог
        -будет возвращен null).
    </p>
    <p>Следующий пример
        демонстрирует использование объектов класса File:
    </p>
    <p>import java.io.*;
        public class FileDemo {
    </p>
    <p>public static void findFiles(File file, FileFilter filter, PrintStream
        output) throws IOException{ if (file.isDirectoryO)
        {
    </p>
    <p>File[] list = file.listFilesO;
        for (int Nist.length;
        -i&gt;=0;) { findFiles(list[i], filter, output);
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>}
    </p>
    <p>} else {
    </p>
    <p>if (filter.accept(file))
    </p>
    <p>output.println("\t" + file.getCanonicalPath());
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>public static void main(String[] args) { class NameFilter
        implements FileFilter { private String mask; NameFilter(String mask) { this.mask
        = mask;
    </p>
    <p>}
    </p>
    <p>public boolean accept(File file){
    </p>
    <p>return (file.getName().indexOf(mask)!=-1 )?true:false;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>File pathFile = new File("."); String
        filterString = ".Java"; try{
    </p>
    <p>FileFilter
        filter = new NameFilter(filterString); findFiles(pathFile, filter, System.out);
        } catch(Exception e) { e.printStackTrace();
    </p>
    <p>}
    </p>
    <p>System.out.println("work finished");
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>При выполнении этой программы на экран будут выведены названия (в
        каноническом виде) всех файлов, с расширением .Java, содержащихся в
        текущем каталоге и всех его подкаталогах.
    </p>
    <p>Для определения того, что файл имеет расширение .Java, использо­вался
        интерфейс FileFilter с реализацией в
        виде внутреннего класса NameFilter. Интерфейс FileFilter определяет только
        один метод accept, возвращающий значение, определяющее, попадает ли переданный файл в
        условия фильтрации. Помимо этого интерфейса, существует еще одна разновидность
        интерфейса фильтра — FilenameFilter, где метод accept определен несколько
        иначе: он принимает не объект файла к проверке, а объект File, указывающий на
        каталог, где находится файл для проверки, и строку его названия. Для проверки
        совпадения, с учетом регулярных вы­ражений, нужно соответствующим образом
        реализовать метод accept. В конкретном приведенном примере можно было обойтись и без
        использо-
    </p>
    <p>Курс
    </p>
    <p>Программирование на Java
    </p>
    <p>Лекция
        15
    </p>
    <p>naKeTJava.io
    </p>
    <p>
    </p>
    <p>вания интерфейсов FileFilter или FilenameFilter. На практике их можно использовать для вызова
        методов list объектов File — в этих случаях
        будут возвращены файлы с учетом фильтра.
    </p>
    <p>Также класс File предоставляет возможность получения некоторой информации о файле.
    </p>
    <p>•
        Методы canRead и canWrite — возвращается boolean значение, можно ли будет приложению
        производить чтение и изменение со­держимого
        из файла, соответственно.
    </p>
    <p>•
        getName - возвращает строку
        — имя файла (или каталога).
    </p>
    <p>•
        getParent, getParentName - возвращают
        каталог, где файл нахо­дится в виде строки названия и объекта File, соответственно.
    </p>
    <p>•
        getPath - возвращает путь к
        файлу (при этом в строку преобразу­ется абстрактный путь, на который указывает
        объект File).
    </p>
    <p>•
        isAbsolutely - возвращает boolean значение, является ли абсолют­ным путь, которым указан
        файл.
        Определение, является ли путь абсолютным, зависит от системы, где запущена Java-машина. Так,
        для Windows абсолютный путь начинается с указания диска, либо символом '\'. Для Unix
        абсолютный путь
        начинается символом '/'.
    </p>
    <p>•
        isDirectory, isFile — возвращает boolean значение, указывает ли объект на каталог либо файл,
        соответственно.
    </p>
    <p>•
        isHidden - возвращает boolean значение, указывает ли объект на скрытый файл.
    </p>
    <p>•
        lastModified - дата последнего изменения.
    </p>
    <p>•
        ength — длина файла в
        байтах.
    </p>
    <p>Также можно изменить некоторые свойства файла — методы setReadOnly, setLastModified,
        назначение которых очевидно из назва­ния. Если нужно создать файл на
        диске, это позволяют сделать методы createNewFile, mkDir, mkDirs. Соответственно,
        createNewFile создает пустой файл
        (если таковой еще не существует), mkDir создает каталог, если для него все родительские уже
        существуют, a mkDirs создаст каталог вместе со всеми необходимыми родительскими.
    </p>
    <p>Файл можно и удалить — для этого предназначены методы delete и deleteOnExit. При вызове
        метода delete файл будет удален
        сразу же, а при вызове deleteOnExit по окончании работы
        Java-машины (только при кор­ректном завершении работы) отменить запрос уже
        невозможно.
    </p>
    <p>Таким образом, класс File дает возможность
        достаточно полного уп­равления файловой системой.
    </p>
    <p>
    </p>
    <p>Класс RandomAccessFile
    </p>
    <p>Этот класс реализует сразу два интерфейса - Datalnput и DataOutput — следовательно,
        может производить запись и чтение всех примитивных типов Java. Эти операции, как
        следует из названия, производятся с фай­лом. При этом их можно производить
        поочередно, произвольным образом перемещаясь по файлу с помощью вызова метода seek(long)
        (переводит на
        указанную позицию в файле). Узнать текущее положение указателя в файле можно
        вызовом метода getFilePointer.
    </p>
    <p>При создании объекта этого класса конструктору в качестве парамет­ров
        нужно передать два параметра: файл и режим работы. Файл, с которым будет
        проводиться работа, указывается либо с помощью String — название файла, либо объектом File,
        ему
        соответствующим. Режим работы (mode) -представляет собой строку либо "г"(только чтение),
        либо
        "пл/"(чтение и за­пись). Попытка открыть несуществующий файл только
        на чтение приведет к исключению FileNotFoundException. При открытии на чтение и запись он
        будет незамедлительно создан (или
        же будет брошено исключение FileNotFoundException, если это невозможно осуществить).
    </p>
    <p>После создания объекта RandomAccessFile можно
        воспользоваться методами интерфейсов Datalnput и DataOutput для проведения с
        файлом операций считывания и записи. По окончании работы с файлом его сле­дует
        закрыть, вызвав метод close.
    </p>
    <p>
    </p>
    <p>Заключение
    </p>
    <p>В данной лекции вы познакомились с таким важным понятием, как потоки
        данных (stream). Потоки являются очень эффективным способом решения задач, связанных с
        передачей и получением данных, независимо от особенностей используемых
        устройств ввода/вывода. Как вы теперь знаете, именно в пакете java.io содержатся
        стандартные классы, решаю­щие задачи обмена данными в самых различных форматах.
    </p>
    <p>Были описаны базовые классы байтовых потоков InputStream и OutputStream, а также символьных
        потоков Reader и Writer. Все классы потоков явным или неявным образом наследуются от них.
        Краткий обзор показал, для чего предназначен каждый класс, как с ним работать,
        какие классы не рекомендованы к использованию. Изучено, как передавать в потоки
        значения примитивные типов Java. Особое внимание было Уделено операциям с объектами, для
        которых
        существует специальный механизм сериализации.
    </p>
    <p>Наконец, были описаны
        классы для работы с файловой системой -
    </p>
    <p>File и RandomAccessFile.
    </p>
    <p></p>
    <center><img alt="Подпись:  " height="37" src="http://kufas.ru/java.files/image049.png"
                 width="446"></center>
    <p>
    </p>
    <p>
    </p>
    <p>Вариант 1
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>1.       Какие
        источники могут использоваться классами
        стандартных входных потоков java в
        качестве источника
        данных?
    </p>
    <p>Г"1   файл
        - представляется объектом класса File
    </p>
    <p>Г~1   массив
        - представляется массивом byte[] или
        char[]
    </p>
    <p>&#9633;       строка
        - представляется объектом String
    </p>
    <p>Г"1   сетевое
        соединение - входной поток получается вызовом getlnput-StreamO у объекта класса
        java.net.Socket
    </p>
    <p>П   сетевое
        соединение - объект класса java.net.URL
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.       От
        какого класса наследуются InputStream и OutputStream?
    </p>
    <p>&#9633;
        lOStream
    </p>
    <p>&#9633;
        AbstractStream
    </p>
    <p>&#9633;
        lOWriter
    </p>
    <p>&#9633;
        Object
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.       Если
        вызвать write(0x01234567) у экземпляра OutputStream,
        то в каком порядке и какие байты будут записаны
    </p>
    <p>в
        выходной поток?
    </p>
    <p>&#9633;
        0x01,0x23,0x45,0x67
    </p>
    <p>&#9633;
        0x67, 0x45, 0x23, 0x01
    </p>
    <p>&#9633;
        только 0x01
    </p>
    <p>&#9633;
        только 0x67
    </p>
    <p>
    </p>
    <p>Курс
    </p>
    <p>Пакет
        java.io
    </p>
    <p>Вариант
        2
    </p>
    <p>Вариант
        3
    </p>
    <p>
    </p>
    <p>1.      Какие
        классы предоставляют методы для записи в поток
        двоичного представления значений примитивных типов
        Java?
    </p>
    <p>Q   DataOutputStream
    </p>
    <p>&#9633;
        OutputStream
    </p>
    <p>&#9633;
        SimpleOutputStream
    </p>
    <p>&#9633;
        ObjectOutputStream
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.       Что
        произойдет при попытке к одному объекту PipedWriter
        несколько раз присоединять объекты PipedReader?
    </p>
    <p>П   при
        попытке присоединить более одного PipedReader будет брошено исключение lOException, но
        только в том случае, если предпринята попытка присоединить PipedReader, отличный
        от уже подключенного
    </p>
    <p>П   при
        попытке присоединить более одного PipedReader будет брошено исключение lOException, даже
        в том случае, если производится попытка несколько раз присоединить один и тот
        же объект PipedReader
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.   Какая кодировка используется классом OutputStreamWriter по умолчанию?
    </p>
    <p>Г~!  
        используемая кодировка зависит от системы, где запущена Java-машина
    </p>
    <p>Г~1   спецификацией Java не
        оговаривается кодировка, используемая по умолчанию, но точно известно, что jdk, поставляемая
        Sun, использует KOI-8
    </p>
    <p>1.      Какое
        значение следует передать методу seek() объекта
        RandomAccessFile, чтобы
        последний байт файла был считан
        одиночным вызовом read()?
        Узнать длину файла, на который
        указывает объект RandomAccessFile, можно
        путем вызова
        метода length().
    </p>
    <p>&#9633;
        randomAccess-File.length()
    </p>
    <p>&#9633;
        randomAccess-File.length()-1
    </p>
    <p>&#9633;
        randomAccess-File.length()-2
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.       Какие
        методы объявлены в интерфейсе Serializable?
    </p>
    <p>Г~1   в
        интерфейсе Serializable не
        определено ни одного метода П   Serializable определяет два абстрактных
        метода - readObject() и writeObjectO
    </p>
    <p>Г~1   Serializable - это класс, в котором есть
        только конструктор без параметров
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.       Что произойдет, если, используя
        ObjectOutputStream,
        записать в файл значения типов long, int, byte именно
        в
        таком порядке, а считать в обратном, используя
        DatalnputStream?
    </p>
    <p>Г"1   ошибка
        на этапе компиляции, так как нельзя настраивать
    </p>
    <p>DatalnputStream на данные, записанные с помощью
    </p>
    <p>ObjectOutputStream &#9633;   несоответствие форматов ObjectOutputStream и DatalnputStream
    </p>
    <p>проявится
        только во время выполнения, что приведет
    </p>
    <p>к возникновению исключения lOException Г~1  
        все пройдет успешно, но полученные значения byte, int и long
    </p>
    <p>могут
        (точнее, будут) отличаться от тех, которые были записаны
    </p>
    <p>
    </p>
    <center>
    </center>
</div>

</body>
</html>
