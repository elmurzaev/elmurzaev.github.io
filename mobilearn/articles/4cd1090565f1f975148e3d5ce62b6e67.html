<!DOCTYPE html>
<html>
<head>

    <title> Лекция 9. Время жизни и область видимости. Пространства имён. Компоновка</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<section id="l9_1">
    <h1> 1. Время жизни и область видимости. Спецификации класса памяти </h1>


    <h2>Введение</h2>

    <p>
        <b>Время жизни переменной</b> может быть <i>глобальным</i> и <i>локальным</i>. Переменная с
        глобальным временем жизни характеризуется тем, что в течение всего времени выполнения
        программы с ней ассоциирована ячейка памяти и значение. Переменной с локальным временем
        жизни выделяется новая ячейка памяти при каждом входе в блок, в котором она определена или
        объявлена. <b>Время жизни функции</b> всегда глобально.

    </p>
    <p>
        <b>Область видимости</b> объекта (переменной или функции) определяет, в каких участках
        программы допустимо использование имени этого объекта.
    </p>
    <p>
        Область видимости имени начинается в точке объявления, точнее, сразу после объявителя, но
        перед инициализатором. Поэтому допускается использование имени в качестве инициализирующего
        значения для себя самого.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> x = x;
            </td>
            <td class="commenti">// Странно!</td>
        </tr>
    </table>
    <p>
        Это допустимо, но не разумно.
    </p>
    <p>
        Прежде чем имя может быть использовано в программе на <span>C++</span>, оно должно быть
        объявлено (иметь <i>объявление</i>), т.е. должен быть указан тип имени, чтобы компилятор
        знал, на сущность какого вида ссылается имя. <i>Определение</i> не только связывает тип с
        именем, но и определяет некоторую сущность, которая соответствует имени. В программе на
        <span>C++</span> для каждого имени должно быть ровно одно определение. Объявлений же может
        быть несколько. Все объявления некой сущности должны согласовываться по типу этой сущности.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> count;
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> count;
            </td>
            <td class="commenti">// Ошибка – повторное определение</td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">extern int</span> error_number;
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">extern short</span> error_number;
            </td>
            <td class="commenti">// Ошибка – несоответствие типов объявлений</td>
        </tr>
    </table>
    <p>
        Объявления и определения, записанные внутри какого-либо блока, называются <i>внутренними</i>
        или <i>локальными</i>. Объявления и определения, записанные за пределами всех блоков,
        называются <i>внешними</i> или <i>глобальными</i>.
    </p>
    <h2 id="l9_1_1">1.1. Переменные </h2>
    <p>
        <b>Объявление переменной</b> задает имя и атрибуты переменной. <b>Определение переменной</b>,
        помимо этого, приводит к <i>выделению для нее памяти</i>. Кроме того, определение переменной
        задает её <i>начальное значение</i> (явно или неявно). Таким образом, не каждое объявление
        переменной является определением переменной. К объявлениям, которые не являются определением
        относятся объявления формальных параметров функций, а также объявления со спецификацией
        класса памяти <i>extern</i>, которые являются ссылкой на переменную, определённую в другом
        месте программы (см. ).

    </p>
    <p>
        Объявления переменных в языке <span>C++</span> имеют следующий синтаксис:
        <span class="sint">
[<i>&lt;спецификация класса памяти&gt;</i>] <i>&lt;тип&gt; &lt;описатель&gt;</i> [= <i>&lt;инициализатор&gt;</i>] [, <i>&lt;описатель&gt;</i> [= <i>&lt;инициализатор&gt;</i>] ...];
</span>
    </p>
    <p id="l9_classi_di_memoria">
        В языке <span>C++</span> имеется четыре спецификации класса памяти:
    </p>
    <ul>
        <li><span class="sint">auto</span>
        </li>
        <li><span class="sint">register</span>
        </li>
        <li><span class="sint">static</span>
        </li>
        <li><span class="sint">extern</span>
        </li>
    </ul>
    <p>
        Спецификации класса памяти <i>auto</i> и <i>register</i> могут быть использованы только на
        внутреннем уровне.
    </p>
    <h3 id="l9_1_1_1"> 1.1.1. Глобальные переменные</h3>
    <p>
        Переменная, объявленная на внешнем уровне, имеет глобальное время жизни. При отсутствии
        инициализатора такая переменная инициализируется нулевым значением. Область видимости
        переменной, определенной на внешнем уровне, распространяется от точки, где она определена,
        до конца исходного файла. Переменная недоступна выше своего определения в том же самом
        исходном файле. На другие исходные файлы программы область видимости переменной может быть
        распространена только в том случае, если ее определение не содержит спецификации класса
        памяти <i>static</i>.

    </p>
    <p>
        Если в объявлении переменной задана спецификация класса памяти <i>static</i>, то в других
        исходных файлах могут быть определены другие переменные с тем же именем и любым классом
        памяти. Эти переменные никак не буду связаны между собой.

    </p>
    <p id="l9_extern">
        Спецификация класса памяти <i>extern</i> используется для объявления переменной,
        определенной где-то в другом месте программы. Такие объявления используются в случае, когда
        нужно распространить на данный исходный файл область видимости переменной, определенной в
        другом исходном файле на <b>внешнем</b> уровне. Область видимости переменной
        распространяется от места объявления до конца исходного файла. В объявлениях, которые
        используют спецификацию класса памяти <i>extern</i>, инициализация не допускается, так как
        они ссылаются на переменные, значения которых определены в другом месте.
    </p>
    <h3 id="l9_1_1_2"> 1.1.2. Локальные переменные</h3>
    <p>
        Переменная, объявленная на внутреннем уровне, доступна только в том, блоке в котором она
        объявлена, <i>независимо от класса памяти</i>. По умолчанию она имеет класс памяти
        <i>auto</i>. Переменные этого класса размещаются в стеке. Переменные класса памяти
        <i>auto</i> автоматически не инициализируются, поэтому в случае отсутствия инициализации в
        объявлении значение переменной класса памяти <i>auto</i> считается неопределенным.

    </p>
    <p>
        Спецификация класса памяти <i>register</i> требует, чтобы переменной была выделена память в
        регистре, если это возможно. Т.к. работа с регистрами происходит быстрее, спецификация
        класса памяти <i>register</i> обычно используется для переменных, к которым предполагается
        обращаться очень часто.

    </p>
    <p>
        Для каждого рекурсивного входа в блок порождается новый набор переменных класса памяти <i>auto</i>
        и <i>register</i>. При этом каждый раз производится инициализация переменных, в объявлении
        которых заданы инициализаторы.

    </p>
    <p>
        Если переменная, объявленная на внутреннем уровне, имеет спецификацию памяти <i>static</i>,
        то область видимости остается прежней, а время жизни становится глобальным. В отличие от
        переменных класса памяти <i>auto</i>, переменные, объявленные со спецификацией класса памяти
        <i>static</i>, сохраняют свое значение при выходе из блока. Переменные класса памяти <i>static</i>
        могут быть инициализированы константным выражением. Если явной инициализации нет, то
        переменная класса памяти <i>static</i> автоматически инициализируется нулевым значением.
        Инициализация выполняется один раз во время компиляции и не повторяется при каждом входе в
        бока. Все рекурсивные вызовы данного бока будут разделять единственный экземпляр переменной
        класса памяти <i>static</i>.

    </p>
    <p>
        Переменная, объявленная со спецификацией класса памяти <i>extern</i>, является ссылкой на
        переменную с тем же самым именем, определенную на <b>внешнем</b> уровне в любом исходном
        файле программы. Цель внутреннего объявления <i>extern</i> состоит в том, чтобы сделать
        определение переменной доступным именно внутри данного блока.
    </p>
    <table>
        <tr>
            <td colspan="2">
                <b> Файл 1 </b>
            </td>
            <td colspan="2">
                <b> Файл 2 </b>
            </td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> a, b;
                <span class="chiavi">static int</span> c;
                <span class="chiavi">extern int</span> d <s>= 10</s>;
                <span class="chiavi">int</span> m[10];
                <span class="chiavi">int</span> f(<span class="chiavi">int</span> x)
                { <span class="chiavi">int</span> y;
                <span class="chiavi">static int</span> z;
                <span class="chiavi">static int</span> c;
                <b>...</b>
                }
            </td>
            <td class="commenti">
                // Глобальные переменные
                // На переменную <b>с</b> нельзя будет
                // сослаться из другого файла
                // Нельзя использовать инициализатор с <i>extern</i>
                // Переменная класса <i>auto</i>.
                // Локальные время жизни и область видимости.
                // Локальная переменная класса <i>static</i>.
                // Имеет глобальное время жизни.
                // Локальная статическая переменная <b>c</b>
                // скрывает глобальную переменную <b>c</b>
            </td>
            <td class="esempi">
                <span class="chiavi">extern int</span> a;
                <span class="chiavi">static double</span> c;
                <span class="chiavi">int</span> d = 10;
                <span class="chiavi">extern int</span> m[];
                <s><span class="chiavi">auto     int</span> e;</s>
                <s><span class="chiavi">register int</span> e;</s>
                <span class="chiavi">int</span> g(<span class="chiavi">int</span> x)
                { <span class="chiavi">extern int</span> b;
                <span class="chiavi">register int</span> w;
                <b>...</b>
                }
            </td>
            <td class="commenti">
                // Ссылка на переменную <b>а</b> из файла 1
                // Но можно объявить переменную
                // с таким же именем <b>c</b> в другом файле
                // С <i>extern</i> можно опускать размер массива
                // Нельзя использовать <i>auto</i> и <i>register</i>
                // на внешнем уровне
                // Ссылка на переменную <b>b</b> из файла 1,
                // которая будет доступна только в функции <b><i>g</i></b>
                // Переменная класса <i>register</i>
            </td>
        </tr>
    </table>
    <h3 id="l9_1_1_3"> 1.1.3. Сокрытие имён</h3>
    <p>
        Объявление имени в блоке может скрыть объявление этого имени в охватывающем блоке или
        глобальное имя. То есть имя может быть замещено внутри блока и будет ссылаться там на другую
        сущность. После выхода из блока имя восстанавливает свой прежний смысл. К скрытому
        глобальному имени можно обратиться с помощью операции разрешения области видимости <span
            class="sint"><b>::</b></span>. Скрытое имя члена класса можно использовать,
        квалифицировав его именем класса. Скрытое глобальное имя можно использовать, если
        квалифицировать его унарной операцией разрешения области видимости.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> x;
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">void</span> f()
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"> { <span class="chiavi">double</span> x = 0;</td>
            <td class="commenti">// Глобальная переменная <b>х</b> скрыта
            </td>
        </tr>
        <tr>
            <td class="esempi"><b>::</b>x = 2;</td>
            <td class="commenti">// Присваивание глобальной переменной <b>х</b></td>
        </tr>
        <tr>
            <td class="esempi"> x = 2.5;</td>
            <td class="commenti">// Присваивание локальной переменной <b>х</b></td>
        </tr>
        <tr>
            <td class="esempi"> }</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> f(<span class="chiavi">int</span> x) { ... }
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">class</span> X
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"> { <span class="chiavi">public</span>:</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"><span class="chiavi">static int</span> f() { ... }</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"> };</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> ff()
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"> { <span class="chiavi">return</span> X<b>::</b>f(); }</td>
            <td class="commenti">// Вызов функции <i>f</i> класса <i>Х</i>, а не глобальной функции
                <i>f</i></td>
        </tr>
    </table>
    <p>
        Не существует способа обращений к скрытой локальной переменной.
    </p>
    <h3 id="l9_1_1_4">1.1.4. Объявления в условиях и цикле <i>for</i></h3>
    <p>
        Во избежание случайного неправильного использования переменных их лучше вводить в наименьшей
        возможной области видимости. В частности, локальную переменную лучше объявлять в тот момент,
        когда ей надо присвоить значение. В этом случае исключаются попытки использования переменной
        до момента её инициализации.
    </p>
    <p>
        Одним из самых элегантных применений этих идей является объявление переменной в . Рассмотрим
        пример.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">if</span> (<span class="chiavi">double</span> d = f(x))
                y /= d;
            </td>
        </tr>
    </table>
    <p>
        Область видимости переменной <b>d</b> простирается от точки её объявления до конца
        оператора, контролируемого условием. Если бы в инструкции <i>if</i> была ветвь <i>else</i>,
        то областью видимости переменной <b>d</b> были бы обе ветви.
    </p>
    <p>
        Очевидной и традиционной альтернативой является объявление переменной до условия, но в этом
        случае область видимости началась бы до мести использования переменной и продолжалась бы
        после завершения её «сознательной» жизни.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">double</span> d;
                ...
                d2 = d;
                ...
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">if</span> (d = f(x))
                y /= d;
                ...
            </td>
            <td class="commenti">// Внимание!!!</td>
        </tr>
        <tr>
            <td class="esempi">d = 2.0;</td>
            <td class="commenti">// Два несвязанных использования переменной <b>d</b></td>
        </tr>
    </table>
    <p>
        Объявление переменных в условиях, кроме того, что даёт логические преимущества, приводит
        также к более компактному исходному коду.
    </p>
    <p>
        Объявление в условии должно объявлять и инициализировать единственную переменную или
        константу.
    </p>
    <p>
        Переменную можно также объявить в инициализирующей части оператора . В этом случае область
        видимости переменной (или переменных) простирается до конца оператора.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">void</span> f(<span class="chiavi">int</span> x[], <span
                    class="chiavi">int</span> n)
                { <span class="chiavi">for</span> (<span class="chiavi">int</span> i = 0; i &lt; n;
                i++) x[i] = i * i; }
            </td>
        </tr>
    </table>
    <p>
        Если требуется узнать значение индекса после выхода из цикла, переменную надо объявить вне
        его.
    </p>
    <h2 id="l9_1_2">1.2. Функции </h2>
    <p>
        <b>Объявление функции (прототип)</b> задает её имя, тип возвращаемого значения и атрибуты её
        формальных параметров. Объявления функций в языке <span>C++</span> имеют следующий
        синтаксис:
        <span class="sint">
[<i>&lt;спецификация класса памяти&gt;</i>] <i>&lt;тип&gt; &lt;имя&gt;</i> (<i>&lt;список формальных параметров&gt;</i>);
</span>
    </p>
    <p>
        <b>Определение функции</b> специфицирует тело функции, которое представляет собой составной
        оператор, содержащий объявления и операторы. Определение функции также задает её имя, тип
        возвращаемого значения и атрибуты её формальных параметров. Определение функции имеет
        следующий синтаксис:
        <span class="sint">
[<i>&lt;спецификация класса памяти&gt;</i>] <i>&lt;тип&gt; &lt;имя&gt;</i> (<i>&lt;список формальных параметров&gt;</i>)
  { <i>&lt;тело функции&gt;</i> }
</span>
    </p>
    <p>
        Функции имеют глобальное время жизни.
    </p>
    <p>
        Определение функции может быть задано <b>только на внешнем уровне</b>. Область видимости
        функции распространяется от определения до конца файла. Чтобы использовать вызов функции
        выше её определения, нужно написать объявление функции (прототип). Прототип некоторой
        функции может быть расположен на внешнем уровне (тогда вызов этой функции будет возможен из
        любой функции исходного файла) или же на внутреннем уровне (тогда вызов данной функции будет
        возможен только из блока, в котором находится прототип).
    </p>
    <p>
        Для использования функции, расположенной в другом исходном файле, также необходимо
        использовать прототип.
    </p>
    <p>
        Если функция определена со спецификацией класса памяти <i>static</i>, ее использование в
        других исходных файлах программы невозможно.
    </p>
    <p>
        компонуются внутренним образом (т.е. не могут быть использованы в других файлах программы),
        если только явным образом не указана внешняя компоновка с помощью ключевого слова
        <i>extern</i>.
    </p></section>
<section id="l9_2">
    <h1> 2. Пространства имён </h1>
    <h2> 2.1. Пространство имён </h2>
    <p>
        Пространство имён является механизмом отражения логического группирования. То есть если
        некоторые объявления можно объединить по какому-либо критерию, их можно поместить в одно
        пространство имён для отражения этого факта.
    </p>
    <p>
        Пространство имён объявляется следующим образом:
        <span class="sint">
<b>namespace</b> &lt;<i>имя пространства имён</i>&gt;
 { &lt;<i>объявления и определения</i>&gt; }
</span>
    </p>
    <p>
        Нельзя объявить новый член пространства имён вне его определения, используя явный
        квалификатор. Это делается для того, чтобы можно было найти все имена в определении
        пространства имён и быстро выявить такие ошибки, как опечатки и несоответствие типов.
    </p>
    <p>
        Пространство имён является областью видимости. Обычные локальные и глобальные области
        видимости и классы являются пространствами имён. Обычные правила областей видимости
        применимы и к пространствам имён. Если имя предварительно объявлено в пространстве имён или
        в охватывающей области, дальше его можно использовать без проблем. Имя из другого
        пространства имён можно использовать при помощи явного указания этого пространства в
        качестве квалификатора.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">namespace</span> N1
                { <span class="chiavi">int</span> g();
                <span class="chiavi">char</span> h();
                }
            </td>

            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">namespace</span> N2
                { <span class="chiavi">int</span> f1();
                <span class="chiavi">int</span> f2();
                }
            </td>

            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> N2<b>::</b>f1()
            </td>

            <td class="commenti">// Используем квалификатор для того, чтобы указать, что функция <i>f1</i>
                объявлена
                // в пространстве имён <i>N2</i>, а не является глобальной функцией.
            </td>
        </tr>
        <tr>
            <td class="esempi"> { <span class="chiavi">return</span> f2() + N1<b>::</b>g(); }</td>

            <td class="commenti">// Т.к. функция <i>f2</i> является членом пространства имён
                <i>N2</i>, нет необходимости
                // использовать квалификатор. Однако без использования квалификатора <i>N1</i>
                // функция <i>g</i> считалась бы необъявленной, потому что члены пространства имён
                <i>N1</i>
                // не находятся в области видимости в пространстве <i>N2</i>.
            </td>
        </tr>
    </table>
    <h2 id="l9_2_1"> 2.2. Объявления <i>using</i></h2>
    <p>
        Если имя часто используется вне пределов своего пространства имён, неудобно каждый раз
        использовать квалификатор. Для того чтобы избежать этого, используются <i>объявления <b>using</b></i>,
        которые вводят локальные синонимы.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">namespace</span> N2
                { ...
                <span class="chiavi">using</span> N1<b>::</b>g;
                }
            </td>
            <td class="commenti">
                // Теперь функцию <i>g</i> можно использовать без квалификатора
            </td>
        </tr>
    </table>
    <p>
        Такие синонимы следует делать как можно более локальными во избежание конфликтов имён.
    </p>
    <p>
        Единственное объявление <i>using</i> делает видимыми все версии .
    </p>
    <h2 id="l9_2_2">2.3. Директивы <i>using</i></h2>
    <p>
        <i>Директива <b>using</b></i> делает доступными все имена из пространства имён.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">namespace</span> N2
                { ...
                <span class="chiavi">using namespace</span> N1;
                }
            </td>
            <td class="commenti">

                // Теперь все функции из пространства имён <i>N1</i> можно использовать без
                квалификатора
            </td>
        </tr>
    </table>
    <p>
        Можно считать, что директива <i>using</i> является средством композиции пространств имён. В
        функциях директива <i>using</i> используется для удобства записи. Однако использования
        глобальных директив <i>using</i> лучше по возможности избегать.
    </p>
    <h2 id="l9_2_3">2.4. Неименованные пространства имён </h2>
    <p>
        Иногда полезно помещать объявления в пространство имён для того, чтобы исключить возможность
        конфликта имён. В этом случае можно использовать неименованные пространства имён.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">namespace</span>
                { <span class="chiavi">void</span> f() { ... }
                <span class="chiavi">void</span> g() { ... }
                <b>...</b>
                }
            </td>
        </tr>
    </table>
    <p>
        Ясно, что должен существовать способ доступа к членам неименованного пространства имён.
        Следовательно, неименованное пространство имён подразумевает использование директивы <i>using</i>.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">namespace</span> XXX
                { <span class="chiavi">void</span> f() { ... }
                <span class="chiavi">void</span> g() { ... }
                <b>...</b>
                }
                <span class="chiavi">using namespace</span> XXX;
            </td>
        </tr>
    </table>
    <p>
        Здесь <i>XXX</i> является некоторым уникальным именем, которое даётся пространству имён
        компилятором и не известно программисту.
    </p>
    <p>
        Неименованные пространства имён в разных единицах компиляции различны. Нельзя осуществить
        доступ из одной единицы компиляции к члену неименованного пространства имён из другой
        единицы компиляции.
    </p>
    <h2 id="l9_2_4">2.5. Поиск имён </h2>
    <p>
        Является скорее правилом, чем исключением, что функция с параметром типа <i>Т</i>
        определяется в том же пространстве имён, что и <i>Т</i>. Поэтому, если функция не найдена в
        контексте её использования, осуществляется поиск в пространстве имён её параметров.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">namespace</span> NS1
                { <span class="chiavi">class</span> X { ... };
                <span class="chiavi">void</span> f(<span class="chiavi">const</span> X &amp;x);
                }
                <span class="chiavi">void</span> g(NS1<b>::</b>X x)
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"> { f(x); }</td>
            <td class="commenti">// Используем <i>NS1<b>::</b>f</i>, т.к. тип параметра функции
                определён в пространстве имён <i>NS1</i></td>
        </tr>
    </table>
    <p>
        По сравнению с использованием явных квалификаторов это правило поиска имён экономит время
        при вводе программы и не приводит к «загрязнению» пространства имён, как это может сделать
        директива <i>using</i>.
    </p>
    <h2 id="l9_2_5"> 2.6. Псевдонимы пространств имён </h2>
    <p>
        Короткие названия пространств имён могут войти в конфликт друг с другом. Однако, длинные
        названия пространств имён непрактичны при написании реального кода. Эту дилемму можно решить
        путём создания короткого псевдонима длинного названия пространства имён.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">namespace</span> RFBR = Russian_Fund_of_Basic_Researches;
            </td>
        </tr>
    </table>
    <p>
        Псевдонимы, кроме того, позволяют пользователю ссылаться на «библиотеку» и в одном
        единственном объявлении определять реально используемую библиотеку.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">namespace</span> Lib = Library_v2r15;
            </td>
        </tr>
    </table>
    <p>
        Это может значительно облегчить проблему смены версии библиотеки.
    </p>
    <h2 id="l9_2_6">2.7. Объединение и отбор </h2>
    <p>
        Комбинация объединения пространств имён при помощи директив <i>using</i> и отбора при помощи
        объявлений <i>using</i> обеспечивает гибкость, требуемую для большинства реальных задач.
        Используя эти механизмы, мы можем обеспечить доступ ко множеству средств таким образом,
        чтобы разрешать конфликты имён и неоднозначности, возникающие из-за объединения.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">namespace</span> One
                { <span class="chiavi">class</span> Matrix { ... };
                <span class="chiavi">class</span> Vector { ... };
                ...
                }
                <span class="chiavi">namespace</span> Two
                { <span class="chiavi">class</span> Vector { ... };
                <span class="chiavi">class</span> Matrix { ... };
                ...
                }
                <span class="chiavi">namespace</span> Three
                { <span class="chiavi">class</span> Set { ... };
                <span class="chiavi">class</span> String { ... };
                ...
                }
            </td>

            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">namespace</span> All
                { <span class="chiavi">using</span> Three<b>::</b>Set;

                <span class="chiavi">using namespace</span> One;

                <span class="chiavi">using namespace</span> Two;

                <span class="chiavi">using</span> One<b>::</b>Vector;

                <span class="chiavi">using</span> Two<b>::</b>Matrix;

                <span class="chiavi">class</span> List { ... };
                }
            </td>
            <td class="commenti">
                // Используем только класс <i>Set</i> из пространства <i>Three</i>
                // Используем все имена из пространства <i>One</i>
                // Используем все имена из пространства <i>Two</i>
                // Разрешение возможных конфликтов в пользу <i>One<b>::</b>Vector</i>
                // Разрешение возможных конфликтов в пользу <i>Two<b>::</b>Matrix</i>
                // Класс, не входящий в пространства имён <i>One</i>, <i>Two</i> и <i>Three</i></td>
        </tr>
    </table>
    <p>
        Имена, явно объявленные в пространстве имён, включая имена, объявленные с помощью объявлений
        <i>using</i>, имеют приоритет по отношению к именам, сделанным доступными при помощи
        директив using. Поэтому конфликты будут разрешать в пользу <i>One::Vector</i> и <i>Two::Matrix</i>.
        Кроме того, <i>All::List</i> будет использоваться по умолчанию, независимо от того, имеется
        ли <i>List</i> в пространстве <i>One</i> или пространстве <i>Two</i>.
    </p></section>
<section id="l9_3">
    <h1> 3. Компоновка </h1>
    <h2> 3.1. Многофайловые программы </h2>
    <p>
        Файл является традиционной единицей хранения информации в файловой системе и не менее
        традиционной единицей компиляции. Как правило, невозможно хранить программу в одном файле. В
        частности, код стандартных библиотек и операционной системы не предоставляется в виде
        исходных текстов в качестве части пользовательской программы. Даже хранение всего
        пользовательского кода в единственном файле для приложений реального размера и непрактично,
        и неудобно. Разбиение программы на файлы помогает подчеркнуть её логическую структуру,
        облегчает её понимание и позволяет компилятору обеспечить эту логическую структуру.
    </p>
    <p>
        Когда единицей компиляции является файл, весь он должен быть заново перекомпилирован при
        внесении изменений (не зависимо от того, насколько они малы) в него или в другой файл, от
        которого он зависит. Даже в случае программы небольших размеров количество времени,
        потраченное на перекомпиляцию, может быть существенно снижено за счёт разбиения программы на
        файлы подходящего размера.
    </p>
    <p>
        Для того чтобы сделать возможной раздельную компиляцию, программист должен предоставить
        объявления, дающие информацию о типах, необходимую для анализа единицы компиляции отдельно
        от остальной части программы. Объявления в программе, состоящей из нескольких раздельно
        компилируемых частей, должны быть согласованы абсолютно так же, как и в программе, состоящей
        из единственного исходного файла.
    </p>
    <p>
        Организацию программы в виде набора исходных файлов обычно называют <i>физической
        структурой</i> программы. Физическое разбиение программы на различные файлы должно
        определяться, исходя из логической структуры программы. Однако логическая и физическая
        структуры программы не обязаны быть идентичными.
    </p>
    <p>
        Имена функций, классов, шаблонов, переменных, пространств имён и перечислений должны быть
        согласованы во всех единицах компиляции, если только эти имена явно не определены как
        локальные.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span>// file1.cpp</span>
                <span class="chiavi">int</span> x = 1;
                <span class="chiavi">int</span> b = 0;
                <span class="chiavi">extern int</span> c;
                <span>// file2.cpp</span>
                <span class="chiavi">int</span> x;
                <span class="chiavi">extern double</span> b;
                <span class="chiavi">extern int</span> c;
            </td>
        </tr>
    </table>
    <p>
        В этом примере содержатся три ошибки:
    </p>
    <ul>
        <li> переменная <b>x</b> определена дважды;
        </li>
        <li> переменная <b>b</b> объявлена дважды с различными типами;
        </li>
        <li> переменная <b>c</b> дважды объявлена, но не определена.
        </li>
    </ul>
    <p>
        Ошибки такого типа не могут быть обнаружены компилятором, который в каждый момент времени
        рассматривает только один файл. Однако большинство таких ошибок выявляются компоновщиком.
    </p>
    <p>
        Если имеется имя, которое может быть использовано в единице компиляции, отличной от той, в
        которой оно было определено, то говорят, что имеет место <i>внешняя компоновка</i>. Про имя,
        но которое можно ссылаться лишь в той единице компиляции, в которой оно определено, говорят,
        что оно компонуется <i>внутренним образом</i>.
    </p>
    <p>
        должна быть определена идентичными определениями в каждой единице компиляции, в которой она
        используется. Поэтому, следующий пример является не просто образцом плохого вкуса – он
        вообще недопустим.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span>// file1.cpp</span>
                <span class="chiavi">inline int</span> f(<span class="chiavi">int</span> i) { <span
                    class="chiavi">return</span> i; }
                <span>// file2.cpp</span>
                <span class="chiavi">inline int</span> f(<span class="chiavi">int</span> i) { <span
                    class="chiavi">return</span> i + 1; }
            </td>
        </tr>
    </table>
    <p>
        По умолчанию <i>const</i> и <i>typedef</i> подразумевают внутреннюю компоновку. Поэтому
        следующий пример допустим, хотя может привести к ошибкам.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span>// file1.cpp</span>
                <span class="chiavi">typedef int</span> T;
                <span class="chiavi">const int</span> x = 7;
                <span>// file2.cpp</span>
                <span class="chiavi">typedef void</span> T;
                <span class="chiavi">const int</span> x = 8;
            </td>
        </tr>
    </table>
    <p>
        Глобальные переменные, которые являются локальными для одной единицы компиляции, являются
        типичным источником ошибок, и их лучше избегать. Для обеспечения согласованности лучше
        помещать глобальные <i>const</i>, <i>typedef</i> и <i>inline</i> только в заголовочные
        файлы.
    </p>
    <p>
        Можно заставить константу компоноваться внешним образом путём её явного объявления с помощью
        ключевого слова <i>extern</i>.
    </p>
    <p>
        Для того чтобы имена в данной единице компиляции были локальными, можно воспользоваться
        неименованными пространствами имён. Эффект от применения неименованного пространства
        напоминает внутреннюю компоновку.
    </p>
    <p>
        В программах на С и старых программах на <span>C++</span> ключевое слово <i>static</i>
        используют (что приводит к путанице) для указания «использовать внутреннюю компоновку».
        Лучше не использовать <i>static</i> кроме как внутри функций и классов.
    </p>
    <h2 id="l9_3_1"> 3.2. Заголовочные файлы </h2>
    <p>
        Во всех объявлениях типы одних и тех же объектов, функций, классов и т.д. должны быть
        согласованы. Следовательно, исходный код, обрабатываемый компилятором и затем компоновщиком,
        должен быть согласован. Самым простым методом достижения согласованности объявлений в
        различных единицах компиляции является включение заголовочных файлов, содержащих информацию
        об интерфейсе в исходные файлы, в которых содержится исполняемый код и/или определения
        данных.
    </p>
    <p>
        Практическое правило гласит, что заголовочный файл может содержать:
    </p>
    <ul>
        <li> именованные пространства имён;
        </li>
        <li> определения типов;
        </li>
        <li> объявления и определения шаблонов;
        </li>
        <li> объявления функций;
        </li>
        <li> определения встраиваемых функций;
        </li>
        <li> объявления данных;
        </li>
        <li> определения констант;
        </li>
        <li> перечисления;
        </li>
        <li> объявления имён;
        </li>
        <li> директивы включения;
        </li>
        <li> макроопределения;
        </li>
        <li> директивы условной компиляции;
        </li>
        <li> комментарии.
        </li>
    </ul>
    <p>
        Это правило не является требованием языка. Оно просто отражает разумный способ использования
        заголовочных файлов для выражения физической структуры программы. С другой стороны,
        заголовочный файл никогда не должен содержать:
    </p>
    <ul>
        <li> определения обычных функций;
        </li>
        <li> определения данных;
        </li>
        <li> неименованные пространства имён.
        </li>
    </ul>
    <h2 id="l9_3_2"> 3.3. Правило одного определения </h2>
    <p>
        Каждый конкретный класс, перечисление, шаблон и т.д. должны быть определены в программе
        ровно один раз.
    </p>
    <p>
        С практической точки зрения это означает, что должно существовать ровно одно определение,
        например, класса, находящееся где-то в одном файле. К сожалению, правило языка не может быть
        таким простым. Определение класса может быть включено в два исходных файла. Хуже того,
        концепция «файла» не является частью определения языка <span>C++</span>.
    </p>
    <p>
        Следовательно, правило стандарта, говорящее о том, что должно существовать уникальное
        определение класса, шаблона и т.д. должно быть изложено в более сложной форме. Это правило
        называют «правилом одного определения» (One-Definition Rule, ODR). А именно, два определения
        класса, шаблона или встроенной функции приемлемы в качестве определения одной и той же
        сущности тогда и только тогда, когда:
    </p>
    <ol>
        <li> они находятся в различных единицах компиляции;</li>
        <li> они идентичны лексема за лексемой;</li>
        <li> значения лексем одинаковы в обеих единицах компиляции.</li>
    </ol>
    <p>
        Приведём примеры трёх способов нарушения правила ODR.
    </p>
    <table>
        <tr>
            <td class="commenti">// file1.cpp</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">struct</span> S1 { <span class="chiavi">int</span> a; <span
                    class="chiavi">char</span> b; };
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">struct</span> S1 { <span class="chiavi">int</span> a; <span
                    class="chiavi">char</span> b; };
            </td>
            <td class="commenti">// Ошибка – нельзя определить структуру дважды в одной единице
                компиляции
            </td>
        </tr>
        <tr>
            <td class="commenti">// file1.cpp</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"><span class="chiavi">struct</span> S2 { <span
                    class="chiavi">int</span> a; <span class="chiavi">char</span> b; };
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="commenti">// file2.cpp</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">struct</span> S2 { <span class="chiavi">int</span> a; <span
                    class="chiavi">char</span> bb; };
            </td>
            <td class="commenti">// Ошибка – имена членов определениях различны</td>
        </tr>
        <tr>
            <td class="commenti">// file1.cpp</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">typedef int</span> X;
                <span class="chiavi">struct</span> S3 { X a; <span class="chiavi">char</span> b; };
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="commenti">// file2.cpp</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">typedef char</span> X;
                <span class="chiavi">struct</span> S3 { X a; <span class="chiavi">char</span> b; };
            </td>
            <td class="commenti"> // Ошибка – смысл <i>X</i> в файлах различен</td>
        </tr>
    </table>
    <p>
        Проверка согласованности определений классов в различных единицах компиляции, как правило,
        находится вне пределов возможностей большинства реализаций <span>C++</span>. Как следствие,
        нарушение правила ODR может являться источником очень тонких ошибок. К сожалению, техника
        помещения совместно используемых определений в заголовочные файлы с последующим их
        включением в исходный файл не предохраняет от последней формы нарушения правила. Локальные
        <i>typedef</i> и макросы могут изменить смысл включаемых объявлений. Наилучшей защитой от
        подобных проблем является создание как можно более самодостаточных заголовочных файлов.
    </p>
    <h2 id="l9_3_3"> 3.4. Стражи включения </h2>
    <p>
        Реальные программы обычно содержат несколько заголовочных файлов. Попытка представить каждый
        логический модуль программы в виде согласованного, самодостаточного фрагмента может привести
        к тому, что некоторые объявления окажутся избыточными. Такая избыточность может привести к
        ошибкам, т.к. заголовочный файл, содержащий определение класса или встроенной функции, может
        быть дважды включён в одну и ту же единицу компиляции.
    </p>
    <p>
        Есть два возможных решения этой проблемы:
    </p>
    <ul>
        <li> реорганизовать программу таким образом, чтобы исключить избыточность;</li>
        <li> найти метод, допускающий повторное включение заголовочных файлов.</li>
    </ul>
    <p>
        Первый подход довольно утомителен и непрактичен при создании программ реального размера.
        Кроме того, избыточность может быть необходима для того, чтобы отдельные части программ были
        осмысленными сами по себе.
    </p>
    <p>
        Выигрыш от устранения избыточных включений и вытекающего отсюда упрощения программы может
        быть весьма значительным и с логической точки зрения, и в плане сокращения времени
        компиляции. Однако анализ такой избыточности очень редко бывает полным, поэтому требуется
        метод избыточного включения. Традиционным решением является вставка так называемых <i>стражей
        включения</i>.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span>// file1.h</span>
                <span class="chiavi">#ifndef</span> FILE1_H
                <span class="chiavi">#define</span> FILE1_H
                ...
                <span class="chiavi">#endif</span>
            </td>
        </tr>
    </table>
    <p>
        Содержимое файла между <i>#ifndef</i> и <i>#endif</i> игнорируется компилятором, если <i>FILE1_H</i>
        определено. В этом случае при первом просмотре файла во время компиляции его содержимое
        читается, и <i>FILE1_H</i> определяется. Если файл будет включён в единицу компиляции второй
        раз, его содержимое игнорируется. Метод не идеальный, но он работает и широко распространён
        в программах на С и <span>C++</span>. Все стандартные заголовочные файлы содержат стражей
        включения.
    </p>
    <p>
        Возможен другой способ использования стражей включения.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span>// file2.h</span>
                <span class="chiavi">#define</span> FILE2_H
                ...
                <span>// file2.cpp</span>
                <span class="chiavi">#if</span> !<span class="chiavi">defined</span>(FILE2_H)
                <span class="chiavi">#include</span> "file2.h"
                <span class="chiavi">#endif</span>
            </td>
        </tr>
    </table>
    <p>
        Второй вариант немного быстрее, зато первый вариант является самодостаточным.
    </p></section>

</body>
</html>
