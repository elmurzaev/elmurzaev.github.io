<!DOCTYPE html>
<html>
<head>

    <title>Лекция 3. Лексика языка</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<div class="left">
    <p></p>
    <p></p>
    <center><h2>Лекция 3.
        Лексика
        языка</h2></center>
    <p>
    </p>
    <p>
    </p>
    <p>Лекция посвящена описанию
        лексики языка Java.
    </p>
    <p>Лексика описывает, из чего состоит текст программы,
        каким образом он записывается и на какие простейшие слова (лексемы) компилятор
        разбивает программу при анализе. Лексемы (или tokens в английском
        варианте) - это основные "кирпичики", из которых строится любая
        программа на языке Java.
    </p>
    <p>Эта тема раскрывает многие детали внутреннего
        устройства языка, и невозможно написать ни одной строчки кода, не затронув ее.
        Именно поэтому курс начинается с основ лексического анализа.
    </p>
    <p>
    </p>
    <p>Ключевые слова: ASCII, Unicode, carriage return, linefeed, пробел, javadoc, идентификаторы,
        underscore, литералы.
    </p>
    <p>
    </p>
    <p>Кодировка
    </p>
    <p>Технология Java, как платформа, изначально спроектированная для Глобальной сети Internet,
        должна быть
        многоязыковой, а значит, обыч­ный набор символов ASCII (American Standard Code for
        Information Interchange, Американский стандартный код обмена информацией), включающий в себя
        лишь латинский алфавит, цифры и простейшие спе­циальные знаки (скобки, знаки
        препинания, арифметические операции и т.д.), недостаточен. Поэтому для записи
        текста программы применяется более универсальная кодировка Unicode.
    </p>
    <p>Как известно, Unicode представляет
        символы кодом из 2 байт, опи­сывая, таким образом, 65535 символов. Это
        позволяет поддерживать практически все распространенные языки мира. Первые 128
        символов совпадают с набором ASCII. Однако понятно, что требуется некоторое специальное
        обозначение, чтобы
        иметь возможность задавать в програм­ме любой символ Unicode, ведь никакая
        клавиатура не позволяет вводить более 65 тысяч различных знаков. Эта
        конструкция представляет символ Unicode, используя только символы ASCII. Например, если в
        программу нужно вставить знак с кодом 6917, необходимо его представить в
        шест-надцатеричном формате (1В05) и записать:
    </p>
    <p>
    </p>
    <p>\u1B05,
    </p>
    <p>причем буква и
        должна быть прописной, а шестнадцатеричные циф-РЬ1
        А, В, С, D, Е, F можно использовать произвольно, как заглавные, Так и
        строчные. Таким образом можно закодировать все символы
    </p>
    <p>Unicode от \u0000 до \uFFFF. Буквы русского алфавита начинаются с \u0410 (только буква Ё
        имеет код \u0401) по \u044F (код буквы ё \u0451). В последних версиях JDK в состав
        демонстрационных при­ложений и апплетов входит небольшая программа SymbolTest, позво­ляющая
        просматривать весь набор символов Unicode
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Ее аналог не­сложно
        написать самостоятельно. Для перекодирования больших текстов служит утилита native2ascii,
        также входящая в JDK. Она мо­жет
        работать как в прямом режиме — переводить из разнообразных кодировок в Unicode, записанный
        ASCII-символами, так и в
        обрат­ном (опция -reverse) — из Unicode в стандартную
        кодировку опера­ционной системы.
    </p>
    <p>В версиях языка Java до 1.1 применялся Unicode версии 1.1.5, в по­следнем выпуске 1.4
        используется 3.0. Таким образом, Java следит за раз­витием стандарта и базируется на
        современных версиях. Для
        любой JDK точную версию Unicode, используемую в
        ней, можно узнать из докумен­тации к классу Character. Официальный web-сайт стандарта, где
        можно получить дополнительную
        информацию,— http://www.Linicocle.org/.
    </p>
    <p>Итак, используя простейшую кодировку ASCII, можно ввести
        произ­вольную последовательность символов Unicode. Далее будет
        показано, что Unicode используется не для
        всех лексем, а только для тех, для которых важна поддержка многих языков, а
        именно: комментарии, идентификато­ры, символьные и строковые литералы. Для
        записи остальных лексем вполне достаточно ASCII-символов.
    </p>
    <p>
    </p>
    <p>Анализ программы
    </p>
    <p>Компилятор, анализируя
        программу, сразу разделяет ее на:
    </p>
    <p>•
        пробелы (white spaces);
    </p>
    <p>•
        комментарии (comments);
    </p>
    <p>•
        основные лексемы (tokens).
    </p>
    <p>
    </p>
    <p>Пробелы
    </p>
    <p>Пробелами в данном случае называют все символы, разбивающие текст
        программы на лексемы. Это как сам символ пробела (space, \u0020, десятичный код 32), так и
        знаки табуляции и перевода строки. Они ис­пользуются
        для разделения лексем, а также для оформления кода, чтобы его было легче
        читать. Например, следующую часть программы (вычисле­ние корней квадратного
        уравнения):
    </p>
    <p>
    </p>
    <p>double а = 1, b = 1, с = 6; double D = b * b - 4 * а * с;
    </p>
    <p>if (D &gt;=0) {
    </p>
    <p>double х1 = (-b + Math.sqrt (D)) / (2 * а); double х2 - (-b - Math.sqrt
        (D)) / (2 * а);
    </p>
    <p>}
    </p>
    <p>можно записать и в таком виде:
    </p>
    <p>
    </p>
    <p>double
        a=1,b=1,c=6;double D=b*b-4*a*c;if(D&gt;=0) {double
    </p>
    <p>x1
        =(-b+Math.sqrt(D))/(2*a);double x2=(-b-Math.sqrt(D))/(2*a);}
    </p>
    <p>В обоих случаях компилятор сгенерирует абсолютно одинаковый код.
        Единственное соображение, которым должен руководствоваться разработчик,—
        легкость чтения и дальнейшей поддержки такого кода.
    </p>
    <p>Для разбиения текста на строки в ASCII используется два символа -"возврат каретки" (carriage
        return, CR, \u000d, десятичный код 13) и сим­вол новой строки (linefeed, LF, \u000a,
        десятичный код 10)
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Чтобы не за­висеть от особенностей используемой
        платформы, в Java применяется на­иболее
        гибкий подход. Завершением строки считается:
    </p>
    <p>•
        ASCII-символ LF, символ новой строки;
    </p>
    <p>•
        ASCII-символ CR, "возврат каретки";
    </p>
    <p>•
        символ CR, за которым сразу же следует символ LF. Разбиение на строки важно для корректного
        разбиения на лексемы
    </p>
    <p>(как уже говорилось, завершение строки также служит
        разделителем меж­ду лексемами), для правильной работы со строковыми
        комментариями (см. следующую тему "Комментарии"), а также для вывода
        отладочной информации (при выводе ошибок компиляции и времени исполнения
        указывается, на какой строке исходного кода они возникли). Итак, пробелами в Java считаются:
    </p>
    <p>•  ASCII-символ SP, space, пробел, \u0020, десятичный код 32;
    </p>
    <p>•
        ASCII-символ НТ, horizontal tab, символ горизонтальной табу­ляции, \u0009, десятичный код 9;
    </p>
    <p>•
        ASCII-символ FF, form feed, символ перевода
        страницы (был вве­ден для работы с принтером), \u000c, десятичный код 12;
    </p>
    <p>•
        завершение строки.
    </p>
    <p>
    </p>
    <p>Комментарии
    </p>
    <p>Комментарии не влияют на
        результирующий бинарный код и ис­пользуются только для ввода пояснений к
        программе. В Java комментарии бывают двух видов:
    </p>
    <p>•
        строчные
    </p>
    <p>•
        блочные
    </p>
    <p>Курс
    </p>
    <p>Программирование
        на Java
    </p>
    <p>Лексика
        языка
    </p>
    <p>
    </p>
    <p>Строчные комментарии начинаются с ASCII-символов // и
        длятся до конца текущей строки. Как правило, они используются для пояснения
        именно этой строки, например:
    </p>
    <p>int у=1970; // год рождения
    </p>
    <p>Блочные комментарии располагаются между ASCII-символами /* и */,
        могут занимать произвольное количество строк, например:
    </p>
    <p>
    </p>
    <p>/*
    </p>
    <p>Этот цикл не может начинаться с нуля из-за особенностей алгоритма
    </p>
    <p>7
    </p>
    <p>for (int i=1; К10; i++) { }
    </p>
    <p>Часто блочные комментарии оформляют следующим образом (каж­дая строка
        начинается с *):
    </p>
    <p>
    </p>
    <p>Г
    </p>
    <p>*
        Описание алгоритма работы
    </p>
    <p>*
        следующего цикла while
    </p>
    <p>7
    </p>
    <p>while (х &gt; 0) { }
    </p>
    <p>Блочный комментарий не обязательно должен располагаться на не­скольких
        строках, он может даже находиться в середине оператора:
    </p>
    <p>
    </p>
    <p>float s = 2*Math.PI/*getRadius()7; // Закомментировано для отладки
    </p>
    <p>В этом примере блочный комментарий разбивает арифметические операции.
        Выражение Math.PI предоставляет значение константы PI, опре­деленное в
        классе Math. Вызов метода getRadius()
        теперь закомментирован и
        не будет произведен, переменная s всегда будет принимать значение 2 PI. Завершает строку
        строчный комментарий.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Комментарии не могут находиться в символьных и строковых лите­ралах,
        идентификаторах (эти понятия подробно рассматриваются далее в этой лекции).
        Следующий пример содержит случаи неправильного при­менения комментариев:
    </p>
    <p>// В этом примере текст
        /*...*/ станет просто частью строки s
    </p>
    <p>String s = "text/*just
        text7";
    </p>
    <p>/*
    </p>
    <p>*
        Следующая строка станет
        причиной ошибки при компиляции,
    </p>
    <p>*
        так как комментарий разбил
        имя метода getRadius()
    </p>
    <p>7
    </p>
    <p>circle.
        get/*comment7Radius(); А такой код допустим:
    </p>
    <p>// Комментарий может
        разделять вызовы функций: cirle./*commerrt7getRadius();
    </p>
    <p>// Комментарий может
        заменять пробелы: int/*comment7x=1 ;
    </p>
    <p>В последней строке
        между названием типа данных int и названием йеременной х обязательно должен быть пробел или,
        как в
        данном примере, комментарий.
    </p>
    <p>Комментарии не могут быть вложенными. Символы /*, */. // не име­ют
        никакого особенного значения внутри уже открытых комментариев, как строчных, так и
        блочных. Таким образом, в примере
    </p>
    <p>
    </p>
    <p>/* начало комментария /* ///** завершение тут: */
    </p>
    <p>
    </p>
    <p>описан только один блочный комментарий. А в следующем примере (строки
        кода пронумерованы для удобства)
    </p>
    <p>
    </p>
    <p>1.   г
    </p>
    <p>2.          comment
    </p>
    <p>4.
        more comments
    </p>
    <p>5.
        7
    </p>
    <p>6.
        finish
    </p>
    <p>7.   7
    </p>
    <p>
    </p>
    <p>компилятор выдаст
        ошибку. Блочный комментарий начался в строке 1 с комбинации символов /*. Вторая открывающая
        комбинация /* на строке 3 будет проигнорирована, так как находится уже внутри комментария.
        Символы
        7 в строке 5 завершат его, а строка 7 породит ошибку — попыт­ка закрыть комментарий, который
        не был начат.
    </p>
    <p>Любые комментарии полностью удаляются из программы во время компиляции,
        поэтому их можно использовать неограниченно, не опаса-
    </p>
    <p>87
    </p>
    <p>ясь, что это повлияет на бинарный код. Основное их
        предназначение -сделать программу простой для понимания, в том числе и для
        других раз­работчиков, которым придется в ней разбираться по какой-либо причи­не.
        Также комментарии зачастую используются для временного исключе­ния частей кода,
        например:
    </p>
    <p>intx = 2; int у = 0;
    </p>
    <p>/*
    </p>
    <p>if (х &gt; 0)
    </p>
    <p>у = у + х*2; else
    </p>
    <p>у = -у - х*4;
    </p>
    <p>7
    </p>
    <p>У = У*У;// + 2*х;
    </p>
    <p>В этом примере закомментировано выражение if-else и оператор сложения +2*х.
    </p>
    <p>Как уже говорилось выше, комментарии можно писать символами Unicode, то есть на любом
        языке, удобном разработчику.
    </p>
    <p>Кроме этого, существует особый вид блочного комментария -комментарий
        разработчика
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Он применяется для автоматического со­здания документации кода. В
        стандартную поставку JDK, начиная с версии 1.0, входит специальная утилита javadoc. На вход
        ей
        подается исходный код классов, а на выходе получается удобная документация в HTML-формате,
        которая
        описывает все классы, все их поля и методы. При этом активно используются
        гиперссылки, что существенно упро­щает изучение программы (например, читая
        описание метода, можно с помощью одного нажатия мыши перейти на описание типов,
        использу­емых в качестве аргументов или возвращаемого значения). Однако по­нятно,
        что одного названия метода и перечисления его аргументов не­достаточно для
        понимания его работы. Необходимы дополнительные пояснения от разработчика.
    </p>
    <p>Комментарий разработчика записывается так же, как и блочный.
        Единственное различие в начальной комбинации символов — для доку­ментации
        комментарий необходимо начинать с /**. Например:
    </p>
    <p>*
        Вычисление модуля целого
        числа.
    </p>
    <p>*
        Этот метод возвращает
    </p>
    <p>*
        абсолютное значение
        аргумента х.
    </p>
    <p>7
    </p>
    <p>int getAbs(intx) { if (х&gt;=0)
    </p>
    <p>return х; else
    </p>
    <p>return -x;
    </p>
    <p>}
    </p>
    <p>Первое предложение должно содержать краткое резюме всего комментария. В
        дальнейшем оно будет использовано как пояснение этой функции в списке всех
        методов класса (ниже будут описаны все конструкции языка, для которых
        применяется комментарий разра­ботчика).
    </p>
    <p>Поскольку в результате создается HTML-документация, то и
        ком­ментарий необходимо писать по правилам HTML. Допускается
        примене­ние тегов, таких как &lt;Ь&gt; и &lt;р&gt; . Однако теги заголовков с &lt;h1 &gt; по
        &lt;h6&gt; и &lt;hr&gt; использовать
        нельзя, так как они активно применяются javadoc для создания структуры документации.
    </p>
    <p>Символ * в начале каждой строки и предшествующие ему пробелы и знаки
        табуляции игнорируются. Их можно не использовать вообще, но они удобны, когда
        необходимо форматирование, скажем, в примерах кода.
    </p>
    <p>
    </p>
    <p>j-k-k
    </p>
    <p>*
        Первое предложение -
        краткое описание метода.
    </p>
    <p>*
        &lt;р&gt;
    </p>
    <p>*
        Так оформляется пример
        кода:
    </p>
    <p>*
        &lt;blockquote&gt;
    </p>
    <p>*
        &lt;рге&gt;
    </p>
    <p>*
        if
        (condition==true) {
    </p>
    <p>x = getWidht(); у =
        x.getHeight();
    </p>
    <p>* }
    </p>
    <p>*
        &lt;/pre&gt;&lt;/blockquote&gt;
    </p>
    <p>*
        Атак описывается HTML-список:
    </p>
    <p>*
        &lt;ul&gt;
    </p>
    <p>*
        &lt;П&gt;Можно
        использовать наклонный шрифт &lt;i&gt;KypcnB&lt;/i&gt;,
    </p>
    <p>*
        &lt;Н&gt;или жирный
        &lt;Ь&gt;жирный&lt;/Ь&gt;.
    </p>
    <p>*
        &lt;/ul&gt; 7
    </p>
    <p>public void
        calculate (int x, int y) { }
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Из этого комментария будет сгенерирован HTML-код, выглядящий
        примерно так:
    </p>
    <p>
    </p>
    <p>Первое предложение -
        краткое описание метода.
    </p>
    <p>
    </p>
    <p>Так оформляется пример
        кода:
    </p>
    <p>if (condition==true) { x = gerWidht(); у = x.getHeight();
    </p>
    <p>}
    </p>
    <p>А так описывается HTML-список:
    </p>
    <p>•
        Можно использовать
        наклонный шрифт курсив,
    </p>
    <p>•
        или жирный жирный.
    </p>
    <p>Наконец, javadoc поддерживает
        специальные теги. Они начинаются с символа @. Подробное описание этих тегов
        можно найти в документа­ции. Например, можно использовать тег @see, чтобы сослаться
        на другой класс, поле или метод, или даже на другой Internet-сайт.
    </p>
    <p>*
        Краткое описание.
    </p>
    <p>*
        Развернутый комментарий.
    </p>
    <p>*
    </p>
    <p>*
        @see java.lang.String
    </p>
    <p>*
        @see java.lang.Math#PI
    </p>
    <p>* @see &lt;a href="java.sun.com"&gt;Official
        Java site&lt;/a&gt;
    </p>
    <p>7
    </p>
    <p>Первая ссылка указывает на класс String Qava.lang - название биб­лиотеки, в которой находится
        этот класс), вторая - на
        поле PI класса Math (символ # разделяет название класса и его полей или методов), тре­тья
        ссылается на официальный сайт Java.
    </p>
    <p>Комментарии
        разработчика могут быть записаны перед объявлением классов, интерфейсов, полей,
        методов и конструкторов. Если записать комментарий /**...*/ в другой части
        кода, то ошибки не будет, но он не по­падет в документацию, генерируемую javadoc. Кроме
        того, можно
        описать пакет (так называются библиотеки, или модули, в Java). Для этого необхо­димо
        создать специальный файл package.html, сохранить в нем коммента­рий и поместить его в
        каталог пакета. HTML-текст,
        содержащийся между тегами &lt;body&gt; и &lt;/body&gt;, будет помещен в документацию, а
        первое пред­ложение будет
        использоваться для краткой характеристики этого пакета.
    </p>
    <p>Все классы стандартных библиотек Java поставляются в виде исход­ного текста и можно увидеть,
        как хорошо они
        комментированы. Стан­дартная документация по этим классам сгенерирована
        утилитой javadoc. Для любой программы также можно подготовить подобное описание, не­обходимы
        лишь грамотные и аккуратные комментарии в исходном коде. Кроме того, Java предоставляет
        возможность генерировать с помощью javadoc документацию с нестандартным внешним видом.
    </p>
    <p>
    </p>
    <p>Лексемы
    </p>
    <p>Итак, мы рассмотрели пробелы (в широком смысле этого слова, т.е. все
        символы, отвечающие за форматирование текста программы) и ком­ментарии,
        применяемые для ввода пояснений к коду. С точки зрения программиста они
        применяются для того, чтобы сделать программу более читаемой и понятной для
        дальнейшего развития.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>С точки зрения компилятора, а точнее его части, отвечающей за лек­сический
        разбор, основная роль пробелов и комментариев — служить раз­делителями между
        лексемами, причем сами разделители далее отбрасыва­ются и на компилированный
        код не влияют. Например, все следующие примеры объявления переменной
        эквивалентны:
    </p>
    <p>
    </p>
    <p>// Используем пробел в
        качестве разделителя, int х = 3 ;
    </p>
    <p>
    </p>
    <p>// здесь разделителем
        является перевод строки int
    </p>
    <p>x
    </p>
    <p>
    </p>
    <p>3
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>// здесь разделяем знаком
        табуляции int х = 3 ;
    </p>
    <p>
    </p>
    <p>/*
    </p>
    <p>* Единственный принципиально необходимый разделитель
    </p>
    <p>* между названием типа данных int и именем переменной
        х
    </p>
    <p>*
        здесь описан комментарием
        блочного типа.
    </p>
    <p>7
    </p>
    <p>int/**/x=3;
    </p>
    <p>Конечно, лексемы очень разнообразными именно они определяют многие
        свойства языка. Рассмотрим все их виды более подробно.
    </p>
    <p>
    </p>
    <p>Виды лексем
    </p>
    <p>Ниже перечислены все виды
        лексем в Java:
    </p>
    <p>•
        идентификаторы (identifiers);
    </p>
    <p>•
        ключевые слова (key words);
    </p>
    <p>•
        литералы (literals);
    </p>
    <p>•
        разделители (separators);
    </p>
    <p>•
        операторы (operators). Рассмотрим их по отдельности.
    </p>
    <p>
    </p>
    <p>Идентификаторы
    </p>
    <p>Идентификаторы - это имена, которые даются различным элементам языка для
        упрощения доступа к ним. Имена имеют пакеты, классы, ин­терфейсы, поля, методы,
        аргументы и локальные переменные (все эти по­нятия подробно рассматриваются в
        следующих лекциях). Идентификато­ры можно записывать символами Unicode, то есть на любом
        удобном язы­ке. Длина имени не ограничена.
    </p>
    <p>Идентификатор состоит из букв и цифр. Имя не может начинаться с цифры. Java-буквы,
        используемые в идентификаторах, включают в себя ASCII-символы A-Z (\u0041-\u005a), a-z
        (\u0061-\u007a), а также знаки подчеркивания _ (ASCII underscore, \u005f) и доллара $
        (\u0024). Знак дол­лара используется только при автоматической генерации кода
        (чтобы ис­ключить случайное совпадение имен), либо при использовании каких-ли­бо
        старых библиотек, в которых допускались имена с этим символом. Java-цифры включают в
        себя обычные ASCII-цифры 0-9 (\u0030-\u0039).
    </p>
    <p>Для идентификаторов не допускаются совпадения с зарезервирован­ными
        словами (это ключевые слова, булевские литералы true и false и null-литерал null). Конечно,
        если 2 идентификатора включают в себя разные буквы, которые
        одинаково выглядят (например, латинская и русская буквы А), то они считаются
        различными.
    </p>
    <p>В этой лекции уже
        применялись следующие идентификаторы:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Character, а, Ь, с, D, х1, х2, Math, sqrt, х, у, i, s, PI, getRadius,
    </p>
    <p>circle, getAbs, calculate, condition, getWidth, getHeight, java,
    </p>
    <p>lang, String
    </p>
    <p>Также допустимыми являются идентификаторы: Компьютер, COLOR_RED, _, aVeryLongNameOfTheMethod
    </p>
    <p>Ключевые
        слова
    </p>
    <p>Ключевые слова — это зарезервированные слова, состоящие из А8СП-символов
        и выполняющие различные задачи языка. Вот их полный список (48 слов):
    </p>
    <p>
    </p>
    <table border="0" cellpadding="0" cellspacing="0" class="MsoNormalTable">
        <tr>
            <td valign="top" width="69">
                <p>abstract
                </p>
            </td>
            <td valign="top" width="81">
                <p>default
                </p>
            </td>
            <td valign="top" width="98">
                <p>if
                </p>
            </td>
            <td valign="top" width="95">
                <p>private
                </p>
            </td>
            <td valign="top" width="61">
                <p>this
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>boolean
                </p>
            </td>
            <td valign="top" width="81">
                <p>do
                </p>
            </td>
            <td valign="top" width="98">
                <p>implements
                </p>
            </td>
            <td valign="top" width="95">
                <p>protected
                </p>
            </td>
            <td valign="top" width="61">
                <p>throw
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>break
                </p>
            </td>
            <td valign="top" width="81">
                <p>double
                </p>
            </td>
            <td valign="top" width="98">
                <p>import
                </p>
            </td>
            <td valign="top" width="95">
                <p>public
                </p>
            </td>
            <td valign="top" width="61">
                <p>throws
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>byte
                </p>
            </td>
            <td valign="top" width="81">
                <p>else
                </p>
            </td>
            <td valign="top" width="98">
                <p>instanceof
                </p>
            </td>
            <td valign="top" width="95">
                <p>return
                </p>
            </td>
            <td valign="top" width="61">
                <p>transient
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>case
                </p>
            </td>
            <td valign="top" width="81">
                <p>extends
                </p>
            </td>
            <td valign="top" width="98">
                <p>int
                </p>
            </td>
            <td valign="top" width="95">
                <p>short
                </p>
            </td>
            <td valign="top" width="61">
                <p>try
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>catch
                </p>
            </td>
            <td valign="top" width="81">
                <p>final
                </p>
            </td>
            <td valign="top" width="98">
                <p>interface
                </p>
            </td>
            <td valign="top" width="95">
                <p>static
                </p>
            </td>
            <td valign="top" width="61">
                <p>void
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>char
                </p>
            </td>
            <td valign="top" width="81">
                <p>finally
                </p>
            </td>
            <td valign="top" width="98">
                <p>long
                </p>
            </td>
            <td valign="top" width="95">
                <p>strictfp
                </p>
            </td>
            <td valign="top" width="61">
                <p>volatile
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>class
                </p>
            </td>
            <td valign="top" width="81">
                <p>float
                </p>
            </td>
            <td valign="top" width="98">
                <p>native
                </p>
            </td>
            <td valign="top" width="95">
                <p>super
                </p>
            </td>
            <td valign="top" width="61">
                <p>while
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>const
                </p>
            </td>
            <td valign="top" width="81">
                <p>for
                </p>
            </td>
            <td valign="top" width="98">
                <p>new
                </p>
            </td>
            <td valign="top" width="95">
                <p>switch
                </p>
            </td>
            <td valign="top" width="61">
                <p>
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>continue
                </p>
            </td>
            <td valign="top" width="81">
                <p>goto
                </p>
            </td>
            <td valign="top" width="98">
                <p>package
                </p>
            </td>
            <td valign="top" width="95">
                <p>synchronized
                </p>
            </td>
            <td valign="top" width="61">
                <p>
                </p>
            </td>
        </tr>
    </table>
    <p>Ключевые слова goto и const зарезервированы, но не используются. Это сделано для того, чтобы
        компилятор мог правильно отреагировать на их использование в других языках. Напротив, оба
        булевских литерала true, false и null-литерал null часто считают ключевыми
        словами (возмож­но, потому, что многие средства разработки подсвечивают их
        таким же образом), однако это именно литералы.
    </p>
    <p>Значение всех ключевых слов будет рассматриваться в следующих лекциях.
    </p>
    <p>
    </p>
    <p>Литералы
    </p>
    <p>Литералы позволяют задать в программе значения для числовых, символьных
        и строковых выражений, а также null-литералов. Всего в Java определены следующие виды
        литералов:
    </p>
    <p>•
        целочисленный (integer);
    </p>
    <p>•
        дробный (floating-point);
    </p>
    <p>•
        булевский (boolean);
    </p>
    <p>•
        символьный (character);
    </p>
    <p>•
        строковый (string);
    </p>
    <p>•
        null-литерал (null-literal). Рассмотрим их по отдельности.
    </p>
    <p>Целочисленные литералы
    </p>
    <p>Целочисленные литералы позволяют задавать целочисленные зна­чения в
        десятеричном, восьмеричном и шестнадцатеричном виде. Деся­теричный формат
        традиционен и ничем не отличается от правил, приня­тых в других языках.
        Значения в восьмеричном виде начинаются с нуля, и, конечно, использование цифр
        8 и 9 запрещено. Запись шестнадцате-ричных чисел начинается с Ох или ОХ (цифра
        0 и латинская ASCII-буква X в произвольном регистре). Таким образом, ноль можно записать
        тремя различными способами:
    </p>
    <p>
    </p>
    <p>О
    </p>
    <p>00 0x0
    </p>
    <p>Как обычно, для записи цифр 10-15 в шестнадцатеричном формате
        используются буквы А, В, С, D, Е, F, заглавные или
        прописные. Примеры таких литералов:
    </p>
    <p>
    </p>
    <p>OxaBcDeF, OxCafe, OxDEC
    </p>
    <p>
    </p>
    <p>Типы данных рассматриваются ниже, однако здесь необходимо упомянуть два
        целочисленных типа int и long длиной 4 и 8 байт, соответственно (или 32 и 64 бита,
        соответственно).
        Оба эти типа знаковые, т.е. тип int хранит значения от -231 до 23,-1, или от
        -2.147.483.648 до 2.147.483.647. По умолчанию целочисленный литерал имеет тип int, а значит,
        в
        программе допустимо использовать литералы только от 0 до 2147483648, иначе
        возникнет ошибка компиляции
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> При этом литерал 2147483648 можно использовать
        только как аргумент унарного оператора -:
    </p>
    <p>
    </p>
    <p>int х = -2147483648; \\верно
    </p>
    <p>int у = 5-2147483648; \\
        здесь возникнет ошибка компиляции
    </p>
    <p>
    </p>
    <p>Соответственно, допустимые литералы в восьмеричной записи долж­ны быть
        от 00 до 017777777777 (=231-1), с унарным оператором - допусти­мо
        также -020000000000 (= -231). Аналогично для шестнадцатеричного
        формата - от 0x0 до 0x7fffffff (=23,-1), а также -0x80000000 (= -231).
    </p>
    <p>Тип long имеет длину 64 бита, а значит, позволяет хранить значения от -263
        до 263-1. Чтобы ввести такой литерал, необходимо в конце поста­вить
        латинскую букву L или I, тогда все значение будет трактоваться как long. Аналогично можно
        выписать
        максимальные допустимые значения для них:
    </p>
    <p>9223372036854775807L
    </p>
    <p>0777777777777777777777L
    </p>
    <p>0x7fffffffffffffffL
    </p>
    <p>//
        наибольшие отрицательные значения: -9223372036854775808L -01000000000000000000000L
        -0x8000000000000000L
    </p>
    <p>Другие примеры целочисленных литералов типа long: 0L, 1231, OxCOBOL
    </p>
    <p>
    </p>
    <p>Дробные литералы
    </p>
    <p>Дробные литералы представляют собой числа с плавающей десятич­ной
        точкой. Правила записи таких чисел такие же, как и в большинстве современных
        языков программирования.
    </p>
    <p>Примеры:
    </p>
    <p>
    </p>
    <p>3.14 2.
    </p>
    <p>.5
    </p>
    <p>7е10 3.1Е-20
    </p>
    <p>Таким образом, дробный литерал состоит из следующих составных частей:
    </p>
    <p>•
        целая часть;
    </p>
    <p>•
        десятичная точка
        (используется ASCII-символ точка);
    </p>
    <p>•
        дробная часть;
    </p>
    <p>•
        показатель степени
        (состоит из латинской ASCII-буквы Е в про­извольном регистре и целого числа с опциональным
        знаком +
        или -);
    </p>
    <p>•
        окончание-указатель типа.
    </p>
    <p>Целая и дробная части записываются десятичными цифрами, а ука­затель
        типа (аналог указателя L или I для
        целочисленных литералов типа long)
    </p>
    <p>имеет два возможных значения - латинская ASCII-буква D (для ти­па double) или F (для типа
        float) в произвольном
        регистре. Они будут по­дробно рассмотрены ниже.
    </p>
    <p>Необходимыми частями
        являются:
    </p>
    <p>•
        хотя бы одна цифра в целой
        или дробной части;
    </p>
    <p>•
        десятичная точка или
        показатель степени, или указатель типа.
    </p>
    <p>Все остальные части необязательные. Таким образом,
        "минимальные" дробные литералы могут быть записаны, например, так:
    </p>
    <p>1. .1
    </p>
    <p>1е1 1f
    </p>
    <p>В Java есть два дробных
        типа, упомянутые выше, - float и double. Их длина - 4 и 8 байт или 32 и 64 бита,
        соответственно. Дробный литерал
        имеет тип float, если он заканчивается на латинскую букву F в произволь­ном регистре
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> В противном случае он рассматривается как
        значение типа double и может включать в себя
        окончание D или d, как признак типа double (используется только для наглядности).
    </p>
    <p>
    </p>
    <p>//float-литералы:
    </p>
    <p>1f, 3.14F, Of, 1e+5F
    </p>
    <p>// double-литералы:
    </p>
    <p>0., 3.14d, 1e-4, 31.34E45D
    </p>
    <p>В Java дробные числа 32-битного типа float и 64-битного типа dou­ble хранятся в памяти в
        бинарном виде в формате, стандартизированном спецификацией IEEE
        754 (полное название — IEEE Standard for Binary Floating-Point Arithmetic,
        ANSI/IEEE Standard 754-1985 (IEEE, New York)). В этой спецификации описаны не только
        конечные дробные вели­чины, но и
        еще несколько особых значений, а именно:
    </p>
    <p>• положительная и отрицательная бесконечности (positive/negative infinity);
    </p>
    <p>• значение "не число", Not-a-Number, сокращенно NaN;
    </p>
    <p>• положительный и отрицательный нули.
    </p>
    <p>Для этих значений нет специальных обозначений. Чтобы получить та­кие
        величины, необходимо либо произвести арифметическую операцию (на­пример,
        результатом деления ноль на ноль 0.0/0.0 является NaN), либо обра­титься
        к константам в классах Float и Double, а именно POSIT1VEJNFINITY, NEGATIVEJNFINITY и NaN.
        Более подробно ра­бота
        с этими особенными значениями рассматривается в следующей лекции.
    </p>
    <p>Типы данных накладывают
        ограничения на возможные значения ли­тералов, как и для целочисленных типов.
        Максимальное положительное конечное значение дробного литерала:
    </p>
    <p>• для float: 3.40282347e+38f
    </p>
    <p>• для double: 1.79769313486231570е+308
    </p>
    <p>Кроме того, для дробных величин становится важным еще одно Предельное значение — минимальное
        положительное ненулевое значение:
    </p>
    <p>•
        для float: 1.40239846e-45f
    </p>
    <p>•
        для double: 4.94065645841246544e-324
    </p>
    <p>Попытка указать литерал со слишком большим абсолютным значе­нием
        (например, 1 e40F) приведет к ошибке компиляции. Такая величина должна представляться
        бесконечностью. Аналогично, указание литерала со слишком малым ненулевым
        значением (например, 1е-350) также при­водит к ошибке. Это значение должно быть округлено до
        нуля.
        Однако ес­ли округление приводит не к нулю, то компилятор произведет его сам:
    </p>
    <p>//
        ошибка, выражение должно быть округлено до О
    </p>
    <p>0.0000000000000000000000000000000000000000000001f
    </p>
    <p>//
        ошибки нет, компилятор сам округляет до 1
    </p>
    <p>1.0000000000000000000000000000000000000000000001f
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>' Стандартных
        возможностей вводить дробные значения не в десятич­ной системе в Java нет, однако классы
        Float и Double предоставляют много вспомогательных методов, в том числе и для такой
        задачи.
    </p>
    <p>
    </p>
    <p>Логические литералы
    </p>
    <p>Логические литералы имеют два возможных значения — true и false. Эти
        два зарезервированных
        слова не являются ключевыми, но также не могут использоваться в качестве
        идентификатора.
    </p>
    <p>
    </p>
    <p>Символьные литералы
    </p>
    <p>Символьные литералы описывают один символ из набора Unicode, заключенный в
        одиночные кавычки, или апострофы (ASCII-символ sin­gly quote, \u0027). Например:
    </p>
    <p>'а'
        // латинская буква а '' // пробел
    </p>
    <p>'К'
        // греческая буква каппа
    </p>
    <p>
    </p>
    <p>Также допускается специальная запись для описания символа через его код (см. тему
        "Кодировка"). Примеры:
    </p>
    <p>'\u0041' //
        латинская буква А '\u0410' // русская буква А '\u0391' // греческая буква А
    </p>
    <p>Символьный литерал должен содержать строго один символ, или специальную
        последовательность, начинающуюся с \. Для записи специ­альных символов
        (неотображаемых и служебных, таких как ",', \) исполь­зуются следующие
        обозначения:
    </p>
    <p>
    </p>
    <p>\Ь \u0008  backspace BS - забой
    </p>
    <p>\х \u0009 horizontal tab НТ- табуляция
    </p>
    <p>\п \u000a  linefeed LF - конец строки
    </p>
    <p>\f \u000c form feed FF - конец страницы
    </p>
    <p>\r \u000d
        carriage return CR - возврат каретки
    </p>
    <p>\" \u0022 
        double quote " - двойная кавычка
    </p>
    <p>V \u0027
        single quote ' - одинарная кавычка
    </p>
    <p>\\ \u005c  backslash \ - обратная косая черта
    </p>
    <p>\восьмеричный код
    </p>
    <p>от \u0000 до \u00ff символа в
        восьмеричном формате.
    </p>
    <p>
    </p>
    <p>Первая колонка описывает стандартные обозначения специальных символов,
        используемые в Java-программах. Вторая колонка представляет их в стандартном виде
        Unicode-символов. Третья
        колонка содержит анг­лийские и русские описания. Использование \ в комбинации с
        другими символами приведет к ошибке компиляции.
    </p>
    <p>Поддержка ввода символов через восьмеричный код обеспечивается для
        совместимости с С. Например:
    </p>
    <p>
    </p>
    <p>'\101 ' // Эквивалентно '\u0041 '
    </p>
    <p>
    </p>
    <p>Однако таким образом можно задать лишь символы от \u0000 до \u00ff (т.е. с кодом от 0
        до 255), поэтому Unicode-последовательности предпочтительней.
    </p>
    <p>Поскольку обработка Unicode-последовательностей (\uhhhh) произво­дится раньше лексического
        анализа, то следующий пример
        является ошибкой:
    </p>
    <p>
    </p>
    <p>'\u000a' // символ конца
        строки
    </p>
    <p>
    </p>
    <p>Компилятор сначала преобразует \u000a в символ конца
        строки и кавычки окажутся на разных строках кода, что является ошибкой. Необ­ходимо
        использовать специальную последовательность:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>'\п' // правильное
        обозначение конца строки
    </p>
    <p>
    </p>
    <p>Аналогично и для символа \u000d (возврат каретки)
        необходимо ис­пользовать обозначение \г.
    </p>
    <p>Специальные символы можно использовать в составе как символь­ных, так и
        строковых литералов.
    </p>
    <p>
    </p>
    <p>Строковые литералы
    </p>
    <p>Строковые литералы состоят из набора символов и записываются в двойных
        кавычках. Длина может быть нулевой или сколь угодно боль­шой. Любой символ может быть
        представлен специальной последова­тельностью,
        начинающейся с \ (см. "Символьные литералы").
    </p>
    <p>""
        // литерал нулевой длины
    </p>
    <p>"\""
        //литерал, состоящий из одного символа "
    </p>
    <p>"Простой
        текст" //литерал длины 13
    </p>
    <p>Строковый литерал нельзя разбивать на несколько строк в коде про­граммы.
        Если требуется текстовое значение, состоящее из нескольких строк, то необходимо
        воспользоваться специальными символами \п и/или \г. Если же текст просто
        слишком длинный, чтобы уместиться на одной строке кода, можно использовать
        оператор конкатенации строк +. Примеры строковых литералов:
    </p>
    <p>//
        выражение-константа, составленное из двух литералов "Длинный текст "
        + "с переносом" /*
    </p>
    <p>*
        Строковый литерал, содержащий текст из
        двух строк:
    </p>
    <p>*
        Hello, world!
    </p>
    <p>*
        Hello!
    </p>
    <p>7
    </p>
    <p>"Hello,
        world!\r\nHello!"
    </p>
    <p>На строковые литералы распространяются те же правила, что и на сим­вольные
        в отношении использования символов новой строки \u000a и \u000d.
    </p>
    <p>Каждый строковый литерал является экземпляром класса String. Это определяет
        некоторые необычные свойства строковых литералов, ко­торые будут рассмотрены в
        следующей лекции.
    </p>
    <p>
    </p>
    <p>Null-литерал
    </p>
    <p>Null-литерал может
        принимать всего одно значение: null. Это литерал ссылочного типа, причем эта ссылка никуда
        не ссылается,
        объект отсутст-вУет. Разумеется, его можно применять к ссылкам
        любого объектного типа Д^ных. Типы данных подробно рассматриваются в следующей
        лекции.
    </p>
    <p>Разделители
    </p>
    <p>Разделители - это специальные символы, которые используются в служебных
        целях языка. Назначение каждого из них будет рассмотрено по ходу изложения
        курса. Вот их полный список:
    </p>
    <p>
    </p>
    <p>()[]{};&#9632;,
    </p>
    <p>
    </p>
    <p>Операторы
    </p>
    <p>Операторы используются в различных операциях — арифметичес­ких,
        логических, битовых, операциях сравнения и присваивания. Следу­ющие 37 лексем
        (все состоят только из ASCII-символов) являются опера­торами языка Java:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <table border="0" cellpadding="0" cellspacing="0" class="MsoNormalTable">
        <tr>
            <td valign="top" width="21">
                <p>-
                </p>
            </td>
            <td valign="top" width="28">
                <p>&gt;
                </p>
            </td>
            <td valign="top" width="36">
                <p>&lt;
                </p>
            </td>
            <td valign="top" width="36">
                <p>і
                </p>
            </td>
            <td valign="top" width="75">
                <p>?
                </p>
            </td>
            <td valign="top" width="43">
                <p>
                </p>
            </td>
            <td valign="top" width="39">
                <p>
                </p>
            </td>
            <td valign="top" width="40">
                <p>
                </p>
            </td>
            <td valign="top" width="75">
                <p>
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="21">
                <p>- -
                </p>
            </td>
            <td valign="top" width="28">
                <p>&lt;-
                </p>
            </td>
            <td valign="top" width="36">
                <p>&gt;=
                </p>
            </td>
            <td valign="top" width="36">
                <p>!=
                </p>
            </td>
            <td valign="top" width="75">
                <p>&amp;&amp;   &#161;1
                </p>
            </td>
            <td valign="top" width="43">
                <p>++
                </p>
            </td>
            <td valign="top" width="39">
                <p>--
                </p>
            </td>
            <td valign="top" width="40">
                <p>
                </p>
            </td>
            <td valign="top" width="75">
                <p>
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="21">
                <p>+
                </p>
            </td>
            <td valign="top" width="28">
                <p>-
                </p>
            </td>
            <td valign="top" width="36">
                <p>*
                </p>
            </td>
            <td valign="top" width="36">
                <p>/
                </p>
            </td>
            <td valign="top" width="75">
                <p>&amp;   1
                </p>
            </td>
            <td valign="top" width="43">
                <p>Л
                </p>
            </td>
            <td valign="top" width="39">
                <p>%
                </p>
            </td>
            <td valign="top" width="40">
                <p>«
                </p>
            </td>
            <td valign="top" width="75">
                <p>»     »&gt;
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="21">
                <p>+=
                </p>
            </td>
            <td valign="top" width="28">
                <p>-=
                </p>
            </td>
            <td valign="top" width="36">
                <p>
                </p>
            </td>
            <td valign="top" width="36">
                <p>/=
                </p>
            </td>
            <td valign="top" width="75">
                <p>&amp;= 1=
                </p>
            </td>
            <td width="43">
                <p>Л____
                </p>
            </td>
            <td valign="top" width="39">
                <p>%=
                </p>
            </td>
            <td valign="top" width="40">
                <p>«=
                </p>
            </td>
            <td valign="top" width="75">
                <p>»=   »=
                </p>
            </td>
        </tr>
    </table>
    <p>Большинство из них вполне очевидны и хорошо известны из других языков
        программирования, однако некоторые нюансы в работе с опера­торами в Java все же
        присутствуют, поэтому в конце лекции приводятся краткие комментарии к ним.
    </p>
    <p>
    </p>
    <p>Пример
        программы
    </p>
    <p>В заключение для примера приведем простейшую программу (тра­диционное Hello, world!), а затем
        классифицируем и подсчитаем исполь­зуемые лексемы:
    </p>
    <p>
    </p>
    <p>public class Demo {
    </p>
    <p>J-k-k
    </p>
    <p>*
        Основной метод, с которого начинается
        выполнение
    </p>
    <p>*
        любой Java программы.
    </p>
    <p>7
    </p>
    <p>public static void main (String
        args[]) { System.out.printlnf'Hello, world!");
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Итак, в приведенной программе есть один комментарий разработчи­ка, 7
        идентификаторов, 5 ключевых слов, 1 строковый литерал, 13 разде­лителей и ни
        одного оператора. Этот текст можно сохранить в файле Demo.java, скомпилировать й
        запустить (работа с JDK и стандартными
        утилитами была рассмотрена в первой лекции). Результатом работы будет, как
        очевидно:
    </p>
    <p>
    </p>
    <p>Hello, world!
    </p>
    <p>
    </p>
    <p>Дополнение. Работа с
        операторами
    </p>
    <p>Рассмотрим некоторые детали использования операторов в Java. Здесь будут описаны
        подробности, относящиеся к работе самих операто­ров. В следующей лекции
        детально рассматриваются особенности, возни­кающие при использовании различных
        типов данных (например, значе-йие операции 1 /2 равно 0, а 1/2. равно 0.5).
    </p>
    <p>
    </p>
    <p>Операторы присваивания и сравнения
    </p>
    <p>Во-первых, конечно же, различаются оператор присваивания = и оператор
        сравнения ==.
    </p>
    <p>
    </p>
    <p>х = 1 ; // присваиваем переменной х значение 1
    </p>
    <p>х == 1 // сравниваем значение переменной х с единицей
    </p>
    <p>
    </p>
    <p>Оператор сравнения всегда возвращает булевское значение trae или false. Оператор
        присваивания возвращает значение правого операнда. Поэтому обычная опечатка в
        языке С, когда эти операторы путают:
    </p>
    <p>
    </p>
    <p>//
        пример вызовет ошибку компилятора
    </p>
    <p>if (х=0) {// здесь должен применятся оператор
        сравнения ==
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>в Java легко устраняется.
        Поскольку выражение х=0 имеет числовое зна­чение 0, а не булевское (и тем более
        не воспринимается как всегда истин­ное), то компилятор сообщает об ошибке
        (необходимо писать х==0). Условие "не равно" записывается как !=.
        Например:
    </p>
    <p>
    </p>
    <p>if (х!=0) {
    </p>
    <p>float f = 1./х;
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Сочетание какого-либо оператора с оператором присваивания = • нижнюю
        строку в полном перечне в разделе "Операторы") использу­ется при
        изменении значения переменной. Например, следующие две строки эквивалентны:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>х = х + 1; х+= 1;
    </p>
    <p>
    </p>
    <p>Арифметические операции
    </p>
    <p>Наряду с четырьмя обычными арифметическими операциями +,-,*, /,
        существует оператор получения остатка от деления %, который может быть применен
        как к целочисленным аргументам, так и к дробным.
    </p>
    <p>Работа с целочисленными аргументами подчиняется простым пра­вилам. Если
        делится значение а на значение Ь, то выражение (а/Ь)*Ь+(а%Ь) должно в точности
        равняться а. Здесь, конечно, оператор деления целых чисел / всегда возвращает
        целое число. Например:
    </p>
    <p>9/5 возвращает 1 9/(-5) возвращает -1 (-9)/5 возвращает -1 (-9)/(-5) возвращает 1
    </p>
    <p>
    </p>
    <p>Остаток может быть положительным, только если делимое было по­ложительным.
        Соответственно, остаток может быть отрицательным только в случае отрицательного
        делимого.
    </p>
    <p>
    </p>
    <p>9%5 возвращает 4 9%(-5) возвращает 4 (-9)%5 возвращает -4 (-9)%(-5)
        возвращает -4
    </p>
    <p>
    </p>
    <p>Попытка получить остаток от деления на 0 приводит к ошибке.
    </p>
    <p>Деление с остатком для дробных чисел может быть произведено по двум
        различным алгоритмам. Один из них повторяет правила для целых чисел, и именно
        он представлен оператором %. Если в рассмотренном примере деления 9 на 5
        перейти к дробным числам, значение остатка во всех вариантах не изменится (оно
        будет также дробным, конечно).
    </p>
    <p>9.0%5.0 возвращает 4.0 9.0%(-5.0) возвращает 4.0 (-9.0)%5.0 возвращает
        -4.0 (-9.0)%(-5.0) возвращает -4.0
    </p>
    <p>Однако стандарт IEEE 754 определяет
        другие правила. Такой способ представлен методом стандартного класса
        Math.lEEEremainder(double f 1, double f2). Результат этого
        метода - значение, которое равно f 1 -f2*n, где п — целое число, ближайшее к значению f
        1/f2, а если два целых
        числа одинаково близки к этому отношению, то выбирается четное. По этому
        правилу значение остатка будет другим:
    </p>
    <p>Math.lEEEremainder(9.0, 5.0) возвращает -1.0 Math.lEEEremainder(9.0, -5.0) возвращает -1.0
        Math.lEEEremainder(-9.0, 5.0) возвращает 1.0 Math.lEEEremainder(-9.0, -5.0) возвращает 1.0
    </p>
    <p>Унарные операторы инкрементации ++ и декрементации --, как обычно, можно
        использовать как справа, так и слева.
    </p>
    <p>int х=1; int у=++х;
    </p>
    <p>В этом примере оператор ++ стоит перед переменной х, это означает, что
        сначала произойдет инкрементация, а затем значение х будет исполь­зовано для
        инициализации у. В результате после выполнения этих строк значения х и у будут равны 2.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>int х=1; int у=х++;
    </p>
    <p>А в этом примере сначала значение х будет использовано для инициализации
        у, и лишь затем
        произойдет инкрементация. В результате значение х будет равно 2, а у будет равно 1.
    </p>
    <p>
    </p>
    <p>Логические операторы
    </p>
    <p>Логические операторы "и" и "или" (&amp; и |) можно
        использовать в двух вариантах. Это связано с тем, что, как легко убедиться, для
        каждого опера­тора возможны случаи, когда значение первого операнда сразу
        определяет значение всего логического выражения. Если вторым операндом является
        значение некоторой функции, то появляется выбор - вызывать ее или нет, причем
        это решение может сказаться как на скорости, так и на функцио­нальности
        программы.
    </p>
    <p>Первый вариант операторов (&amp;, |) всегда вычисляет оба операнда,
        второй же - ( &amp;&amp;, 11 ) не будет продолжать вычисления, если значение выражения уже
        очевидно.
        Например:
    </p>
    <p>
    </p>
    <p>int х=1;
    </p>
    <p>(х&gt;0) | calculate(x) // в таком выражении произойдет вызов calulate (х&gt;0) 11
        calculate(x) // а в этом - нет
    </p>
    <p>
    </p>
    <p>Логический оператор отрицания "не" записывается как ! и,
        конечно, имеет только один вариант использования. Этот оператор меняет булев­ское
        значение на противоположное.
    </p>
    <p>
    </p>
    <p>int х=1;
    </p>
    <p>х&gt;0 // выражение
        истинно !(х&gt;0) // выражение ложно
    </p>
    <p>
    </p>
    <p>Оператор с условием ? : состоит из трех частей - условия и двух выра­жений.
        Сначала вычисляется условие (булевское выражение), а на основа­нии результата
        значение всего оператора определяется первым выражени­ем в случае получения
        истины и вторым - если условие ложно. Например, так можно вычислить модуль
        числа х:
    </p>
    <p>
    </p>
    <p>х&gt;0 ? х : -х
    </p>
    <p>
    </p>
    <p>Битовые операции
    </p>
    <p>Прежде чем переходить к битовым операциям, необходимо уточнить, каким
        именно образом целые числа представляются в двоичном виде. Ко­нечно, для
        неотрицательных величин это практически очевидно:
    </p>
    <p>0
        О
    </p>
    <p>1
        1
    </p>
    <p>2
        10
    </p>
    <p>3
        11
    </p>
    <p>4
        100
    </p>
    <p>5
        101
    </p>
    <p>
    </p>
    <p>и так далее. Однако как представляются отрицательные числа? Во-пер­вых,
        вводят понятие знакового бита. Первый бит начинает отвечать за знак, а именно 0
        означает положительное число, 1 — отрицательное. Но не следует думать, что
        остальные биты остаются неизменными. Напри­мер, если рассмотреть 8-битовое
        представление:
    </p>
    <p>-1 10000001 //это
        НЕВЕРНО! -2 10000010//это НЕВЕРНО! -3 10000011 //это НЕВЕРНО!
    </p>
    <p>Такой подход неверен! В частности, мы получаем сразу два представления дудя - 00000000 и
        100000000, что нерационально. Правильный алгоритм можно
        представить себе так. Чтобы получить значение -1, надо из 0 вычесть 1: 00000000
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>-00000001
    </p>
    <p>
    </p>
    <p>-11111111
    </p>
    <p>Итак, -1 в двоичном виде представляется как 11111111. Продолжаем
        применять тот же алгоритм (вычитаем 1):
    </p>
    <p>0 00000000 -1 11111111 -2 11111110 -3 11111101
    </p>
    <p>и так далее до
        значения 10000000, которое представляет собой наибольшее по модулю
        отрицательное число. Для 8-битового представления наиболь­шее положительное число
        01111111 (=127), а наименьшее отрицательное 10000000 (=-128). Поскольку всего 8
        бит определяет 28=256 значений, причем одно из них отводится для
        нуля, то становится ясно, почему наи­большие по модулю положительные й
        отрицательные значения различа­ются на единицу, а не совпадают.
    </p>
    <p>Как известно, битовые операции "и", "или",
        "исключающее или" принимают два аргумента и выполняют логическое
        действие попарно над соответствующими битами аргументов. При этом используются
        те же обозначения, что и для логических операторов, но, конечно, только в
        первом (одиночном) варианте. Например, вычислим выражение 5&amp;6:
    </p>
    <p>
    </p>
    <p>00000101    // число 5 в двоичном виде &amp;00000110    //число 6 в двоичном виде
    </p>
    <p>00000100    //проделали
        операцию "и" попарно над битами // в каждой позиции
    </p>
    <p>
    </p>
    <p>То есть выражение 5&amp;6
        равно 4.
    </p>
    <p>Исключение составляет лишь оператор "не" или "NOT", который для
        побитовых операций записывается как ~ (для логических было !). Этот оператор
        меняет каждый бит в числе на противоположный. Например,
    </p>
    <p>)=0. Можно легко установить общее правило для получения битового
        представления отрицательных чисел:
    </p>
    <p>Если п - целое положительное число, то -п в битовом представлении Равняется ~(п-1).
    </p>
    <p>Наконец, осталось
        рассмотреть лишь операторы побитового сдвига. В Java есть один оператор сдвига влево и два
        варианта сдвига вправо. Такое
        различие связано с наличием знакового бита.
    </p>
    <p>При сдвиге влево оператором &lt;&lt; все биты числа смещаются на ука­занное
        количество позиций влево, причем освободившиеся справа пози­ции заполняются
        нулями. Эта операция аналогична умножению на 2п и действует вполне
        предсказуемо, как при положительных, так и при отри­цательных аргументах.
    </p>
    <p>Рассмотрим примеры применения операторов сдвига для значений типа int, т.е. 32-битных
        чисел. Пусть положительным аргументом будет число 20, а отрицательным -21.
    </p>
    <p>
    </p>
    <p>// Сдвиг
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>влево для
        положительного числа 20 20 « 00 =
        00000000000000000000000000010100 = 20 20 « 01 =00000000000000000000000000101000
        = 40 20 « 02 = 00000000000000000000000001010000 = 80 20 «03 =
        00000000000000000000000010100000
        = 160 20 « 04 = 00000000000000000000000101000000 = 320
    </p>
    <p>
    </p>
    <p>20 « 25 =
        00101000000000000000000000000000 = 671088640
    </p>
    <p>20 « 26 =
        01010000000000000000000000000000 = 1342177280
    </p>
    <p>20 « 27 = 10100000000000000000000000000000 =
        -1610612736
    </p>
    <p>20 « 28 =
        01000000000000000000000000000000 = 1073741824
    </p>
    <p>20 « 29 = 10000000000000000000000000000000 = -2147483648
    </p>
    <p>20 « 30 =
        00000000000000000000000000000000 = о
    </p>
    <p>20 « 31
        =00000000000000000000000000000000 = о
    </p>
    <p>//
        Сдвиг влево для отрицательного числа -21
    </p>
    <p>-21 «00=
        11111111111111111111111111101011 =-21
    </p>
    <p>-21 «01 =
        11111111111111111111111111010110 = -42
    </p>
    <p>-21 «02 =
        11111111111111111111111110101100 =-84
    </p>
    <p>-21 « 03=11111111111111111111111101011000=-168
    </p>
    <p>-21 &lt;^ 04 = 11111111111111111111111010110000 = -336
    </p>
    <p>-21 «
        05=11111111111111111111110101100000=-672
    </p>
    <p>-21 « 25 =
        11010110000000000000000000000000 = -704643072 -21 « 26 =
        10101100000000000000000000000000 = -1409286144 -21 « 27 =
        01011000000000000000000000000000 = 1476395008 -21 « 28 =
        10110000000000000000000000000000 = -1342177280 -21 « 29 =
        01100000000000000000000000000000 =1610612736 -21 « 30 =
        11000000000000000000000000000000 .= -1073741824 -21 « 31 = 10000000000000000000000000000000
        = -2147483648
    </p>
    <p>Как видно из примера, неожиданности возникают тогда, когда $начащие биты
        начинают занимать первую позицию и влиять на знак результата.
    </p>
    <p>При сдвиге вправо все биты аргумента смещаются на указанное коли­чество
        позиций, соответственно, вправо. Однако встает вопрос — каким значением
        заполнять освобождающиеся позиции слева, в том числе и отве­чающую за знак.
        Есть два варианта. Оператор » использует для заполне­ния этих позиций значение
        знакового бита, то есть результат всегда имеет тот же знак, что и начальное
        значение. Второй оператор »&gt; заполняет их нулями, то есть результат всегда
        положительный.
    </p>
    <p>// Сдвиг вправо для положительного числа 20 // Оператор »
    </p>
    <p>20 » 00 = 00000000000000000000000000010100 = 20 20 » 01 =
        00000000000000000000000000001010 = 10 20 » 02 =
        00000000000000000000000000000101 =5 20 » 03 = 00000000000000000000000000000010
        = 2 20 » 04 = 00000000000000000000000000000001 = 1 20 » 05 =
        00000000000000000000000000000000 = о // Оператор »&gt;
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>20 »&gt; 00 = 00000000000000000000000000010100 = 20 20 »&gt; 01 =
        00000000000000000000000000001010 = 10 20 »&gt; 02 =
        00000000000000000000000000000101 = 5 20 »&gt; 03 =
        00000000000000000000000000000010 = 2 20 »&gt; 04 =
        00000000000000000000000000000001 = 1 20 »&gt; 05 = 00000000000000000000000000000000
        = о
    </p>
    <p>Очевидно, что для положительного аргумента операторы &gt;&gt; и
        &gt;&gt;&gt; Работают совершенно одинаково. Дальнейший сдвиг на большее количе­ство позиций
        будет также давать нулевой результат.
    </p>
    <p>// Сдвиг вправо для отрицательного числа -21 // Оператор &gt;&gt;
    </p>
    <p>-21 » 00 =11111111111111111111111111101011= -21 -21 »01 =
        11111111111111111111111111110101 =-11 -21 »02 =
        11111111111111111111111111111010 = -6 -21 » 03
        =11111111111111111111111111111101 =-3 -21 »04 =
        11111111111111111111111111111110 = -2 -21 »05 = 11111111111111111111111111111111
        =-1 // Оператор »&gt;
    </p>
    <p>-21 »&gt; 00 =
        11111111111111111111111111101011 = -21
    </p>
    <p>-21 &gt;» 01
        =01111111111111111111111111110101 =2147483637
    </p>
    <p>
    </p>
    <table border="0" cellpadding="0" cellspacing="0" class="MsoNormalTable">
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td colspan="2" valign="top" width="50">
                <p>&gt;» 02:
                </p>
            </td>
            <td valign="top" width="261">
                <p>=00111111111111111111111111111010=
                </p>
            </td>
            <td valign="top" width="81">
                <p>1073741818
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>03
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00011111111111111111111111111101 :
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 536870909
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>04
                </p>
            </td>
            <td valign="top" width="261">
                <p>=00001111111111111111111111111110=
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 268435454
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>05
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000111111111111111111111111111 =
                </p>
            </td>
            <td valign="top" width="81">
                <p>=134217727
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>24
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000000000000000000000011111111
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 255
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>25
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000000000000000000000001111111
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 127
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>26
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000000000000000000000000111111
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 63
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>27
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000000000000000000000000011111
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 31
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>28
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000000000000000000000000001111
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 15
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>29
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000000000000000000000000000111
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 7
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>&gt;»
                </p>
            </td>
            <td valign="top" width="20">
                <p>30
                </p>
            </td>
            <td valign="top" width="261">
                <p>=00000000000000000000000000000011
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 3
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>31
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000000000000000000000000000001
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 1
                </p>
            </td>
        </tr>
    </table>
    <p>Как видно из примеров, эти операции аналогичны делению на 2п. При­чем,
        если для положительных аргументов с ростом п результат закономерно стремится к
        0, то для отрицательных предельным значением является -1.
    </p>
    <p>
    </p>
    <p>Заключение
    </p>
    <p>В этой лекции были рассмотрены основы лексического анализа про­грамм Java. Для их записи
        применяется универсальная кодировка ишсос1е,позволяющая использовать любой язык
        помимо традиционного английского. Еще раз напомним, что использование Unicode возможно и
        необходимо в следующих конструкциях:
    </p>
    <p>•
        комментарии;
    </p>
    <p>•
        идентификаторы;
    </p>
    <p>•
        символьные и строковые
        литералы.
    </p>
    <p>Остальные же (пробелы, ключевые слова, числовые,
        булевские и null-ли-тералы, разделители и операторы) легко записываются с применением
        лишь ASCII-символов. В то же время любой Unicode-символ также мож­но
        задать в виде специальной последовательности ASCII-символов.
    </p>
    <p>Во время анализа компилятор выделяет из текста программы
        &lt;про-белы&gt; (были рассмотрены все символы, которые рассматриваются как
        пробелы) и комментарии,которые полностью удаляются из кода (были рассмотрены
        все виды комментариев, в частности комментарий разра­ботчика). Пробелы и все
        виды комментариев служат для разбиения текс­та программы на лексемы. Были
        рассмотрены все виды лексем,в том чис­ле все виды литералов.
    </p>
    <p>В дополнении были рассмотрены особенности применения различ­ных
        операторов.
    </p>
    <p>Вариант 1
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>Как записать в Java-программе символ с кодом 514?
    </p>
    <p>&#9633;
        '514'
    </p>
    <p>&#9633;
        \u0546
    </p>
    <p>&#9633;
        \u222
    </p>
    <p>&#9633;
        \u0222
    </p>
    <p>
    </p>
    <p>Какие
        из перечисленных идентификаторов являются корректными?
    </p>
    <p>&#9633;
        abc
    </p>
    <p>&#9633;
        lab
    </p>
    <p>&#9633;
        _bc
    </p>
    <p>&#9633;
        _1с$ас
    </p>
    <p>&#9633;
        $ас
    </p>
    <p>&#9633;
        for_
    </p>
    <p>&#9633;
        Int
    </p>
    <p>&#9633;
        byte
    </p>
    <p>
    </p>
    <p>Каким будет результат следующих
        действий?
    </p>
    <p>1/0 1./0 i/o-
    </p>
    <p>'\n'+V
    </p>
    <p>&#9633;
        все 4 операции деления вызовут
        ошибку деления на 0, сложение даст "\п\г"
    </p>
    <p>&#9633;
        результатом всех 4 операций
        деления будет POSITIVEJNnNITf,
        сложение даст '\п\г'
    </p>
    <p>&#9633;
        операция 1/0 приведет K/P^MeTM4^b^pos,T|VE INFINITY; следующие
        3 операции будут иметь результат РОЫ ivt_
    </p>
    <p>последнее сложение даст 23
    </p>
    <p>Вариант
        2
    </p>
    <p>Вариант
        3
    </p>
    <p>
    </p>
    <p>Сколько
        пробелов в следующем примере кода: intx = 3; int у=1; int z = х+у;
    </p>
    <p>&#9633;
        7
    </p>
    <p>&#9633;
        8
    </p>
    <p>&#9633;
        9
    </p>
    <p>&#9633;
        11
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.   Являются ли следующие слова ключевыми:
    </p>
    <p>&#9633;
        true
    </p>
    <p>&#9633;
        goto
    </p>
    <p>&#9633;
        null
    </p>
    <p>&#9633;
        const
    </p>
    <p>&#9633;
        false
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>Чему
        будет равно следующее выражение и значение переменной х после вычислений? int х=0;
    </p>
    <p>print(++x==x++);
    </p>
    <p>&#9633;
        true
    </p>
    <p>&#9633;
        false
    </p>
    <p>1.      Сколько комментариев в
        следующем примере кода:
        int х = О; /* text //
        text /*
    </p>
    <p>int у=1;
        // text */ // text */
    </p>
    <p>&#9633;         1
        блочный, 0 строчных
        П        1
        блочный, 1 строчный
        Г~1    1 блочный, 2 строчных
        П        2
        блочных, 3 строчных
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.      Равны
        ли следующие числа:
    </p>
    <p>&#9633;
        5 и 05
    </p>
    <p>&#9633;
        9 и 09
    </p>
    <p>&#9633;
        ЮиОЮ
        •&#9633;   0x5Am90L
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.      Чему будет равно следующее
        выражение и значения
        переменных х и у после вычислений?
    </p>
    <p>int х=0,
        у=0;
    </p>
    <p>print((++x==1) || (у++==1));
    </p>
    <p>&#9633;
        true
    </p>
    <p>&#9633;
        false
    </p>
    <p>
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <center><h2>Лекция 3.
        Лексика
        языка</h2></center>
    <p>
    </p>
    <p>
    </p>
    <p>Лекция посвящена описанию
        лексики языка Java.
    </p>
    <p>Лексика описывает, из чего состоит текст программы,
        каким образом он записывается и на какие простейшие слова (лексемы) компилятор
        разбивает программу при анализе. Лексемы (или tokens в английском
        варианте) - это основные "кирпичики", из которых строится любая
        программа на языке Java.
    </p>
    <p>Эта тема раскрывает многие детали внутреннего
        устройства языка, и невозможно написать ни одной строчки кода, не затронув ее.
        Именно поэтому курс начинается с основ лексического анализа.
    </p>
    <p>
    </p>
    <p>Ключевые слова: ASCII, Unicode, carriage return, linefeed, пробел, javadoc, идентификаторы,
        underscore, литералы.
    </p>
    <p>
    </p>
    <p>Кодировка
    </p>
    <p>Технология Java, как платформа, изначально спроектированная для Глобальной сети Internet,
        должна быть
        многоязыковой, а значит, обыч­ный набор символов ASCII (American Standard Code for
        Information Interchange, Американский стандартный код обмена информацией), включающий в себя
        лишь латинский алфавит, цифры и простейшие спе­циальные знаки (скобки, знаки
        препинания, арифметические операции и т.д.), недостаточен. Поэтому для записи
        текста программы применяется более универсальная кодировка Unicode.
    </p>
    <p>Как известно, Unicode представляет
        символы кодом из 2 байт, опи­сывая, таким образом, 65535 символов. Это
        позволяет поддерживать практически все распространенные языки мира. Первые 128
        символов совпадают с набором ASCII. Однако понятно, что требуется некоторое специальное
        обозначение, чтобы
        иметь возможность задавать в програм­ме любой символ Unicode, ведь никакая
        клавиатура не позволяет вводить более 65 тысяч различных знаков. Эта
        конструкция представляет символ Unicode, используя только символы ASCII. Например, если в
        программу нужно вставить знак с кодом 6917, необходимо его представить в
        шест-надцатеричном формате (1В05) и записать:
    </p>
    <p>
    </p>
    <p>\u1B05,
    </p>
    <p>причем буква и
        должна быть прописной, а шестнадцатеричные циф-РЬ1
        А, В, С, D, Е, F можно использовать произвольно, как заглавные, Так и
        строчные. Таким образом можно закодировать все символы
    </p>
    <p>Unicode от \u0000 до \uFFFF. Буквы русского алфавита начинаются с \u0410 (только буква Ё
        имеет код \u0401) по \u044F (код буквы ё \u0451). В последних версиях JDK в состав
        демонстрационных при­ложений и апплетов входит небольшая программа SymbolTest, позво­ляющая
        просматривать весь набор символов Unicode
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Ее аналог не­сложно
        написать самостоятельно. Для перекодирования больших текстов служит утилита native2ascii,
        также входящая в JDK. Она мо­жет
        работать как в прямом режиме — переводить из разнообразных кодировок в Unicode, записанный
        ASCII-символами, так и в
        обрат­ном (опция -reverse) — из Unicode в стандартную
        кодировку опера­ционной системы.
    </p>
    <p>В версиях языка Java до 1.1 применялся Unicode версии 1.1.5, в по­следнем выпуске 1.4
        используется 3.0. Таким образом, Java следит за раз­витием стандарта и базируется на
        современных версиях. Для
        любой JDK точную версию Unicode, используемую в
        ней, можно узнать из докумен­тации к классу Character. Официальный web-сайт стандарта, где
        можно получить дополнительную
        информацию,— http://www.Linicocle.org/.
    </p>
    <p>Итак, используя простейшую кодировку ASCII, можно ввести
        произ­вольную последовательность символов Unicode. Далее будет
        показано, что Unicode используется не для
        всех лексем, а только для тех, для которых важна поддержка многих языков, а
        именно: комментарии, идентификато­ры, символьные и строковые литералы. Для
        записи остальных лексем вполне достаточно ASCII-символов.
    </p>
    <p>
    </p>
    <p>Анализ программы
    </p>
    <p>Компилятор, анализируя
        программу, сразу разделяет ее на:
    </p>
    <p>•
        пробелы (white spaces);
    </p>
    <p>•
        комментарии (comments);
    </p>
    <p>•
        основные лексемы (tokens).
    </p>
    <p>
    </p>
    <p>Пробелы
    </p>
    <p>Пробелами в данном случае называют все символы, разбивающие текст
        программы на лексемы. Это как сам символ пробела (space, \u0020, десятичный код 32), так и
        знаки табуляции и перевода строки. Они ис­пользуются
        для разделения лексем, а также для оформления кода, чтобы его было легче
        читать. Например, следующую часть программы (вычисле­ние корней квадратного
        уравнения):
    </p>
    <p>
    </p>
    <p>double а = 1, b = 1, с = 6; double D = b * b - 4 * а * с;
    </p>
    <p>if (D &gt;=0) {
    </p>
    <p>double х1 = (-b + Math.sqrt (D)) / (2 * а); double х2 - (-b - Math.sqrt
        (D)) / (2 * а);
    </p>
    <p>}
    </p>
    <p>можно записать и в таком виде:
    </p>
    <p>
    </p>
    <p>double
        a=1,b=1,c=6;double D=b*b-4*a*c;if(D&gt;=0) {double
    </p>
    <p>x1
        =(-b+Math.sqrt(D))/(2*a);double x2=(-b-Math.sqrt(D))/(2*a);}
    </p>
    <p>В обоих случаях компилятор сгенерирует абсолютно одинаковый код.
        Единственное соображение, которым должен руководствоваться разработчик,—
        легкость чтения и дальнейшей поддержки такого кода.
    </p>
    <p>Для разбиения текста на строки в ASCII используется два символа -"возврат каретки" (carriage
        return, CR, \u000d, десятичный код 13) и сим­вол новой строки (linefeed, LF, \u000a,
        десятичный код 10)
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Чтобы не за­висеть от особенностей используемой
        платформы, в Java применяется на­иболее
        гибкий подход. Завершением строки считается:
    </p>
    <p>•
        ASCII-символ LF, символ новой строки;
    </p>
    <p>•
        ASCII-символ CR, "возврат каретки";
    </p>
    <p>•
        символ CR, за которым сразу же следует символ LF. Разбиение на строки важно для корректного
        разбиения на лексемы
    </p>
    <p>(как уже говорилось, завершение строки также служит
        разделителем меж­ду лексемами), для правильной работы со строковыми
        комментариями (см. следующую тему "Комментарии"), а также для вывода
        отладочной информации (при выводе ошибок компиляции и времени исполнения
        указывается, на какой строке исходного кода они возникли). Итак, пробелами в Java считаются:
    </p>
    <p>•  ASCII-символ SP, space, пробел, \u0020, десятичный код 32;
    </p>
    <p>•
        ASCII-символ НТ, horizontal tab, символ горизонтальной табу­ляции, \u0009, десятичный код 9;
    </p>
    <p>•
        ASCII-символ FF, form feed, символ перевода
        страницы (был вве­ден для работы с принтером), \u000c, десятичный код 12;
    </p>
    <p>•
        завершение строки.
    </p>
    <p>
    </p>
    <p>Комментарии
    </p>
    <p>Комментарии не влияют на
        результирующий бинарный код и ис­пользуются только для ввода пояснений к
        программе. В Java комментарии бывают двух видов:
    </p>
    <p>•
        строчные
    </p>
    <p>•
        блочные
    </p>
    <p>Курс
    </p>
    <p>Программирование
        на Java
    </p>
    <p>Лексика
        языка
    </p>
    <p>
    </p>
    <p>Строчные комментарии начинаются с ASCII-символов // и
        длятся до конца текущей строки. Как правило, они используются для пояснения
        именно этой строки, например:
    </p>
    <p>int у=1970; // год рождения
    </p>
    <p>Блочные комментарии располагаются между ASCII-символами /* и */,
        могут занимать произвольное количество строк, например:
    </p>
    <p>
    </p>
    <p>/*
    </p>
    <p>Этот цикл не может начинаться с нуля из-за особенностей алгоритма
    </p>
    <p>7
    </p>
    <p>for (int i=1; К10; i++) { }
    </p>
    <p>Часто блочные комментарии оформляют следующим образом (каж­дая строка
        начинается с *):
    </p>
    <p>
    </p>
    <p>Г
    </p>
    <p>*
        Описание алгоритма работы
    </p>
    <p>*
        следующего цикла while
    </p>
    <p>7
    </p>
    <p>while (х &gt; 0) { }
    </p>
    <p>Блочный комментарий не обязательно должен располагаться на не­скольких
        строках, он может даже находиться в середине оператора:
    </p>
    <p>
    </p>
    <p>float s = 2*Math.PI/*getRadius()7; // Закомментировано для отладки
    </p>
    <p>В этом примере блочный комментарий разбивает арифметические операции.
        Выражение Math.PI предоставляет значение константы PI, опре­деленное в
        классе Math. Вызов метода getRadius()
        теперь закомментирован и
        не будет произведен, переменная s всегда будет принимать значение 2 PI. Завершает строку
        строчный комментарий.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Комментарии не могут находиться в символьных и строковых лите­ралах,
        идентификаторах (эти понятия подробно рассматриваются далее в этой лекции).
        Следующий пример содержит случаи неправильного при­менения комментариев:
    </p>
    <p>// В этом примере текст
        /*...*/ станет просто частью строки s
    </p>
    <p>String s = "text/*just
        text7";
    </p>
    <p>/*
    </p>
    <p>*
        Следующая строка станет
        причиной ошибки при компиляции,
    </p>
    <p>*
        так как комментарий разбил
        имя метода getRadius()
    </p>
    <p>7
    </p>
    <p>circle.
        get/*comment7Radius(); А такой код допустим:
    </p>
    <p>// Комментарий может
        разделять вызовы функций: cirle./*commerrt7getRadius();
    </p>
    <p>// Комментарий может
        заменять пробелы: int/*comment7x=1 ;
    </p>
    <p>В последней строке
        между названием типа данных int и названием йеременной х обязательно должен быть пробел или,
        как в
        данном примере, комментарий.
    </p>
    <p>Комментарии не могут быть вложенными. Символы /*, */. // не име­ют
        никакого особенного значения внутри уже открытых комментариев, как строчных, так и
        блочных. Таким образом, в примере
    </p>
    <p>
    </p>
    <p>/* начало комментария /* ///** завершение тут: */
    </p>
    <p>
    </p>
    <p>описан только один блочный комментарий. А в следующем примере (строки
        кода пронумерованы для удобства)
    </p>
    <p>
    </p>
    <p>1.   г
    </p>
    <p>2.          comment
    </p>
    <p>4.
        more comments
    </p>
    <p>5.
        7
    </p>
    <p>6.
        finish
    </p>
    <p>7.   7
    </p>
    <p>
    </p>
    <p>компилятор выдаст
        ошибку. Блочный комментарий начался в строке 1 с комбинации символов /*. Вторая открывающая
        комбинация /* на строке 3 будет проигнорирована, так как находится уже внутри комментария.
        Символы
        7 в строке 5 завершат его, а строка 7 породит ошибку — попыт­ка закрыть комментарий, который
        не был начат.
    </p>
    <p>Любые комментарии полностью удаляются из программы во время компиляции,
        поэтому их можно использовать неограниченно, не опаса-
    </p>
    <p>87
    </p>
    <p>ясь, что это повлияет на бинарный код. Основное их
        предназначение -сделать программу простой для понимания, в том числе и для
        других раз­работчиков, которым придется в ней разбираться по какой-либо причи­не.
        Также комментарии зачастую используются для временного исключе­ния частей кода,
        например:
    </p>
    <p>intx = 2; int у = 0;
    </p>
    <p>/*
    </p>
    <p>if (х &gt; 0)
    </p>
    <p>у = у + х*2; else
    </p>
    <p>у = -у - х*4;
    </p>
    <p>7
    </p>
    <p>У = У*У;// + 2*х;
    </p>
    <p>В этом примере закомментировано выражение if-else и оператор сложения +2*х.
    </p>
    <p>Как уже говорилось выше, комментарии можно писать символами Unicode, то есть на любом
        языке, удобном разработчику.
    </p>
    <p>Кроме этого, существует особый вид блочного комментария -комментарий
        разработчика
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Он применяется для автоматического со­здания документации кода. В
        стандартную поставку JDK, начиная с версии 1.0, входит специальная утилита javadoc. На вход
        ей
        подается исходный код классов, а на выходе получается удобная документация в HTML-формате,
        которая
        описывает все классы, все их поля и методы. При этом активно используются
        гиперссылки, что существенно упро­щает изучение программы (например, читая
        описание метода, можно с помощью одного нажатия мыши перейти на описание типов,
        использу­емых в качестве аргументов или возвращаемого значения). Однако по­нятно,
        что одного названия метода и перечисления его аргументов не­достаточно для
        понимания его работы. Необходимы дополнительные пояснения от разработчика.
    </p>
    <p>Комментарий разработчика записывается так же, как и блочный.
        Единственное различие в начальной комбинации символов — для доку­ментации
        комментарий необходимо начинать с /**. Например:
    </p>
    <p>*
        Вычисление модуля целого
        числа.
    </p>
    <p>*
        Этот метод возвращает
    </p>
    <p>*
        абсолютное значение
        аргумента х.
    </p>
    <p>7
    </p>
    <p>int getAbs(intx) { if (х&gt;=0)
    </p>
    <p>return х; else
    </p>
    <p>return -x;
    </p>
    <p>}
    </p>
    <p>Первое предложение должно содержать краткое резюме всего комментария. В
        дальнейшем оно будет использовано как пояснение этой функции в списке всех
        методов класса (ниже будут описаны все конструкции языка, для которых
        применяется комментарий разра­ботчика).
    </p>
    <p>Поскольку в результате создается HTML-документация, то и
        ком­ментарий необходимо писать по правилам HTML. Допускается
        примене­ние тегов, таких как &lt;Ь&gt; и &lt;р&gt; . Однако теги заголовков с &lt;h1 &gt; по
        &lt;h6&gt; и &lt;hr&gt; использовать
        нельзя, так как они активно применяются javadoc для создания структуры документации.
    </p>
    <p>Символ * в начале каждой строки и предшествующие ему пробелы и знаки
        табуляции игнорируются. Их можно не использовать вообще, но они удобны, когда
        необходимо форматирование, скажем, в примерах кода.
    </p>
    <p>
    </p>
    <p>j-k-k
    </p>
    <p>*
        Первое предложение -
        краткое описание метода.
    </p>
    <p>*
        &lt;р&gt;
    </p>
    <p>*
        Так оформляется пример
        кода:
    </p>
    <p>*
        &lt;blockquote&gt;
    </p>
    <p>*
        &lt;рге&gt;
    </p>
    <p>*
        if
        (condition==true) {
    </p>
    <p>x = getWidht(); у =
        x.getHeight();
    </p>
    <p>* }
    </p>
    <p>*
        &lt;/pre&gt;&lt;/blockquote&gt;
    </p>
    <p>*
        Атак описывается HTML-список:
    </p>
    <p>*
        &lt;ul&gt;
    </p>
    <p>*
        &lt;П&gt;Можно
        использовать наклонный шрифт &lt;i&gt;KypcnB&lt;/i&gt;,
    </p>
    <p>*
        &lt;Н&gt;или жирный
        &lt;Ь&gt;жирный&lt;/Ь&gt;.
    </p>
    <p>*
        &lt;/ul&gt; 7
    </p>
    <p>public void
        calculate (int x, int y) { }
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Из этого комментария будет сгенерирован HTML-код, выглядящий
        примерно так:
    </p>
    <p>
    </p>
    <p>Первое предложение -
        краткое описание метода.
    </p>
    <p>
    </p>
    <p>Так оформляется пример
        кода:
    </p>
    <p>if (condition==true) { x = gerWidht(); у = x.getHeight();
    </p>
    <p>}
    </p>
    <p>А так описывается HTML-список:
    </p>
    <p>•
        Можно использовать
        наклонный шрифт курсив,
    </p>
    <p>•
        или жирный жирный.
    </p>
    <p>Наконец, javadoc поддерживает
        специальные теги. Они начинаются с символа @. Подробное описание этих тегов
        можно найти в документа­ции. Например, можно использовать тег @see, чтобы сослаться
        на другой класс, поле или метод, или даже на другой Internet-сайт.
    </p>
    <p>*
        Краткое описание.
    </p>
    <p>*
        Развернутый комментарий.
    </p>
    <p>*
    </p>
    <p>*
        @see java.lang.String
    </p>
    <p>*
        @see java.lang.Math#PI
    </p>
    <p>* @see &lt;a href="java.sun.com"&gt;Official
        Java site&lt;/a&gt;
    </p>
    <p>7
    </p>
    <p>Первая ссылка указывает на класс String Qava.lang - название биб­лиотеки, в которой находится
        этот класс), вторая - на
        поле PI класса Math (символ # разделяет название класса и его полей или методов), тре­тья
        ссылается на официальный сайт Java.
    </p>
    <p>Комментарии
        разработчика могут быть записаны перед объявлением классов, интерфейсов, полей,
        методов и конструкторов. Если записать комментарий /**...*/ в другой части
        кода, то ошибки не будет, но он не по­падет в документацию, генерируемую javadoc. Кроме
        того, можно
        описать пакет (так называются библиотеки, или модули, в Java). Для этого необхо­димо
        создать специальный файл package.html, сохранить в нем коммента­рий и поместить его в
        каталог пакета. HTML-текст,
        содержащийся между тегами &lt;body&gt; и &lt;/body&gt;, будет помещен в документацию, а
        первое пред­ложение будет
        использоваться для краткой характеристики этого пакета.
    </p>
    <p>Все классы стандартных библиотек Java поставляются в виде исход­ного текста и можно увидеть,
        как хорошо они
        комментированы. Стан­дартная документация по этим классам сгенерирована
        утилитой javadoc. Для любой программы также можно подготовить подобное описание, не­обходимы
        лишь грамотные и аккуратные комментарии в исходном коде. Кроме того, Java предоставляет
        возможность генерировать с помощью javadoc документацию с нестандартным внешним видом.
    </p>
    <p>
    </p>
    <p>Лексемы
    </p>
    <p>Итак, мы рассмотрели пробелы (в широком смысле этого слова, т.е. все
        символы, отвечающие за форматирование текста программы) и ком­ментарии,
        применяемые для ввода пояснений к коду. С точки зрения программиста они
        применяются для того, чтобы сделать программу более читаемой и понятной для
        дальнейшего развития.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>С точки зрения компилятора, а точнее его части, отвечающей за лек­сический
        разбор, основная роль пробелов и комментариев — служить раз­делителями между
        лексемами, причем сами разделители далее отбрасыва­ются и на компилированный
        код не влияют. Например, все следующие примеры объявления переменной
        эквивалентны:
    </p>
    <p>
    </p>
    <p>// Используем пробел в
        качестве разделителя, int х = 3 ;
    </p>
    <p>
    </p>
    <p>// здесь разделителем
        является перевод строки int
    </p>
    <p>x
    </p>
    <p>
    </p>
    <p>3
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>// здесь разделяем знаком
        табуляции int х = 3 ;
    </p>
    <p>
    </p>
    <p>/*
    </p>
    <p>* Единственный принципиально необходимый разделитель
    </p>
    <p>* между названием типа данных int и именем переменной
        х
    </p>
    <p>*
        здесь описан комментарием
        блочного типа.
    </p>
    <p>7
    </p>
    <p>int/**/x=3;
    </p>
    <p>Конечно, лексемы очень разнообразными именно они определяют многие
        свойства языка. Рассмотрим все их виды более подробно.
    </p>
    <p>
    </p>
    <p>Виды лексем
    </p>
    <p>Ниже перечислены все виды
        лексем в Java:
    </p>
    <p>•
        идентификаторы (identifiers);
    </p>
    <p>•
        ключевые слова (key words);
    </p>
    <p>•
        литералы (literals);
    </p>
    <p>•
        разделители (separators);
    </p>
    <p>•
        операторы (operators). Рассмотрим их по отдельности.
    </p>
    <p>
    </p>
    <p>Идентификаторы
    </p>
    <p>Идентификаторы - это имена, которые даются различным элементам языка для
        упрощения доступа к ним. Имена имеют пакеты, классы, ин­терфейсы, поля, методы,
        аргументы и локальные переменные (все эти по­нятия подробно рассматриваются в
        следующих лекциях). Идентификато­ры можно записывать символами Unicode, то есть на любом
        удобном язы­ке. Длина имени не ограничена.
    </p>
    <p>Идентификатор состоит из букв и цифр. Имя не может начинаться с цифры. Java-буквы,
        используемые в идентификаторах, включают в себя ASCII-символы A-Z (\u0041-\u005a), a-z
        (\u0061-\u007a), а также знаки подчеркивания _ (ASCII underscore, \u005f) и доллара $
        (\u0024). Знак дол­лара используется только при автоматической генерации кода
        (чтобы ис­ключить случайное совпадение имен), либо при использовании каких-ли­бо
        старых библиотек, в которых допускались имена с этим символом. Java-цифры включают в
        себя обычные ASCII-цифры 0-9 (\u0030-\u0039).
    </p>
    <p>Для идентификаторов не допускаются совпадения с зарезервирован­ными
        словами (это ключевые слова, булевские литералы true и false и null-литерал null). Конечно,
        если 2 идентификатора включают в себя разные буквы, которые
        одинаково выглядят (например, латинская и русская буквы А), то они считаются
        различными.
    </p>
    <p>В этой лекции уже
        применялись следующие идентификаторы:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Character, а, Ь, с, D, х1, х2, Math, sqrt, х, у, i, s, PI, getRadius,
    </p>
    <p>circle, getAbs, calculate, condition, getWidth, getHeight, java,
    </p>
    <p>lang, String
    </p>
    <p>Также допустимыми являются идентификаторы: Компьютер, COLOR_RED, _, aVeryLongNameOfTheMethod
    </p>
    <p>Ключевые
        слова
    </p>
    <p>Ключевые слова — это зарезервированные слова, состоящие из А8СП-символов
        и выполняющие различные задачи языка. Вот их полный список (48 слов):
    </p>
    <p>
    </p>
    <table border="0" cellpadding="0" cellspacing="0" class="MsoNormalTable">
        <tr>
            <td valign="top" width="69">
                <p>abstract
                </p>
            </td>
            <td valign="top" width="81">
                <p>default
                </p>
            </td>
            <td valign="top" width="98">
                <p>if
                </p>
            </td>
            <td valign="top" width="95">
                <p>private
                </p>
            </td>
            <td valign="top" width="61">
                <p>this
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>boolean
                </p>
            </td>
            <td valign="top" width="81">
                <p>do
                </p>
            </td>
            <td valign="top" width="98">
                <p>implements
                </p>
            </td>
            <td valign="top" width="95">
                <p>protected
                </p>
            </td>
            <td valign="top" width="61">
                <p>throw
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>break
                </p>
            </td>
            <td valign="top" width="81">
                <p>double
                </p>
            </td>
            <td valign="top" width="98">
                <p>import
                </p>
            </td>
            <td valign="top" width="95">
                <p>public
                </p>
            </td>
            <td valign="top" width="61">
                <p>throws
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>byte
                </p>
            </td>
            <td valign="top" width="81">
                <p>else
                </p>
            </td>
            <td valign="top" width="98">
                <p>instanceof
                </p>
            </td>
            <td valign="top" width="95">
                <p>return
                </p>
            </td>
            <td valign="top" width="61">
                <p>transient
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>case
                </p>
            </td>
            <td valign="top" width="81">
                <p>extends
                </p>
            </td>
            <td valign="top" width="98">
                <p>int
                </p>
            </td>
            <td valign="top" width="95">
                <p>short
                </p>
            </td>
            <td valign="top" width="61">
                <p>try
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>catch
                </p>
            </td>
            <td valign="top" width="81">
                <p>final
                </p>
            </td>
            <td valign="top" width="98">
                <p>interface
                </p>
            </td>
            <td valign="top" width="95">
                <p>static
                </p>
            </td>
            <td valign="top" width="61">
                <p>void
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>char
                </p>
            </td>
            <td valign="top" width="81">
                <p>finally
                </p>
            </td>
            <td valign="top" width="98">
                <p>long
                </p>
            </td>
            <td valign="top" width="95">
                <p>strictfp
                </p>
            </td>
            <td valign="top" width="61">
                <p>volatile
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>class
                </p>
            </td>
            <td valign="top" width="81">
                <p>float
                </p>
            </td>
            <td valign="top" width="98">
                <p>native
                </p>
            </td>
            <td valign="top" width="95">
                <p>super
                </p>
            </td>
            <td valign="top" width="61">
                <p>while
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>const
                </p>
            </td>
            <td valign="top" width="81">
                <p>for
                </p>
            </td>
            <td valign="top" width="98">
                <p>new
                </p>
            </td>
            <td valign="top" width="95">
                <p>switch
                </p>
            </td>
            <td valign="top" width="61">
                <p>
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="69">
                <p>continue
                </p>
            </td>
            <td valign="top" width="81">
                <p>goto
                </p>
            </td>
            <td valign="top" width="98">
                <p>package
                </p>
            </td>
            <td valign="top" width="95">
                <p>synchronized
                </p>
            </td>
            <td valign="top" width="61">
                <p>
                </p>
            </td>
        </tr>
    </table>
    <p>Ключевые слова goto и const зарезервированы, но не используются. Это сделано для того, чтобы
        компилятор мог правильно отреагировать на их использование в других языках. Напротив, оба
        булевских литерала true, false и null-литерал null часто считают ключевыми
        словами (возмож­но, потому, что многие средства разработки подсвечивают их
        таким же образом), однако это именно литералы.
    </p>
    <p>Значение всех ключевых слов будет рассматриваться в следующих лекциях.
    </p>
    <p>
    </p>
    <p>Литералы
    </p>
    <p>Литералы позволяют задать в программе значения для числовых, символьных
        и строковых выражений, а также null-литералов. Всего в Java определены следующие виды
        литералов:
    </p>
    <p>•
        целочисленный (integer);
    </p>
    <p>•
        дробный (floating-point);
    </p>
    <p>•
        булевский (boolean);
    </p>
    <p>•
        символьный (character);
    </p>
    <p>•
        строковый (string);
    </p>
    <p>•
        null-литерал (null-literal). Рассмотрим их по отдельности.
    </p>
    <p>Целочисленные литералы
    </p>
    <p>Целочисленные литералы позволяют задавать целочисленные зна­чения в
        десятеричном, восьмеричном и шестнадцатеричном виде. Деся­теричный формат
        традиционен и ничем не отличается от правил, приня­тых в других языках.
        Значения в восьмеричном виде начинаются с нуля, и, конечно, использование цифр
        8 и 9 запрещено. Запись шестнадцате-ричных чисел начинается с Ох или ОХ (цифра
        0 и латинская ASCII-буква X в произвольном регистре). Таким образом, ноль можно записать
        тремя различными способами:
    </p>
    <p>
    </p>
    <p>О
    </p>
    <p>00 0x0
    </p>
    <p>Как обычно, для записи цифр 10-15 в шестнадцатеричном формате
        используются буквы А, В, С, D, Е, F, заглавные или
        прописные. Примеры таких литералов:
    </p>
    <p>
    </p>
    <p>OxaBcDeF, OxCafe, OxDEC
    </p>
    <p>
    </p>
    <p>Типы данных рассматриваются ниже, однако здесь необходимо упомянуть два
        целочисленных типа int и long длиной 4 и 8 байт, соответственно (или 32 и 64 бита,
        соответственно).
        Оба эти типа знаковые, т.е. тип int хранит значения от -231 до 23,-1, или от
        -2.147.483.648 до 2.147.483.647. По умолчанию целочисленный литерал имеет тип int, а значит,
        в
        программе допустимо использовать литералы только от 0 до 2147483648, иначе
        возникнет ошибка компиляции
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> При этом литерал 2147483648 можно использовать
        только как аргумент унарного оператора -:
    </p>
    <p>
    </p>
    <p>int х = -2147483648; \\верно
    </p>
    <p>int у = 5-2147483648; \\
        здесь возникнет ошибка компиляции
    </p>
    <p>
    </p>
    <p>Соответственно, допустимые литералы в восьмеричной записи долж­ны быть
        от 00 до 017777777777 (=231-1), с унарным оператором - допусти­мо
        также -020000000000 (= -231). Аналогично для шестнадцатеричного
        формата - от 0x0 до 0x7fffffff (=23,-1), а также -0x80000000 (= -231).
    </p>
    <p>Тип long имеет длину 64 бита, а значит, позволяет хранить значения от -263
        до 263-1. Чтобы ввести такой литерал, необходимо в конце поста­вить
        латинскую букву L или I, тогда все значение будет трактоваться как long. Аналогично можно
        выписать
        максимальные допустимые значения для них:
    </p>
    <p>9223372036854775807L
    </p>
    <p>0777777777777777777777L
    </p>
    <p>0x7fffffffffffffffL
    </p>
    <p>//
        наибольшие отрицательные значения: -9223372036854775808L -01000000000000000000000L
        -0x8000000000000000L
    </p>
    <p>Другие примеры целочисленных литералов типа long: 0L, 1231, OxCOBOL
    </p>
    <p>
    </p>
    <p>Дробные литералы
    </p>
    <p>Дробные литералы представляют собой числа с плавающей десятич­ной
        точкой. Правила записи таких чисел такие же, как и в большинстве современных
        языков программирования.
    </p>
    <p>Примеры:
    </p>
    <p>
    </p>
    <p>3.14 2.
    </p>
    <p>.5
    </p>
    <p>7е10 3.1Е-20
    </p>
    <p>Таким образом, дробный литерал состоит из следующих составных частей:
    </p>
    <p>•
        целая часть;
    </p>
    <p>•
        десятичная точка
        (используется ASCII-символ точка);
    </p>
    <p>•
        дробная часть;
    </p>
    <p>•
        показатель степени
        (состоит из латинской ASCII-буквы Е в про­извольном регистре и целого числа с опциональным
        знаком +
        или -);
    </p>
    <p>•
        окончание-указатель типа.
    </p>
    <p>Целая и дробная части записываются десятичными цифрами, а ука­затель
        типа (аналог указателя L или I для
        целочисленных литералов типа long)
    </p>
    <p>имеет два возможных значения - латинская ASCII-буква D (для ти­па double) или F (для типа
        float) в произвольном
        регистре. Они будут по­дробно рассмотрены ниже.
    </p>
    <p>Необходимыми частями
        являются:
    </p>
    <p>•
        хотя бы одна цифра в целой
        или дробной части;
    </p>
    <p>•
        десятичная точка или
        показатель степени, или указатель типа.
    </p>
    <p>Все остальные части необязательные. Таким образом,
        "минимальные" дробные литералы могут быть записаны, например, так:
    </p>
    <p>1. .1
    </p>
    <p>1е1 1f
    </p>
    <p>В Java есть два дробных
        типа, упомянутые выше, - float и double. Их длина - 4 и 8 байт или 32 и 64 бита,
        соответственно. Дробный литерал
        имеет тип float, если он заканчивается на латинскую букву F в произволь­ном регистре
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> В противном случае он рассматривается как
        значение типа double и может включать в себя
        окончание D или d, как признак типа double (используется только для наглядности).
    </p>
    <p>
    </p>
    <p>//float-литералы:
    </p>
    <p>1f, 3.14F, Of, 1e+5F
    </p>
    <p>// double-литералы:
    </p>
    <p>0., 3.14d, 1e-4, 31.34E45D
    </p>
    <p>В Java дробные числа 32-битного типа float и 64-битного типа dou­ble хранятся в памяти в
        бинарном виде в формате, стандартизированном спецификацией IEEE
        754 (полное название — IEEE Standard for Binary Floating-Point Arithmetic,
        ANSI/IEEE Standard 754-1985 (IEEE, New York)). В этой спецификации описаны не только
        конечные дробные вели­чины, но и
        еще несколько особых значений, а именно:
    </p>
    <p>• положительная и отрицательная бесконечности (positive/negative infinity);
    </p>
    <p>• значение "не число", Not-a-Number, сокращенно NaN;
    </p>
    <p>• положительный и отрицательный нули.
    </p>
    <p>Для этих значений нет специальных обозначений. Чтобы получить та­кие
        величины, необходимо либо произвести арифметическую операцию (на­пример,
        результатом деления ноль на ноль 0.0/0.0 является NaN), либо обра­титься
        к константам в классах Float и Double, а именно POSIT1VEJNFINITY, NEGATIVEJNFINITY и NaN.
        Более подробно ра­бота
        с этими особенными значениями рассматривается в следующей лекции.
    </p>
    <p>Типы данных накладывают
        ограничения на возможные значения ли­тералов, как и для целочисленных типов.
        Максимальное положительное конечное значение дробного литерала:
    </p>
    <p>• для float: 3.40282347e+38f
    </p>
    <p>• для double: 1.79769313486231570е+308
    </p>
    <p>Кроме того, для дробных величин становится важным еще одно Предельное значение — минимальное
        положительное ненулевое значение:
    </p>
    <p>•
        для float: 1.40239846e-45f
    </p>
    <p>•
        для double: 4.94065645841246544e-324
    </p>
    <p>Попытка указать литерал со слишком большим абсолютным значе­нием
        (например, 1 e40F) приведет к ошибке компиляции. Такая величина должна представляться
        бесконечностью. Аналогично, указание литерала со слишком малым ненулевым
        значением (например, 1е-350) также при­водит к ошибке. Это значение должно быть округлено до
        нуля.
        Однако ес­ли округление приводит не к нулю, то компилятор произведет его сам:
    </p>
    <p>//
        ошибка, выражение должно быть округлено до О
    </p>
    <p>0.0000000000000000000000000000000000000000000001f
    </p>
    <p>//
        ошибки нет, компилятор сам округляет до 1
    </p>
    <p>1.0000000000000000000000000000000000000000000001f
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>' Стандартных
        возможностей вводить дробные значения не в десятич­ной системе в Java нет, однако классы
        Float и Double предоставляют много вспомогательных методов, в том числе и для такой
        задачи.
    </p>
    <p>
    </p>
    <p>Логические литералы
    </p>
    <p>Логические литералы имеют два возможных значения — true и false. Эти
        два зарезервированных
        слова не являются ключевыми, но также не могут использоваться в качестве
        идентификатора.
    </p>
    <p>
    </p>
    <p>Символьные литералы
    </p>
    <p>Символьные литералы описывают один символ из набора Unicode, заключенный в
        одиночные кавычки, или апострофы (ASCII-символ sin­gly quote, \u0027). Например:
    </p>
    <p>'а'
        // латинская буква а '' // пробел
    </p>
    <p>'К'
        // греческая буква каппа
    </p>
    <p>
    </p>
    <p>Также допускается специальная запись для описания символа через его код (см. тему
        "Кодировка"). Примеры:
    </p>
    <p>'\u0041' //
        латинская буква А '\u0410' // русская буква А '\u0391' // греческая буква А
    </p>
    <p>Символьный литерал должен содержать строго один символ, или специальную
        последовательность, начинающуюся с \. Для записи специ­альных символов
        (неотображаемых и служебных, таких как ",', \) исполь­зуются следующие
        обозначения:
    </p>
    <p>
    </p>
    <p>\Ь \u0008  backspace BS - забой
    </p>
    <p>\х \u0009 horizontal tab НТ- табуляция
    </p>
    <p>\п \u000a  linefeed LF - конец строки
    </p>
    <p>\f \u000c form feed FF - конец страницы
    </p>
    <p>\r \u000d
        carriage return CR - возврат каретки
    </p>
    <p>\" \u0022 
        double quote " - двойная кавычка
    </p>
    <p>V \u0027
        single quote ' - одинарная кавычка
    </p>
    <p>\\ \u005c  backslash \ - обратная косая черта
    </p>
    <p>\восьмеричный код
    </p>
    <p>от \u0000 до \u00ff символа в
        восьмеричном формате.
    </p>
    <p>
    </p>
    <p>Первая колонка описывает стандартные обозначения специальных символов,
        используемые в Java-программах. Вторая колонка представляет их в стандартном виде
        Unicode-символов. Третья
        колонка содержит анг­лийские и русские описания. Использование \ в комбинации с
        другими символами приведет к ошибке компиляции.
    </p>
    <p>Поддержка ввода символов через восьмеричный код обеспечивается для
        совместимости с С. Например:
    </p>
    <p>
    </p>
    <p>'\101 ' // Эквивалентно '\u0041 '
    </p>
    <p>
    </p>
    <p>Однако таким образом можно задать лишь символы от \u0000 до \u00ff (т.е. с кодом от 0
        до 255), поэтому Unicode-последовательности предпочтительней.
    </p>
    <p>Поскольку обработка Unicode-последовательностей (\uhhhh) произво­дится раньше лексического
        анализа, то следующий пример
        является ошибкой:
    </p>
    <p>
    </p>
    <p>'\u000a' // символ конца
        строки
    </p>
    <p>
    </p>
    <p>Компилятор сначала преобразует \u000a в символ конца
        строки и кавычки окажутся на разных строках кода, что является ошибкой. Необ­ходимо
        использовать специальную последовательность:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>'\п' // правильное
        обозначение конца строки
    </p>
    <p>
    </p>
    <p>Аналогично и для символа \u000d (возврат каретки)
        необходимо ис­пользовать обозначение \г.
    </p>
    <p>Специальные символы можно использовать в составе как символь­ных, так и
        строковых литералов.
    </p>
    <p>
    </p>
    <p>Строковые литералы
    </p>
    <p>Строковые литералы состоят из набора символов и записываются в двойных
        кавычках. Длина может быть нулевой или сколь угодно боль­шой. Любой символ может быть
        представлен специальной последова­тельностью,
        начинающейся с \ (см. "Символьные литералы").
    </p>
    <p>""
        // литерал нулевой длины
    </p>
    <p>"\""
        //литерал, состоящий из одного символа "
    </p>
    <p>"Простой
        текст" //литерал длины 13
    </p>
    <p>Строковый литерал нельзя разбивать на несколько строк в коде про­граммы.
        Если требуется текстовое значение, состоящее из нескольких строк, то необходимо
        воспользоваться специальными символами \п и/или \г. Если же текст просто
        слишком длинный, чтобы уместиться на одной строке кода, можно использовать
        оператор конкатенации строк +. Примеры строковых литералов:
    </p>
    <p>//
        выражение-константа, составленное из двух литералов "Длинный текст "
        + "с переносом" /*
    </p>
    <p>*
        Строковый литерал, содержащий текст из
        двух строк:
    </p>
    <p>*
        Hello, world!
    </p>
    <p>*
        Hello!
    </p>
    <p>7
    </p>
    <p>"Hello,
        world!\r\nHello!"
    </p>
    <p>На строковые литералы распространяются те же правила, что и на сим­вольные
        в отношении использования символов новой строки \u000a и \u000d.
    </p>
    <p>Каждый строковый литерал является экземпляром класса String. Это определяет
        некоторые необычные свойства строковых литералов, ко­торые будут рассмотрены в
        следующей лекции.
    </p>
    <p>
    </p>
    <p>Null-литерал
    </p>
    <p>Null-литерал может
        принимать всего одно значение: null. Это литерал ссылочного типа, причем эта ссылка никуда
        не ссылается,
        объект отсутст-вУет. Разумеется, его можно применять к ссылкам
        любого объектного типа Д^ных. Типы данных подробно рассматриваются в следующей
        лекции.
    </p>
    <p>Разделители
    </p>
    <p>Разделители - это специальные символы, которые используются в служебных
        целях языка. Назначение каждого из них будет рассмотрено по ходу изложения
        курса. Вот их полный список:
    </p>
    <p>
    </p>
    <p>()[]{};&#9632;,
    </p>
    <p>
    </p>
    <p>Операторы
    </p>
    <p>Операторы используются в различных операциях — арифметичес­ких,
        логических, битовых, операциях сравнения и присваивания. Следу­ющие 37 лексем
        (все состоят только из ASCII-символов) являются опера­торами языка Java:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <table border="0" cellpadding="0" cellspacing="0" class="MsoNormalTable">
        <tr>
            <td valign="top" width="21">
                <p>-
                </p>
            </td>
            <td valign="top" width="28">
                <p>&gt;
                </p>
            </td>
            <td valign="top" width="36">
                <p>&lt;
                </p>
            </td>
            <td valign="top" width="36">
                <p>і
                </p>
            </td>
            <td valign="top" width="75">
                <p>?
                </p>
            </td>
            <td valign="top" width="43">
                <p>
                </p>
            </td>
            <td valign="top" width="39">
                <p>
                </p>
            </td>
            <td valign="top" width="40">
                <p>
                </p>
            </td>
            <td valign="top" width="75">
                <p>
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="21">
                <p>- -
                </p>
            </td>
            <td valign="top" width="28">
                <p>&lt;-
                </p>
            </td>
            <td valign="top" width="36">
                <p>&gt;=
                </p>
            </td>
            <td valign="top" width="36">
                <p>!=
                </p>
            </td>
            <td valign="top" width="75">
                <p>&amp;&amp;   &#161;1
                </p>
            </td>
            <td valign="top" width="43">
                <p>++
                </p>
            </td>
            <td valign="top" width="39">
                <p>--
                </p>
            </td>
            <td valign="top" width="40">
                <p>
                </p>
            </td>
            <td valign="top" width="75">
                <p>
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="21">
                <p>+
                </p>
            </td>
            <td valign="top" width="28">
                <p>-
                </p>
            </td>
            <td valign="top" width="36">
                <p>*
                </p>
            </td>
            <td valign="top" width="36">
                <p>/
                </p>
            </td>
            <td valign="top" width="75">
                <p>&amp;   1
                </p>
            </td>
            <td valign="top" width="43">
                <p>Л
                </p>
            </td>
            <td valign="top" width="39">
                <p>%
                </p>
            </td>
            <td valign="top" width="40">
                <p>«
                </p>
            </td>
            <td valign="top" width="75">
                <p>»     »&gt;
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="21">
                <p>+=
                </p>
            </td>
            <td valign="top" width="28">
                <p>-=
                </p>
            </td>
            <td valign="top" width="36">
                <p>
                </p>
            </td>
            <td valign="top" width="36">
                <p>/=
                </p>
            </td>
            <td valign="top" width="75">
                <p>&amp;= 1=
                </p>
            </td>
            <td width="43">
                <p>Л____
                </p>
            </td>
            <td valign="top" width="39">
                <p>%=
                </p>
            </td>
            <td valign="top" width="40">
                <p>«=
                </p>
            </td>
            <td valign="top" width="75">
                <p>»=   »=
                </p>
            </td>
        </tr>
    </table>
    <p>Большинство из них вполне очевидны и хорошо известны из других языков
        программирования, однако некоторые нюансы в работе с опера­торами в Java все же
        присутствуют, поэтому в конце лекции приводятся краткие комментарии к ним.
    </p>
    <p>
    </p>
    <p>Пример
        программы
    </p>
    <p>В заключение для примера приведем простейшую программу (тра­диционное Hello, world!), а затем
        классифицируем и подсчитаем исполь­зуемые лексемы:
    </p>
    <p>
    </p>
    <p>public class Demo {
    </p>
    <p>J-k-k
    </p>
    <p>*
        Основной метод, с которого начинается
        выполнение
    </p>
    <p>*
        любой Java программы.
    </p>
    <p>7
    </p>
    <p>public static void main (String
        args[]) { System.out.printlnf'Hello, world!");
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Итак, в приведенной программе есть один комментарий разработчи­ка, 7
        идентификаторов, 5 ключевых слов, 1 строковый литерал, 13 разде­лителей и ни
        одного оператора. Этот текст можно сохранить в файле Demo.java, скомпилировать й
        запустить (работа с JDK и стандартными
        утилитами была рассмотрена в первой лекции). Результатом работы будет, как
        очевидно:
    </p>
    <p>
    </p>
    <p>Hello, world!
    </p>
    <p>
    </p>
    <p>Дополнение. Работа с
        операторами
    </p>
    <p>Рассмотрим некоторые детали использования операторов в Java. Здесь будут описаны
        подробности, относящиеся к работе самих операто­ров. В следующей лекции
        детально рассматриваются особенности, возни­кающие при использовании различных
        типов данных (например, значе-йие операции 1 /2 равно 0, а 1/2. равно 0.5).
    </p>
    <p>
    </p>
    <p>Операторы присваивания и сравнения
    </p>
    <p>Во-первых, конечно же, различаются оператор присваивания = и оператор
        сравнения ==.
    </p>
    <p>
    </p>
    <p>х = 1 ; // присваиваем переменной х значение 1
    </p>
    <p>х == 1 // сравниваем значение переменной х с единицей
    </p>
    <p>
    </p>
    <p>Оператор сравнения всегда возвращает булевское значение trae или false. Оператор
        присваивания возвращает значение правого операнда. Поэтому обычная опечатка в
        языке С, когда эти операторы путают:
    </p>
    <p>
    </p>
    <p>//
        пример вызовет ошибку компилятора
    </p>
    <p>if (х=0) {// здесь должен применятся оператор
        сравнения ==
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>в Java легко устраняется.
        Поскольку выражение х=0 имеет числовое зна­чение 0, а не булевское (и тем более
        не воспринимается как всегда истин­ное), то компилятор сообщает об ошибке
        (необходимо писать х==0). Условие "не равно" записывается как !=.
        Например:
    </p>
    <p>
    </p>
    <p>if (х!=0) {
    </p>
    <p>float f = 1./х;
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Сочетание какого-либо оператора с оператором присваивания = • нижнюю
        строку в полном перечне в разделе "Операторы") использу­ется при
        изменении значения переменной. Например, следующие две строки эквивалентны:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>х = х + 1; х+= 1;
    </p>
    <p>
    </p>
    <p>Арифметические операции
    </p>
    <p>Наряду с четырьмя обычными арифметическими операциями +,-,*, /,
        существует оператор получения остатка от деления %, который может быть применен
        как к целочисленным аргументам, так и к дробным.
    </p>
    <p>Работа с целочисленными аргументами подчиняется простым пра­вилам. Если
        делится значение а на значение Ь, то выражение (а/Ь)*Ь+(а%Ь) должно в точности
        равняться а. Здесь, конечно, оператор деления целых чисел / всегда возвращает
        целое число. Например:
    </p>
    <p>9/5 возвращает 1 9/(-5) возвращает -1 (-9)/5 возвращает -1 (-9)/(-5) возвращает 1
    </p>
    <p>
    </p>
    <p>Остаток может быть положительным, только если делимое было по­ложительным.
        Соответственно, остаток может быть отрицательным только в случае отрицательного
        делимого.
    </p>
    <p>
    </p>
    <p>9%5 возвращает 4 9%(-5) возвращает 4 (-9)%5 возвращает -4 (-9)%(-5)
        возвращает -4
    </p>
    <p>
    </p>
    <p>Попытка получить остаток от деления на 0 приводит к ошибке.
    </p>
    <p>Деление с остатком для дробных чисел может быть произведено по двум
        различным алгоритмам. Один из них повторяет правила для целых чисел, и именно
        он представлен оператором %. Если в рассмотренном примере деления 9 на 5
        перейти к дробным числам, значение остатка во всех вариантах не изменится (оно
        будет также дробным, конечно).
    </p>
    <p>9.0%5.0 возвращает 4.0 9.0%(-5.0) возвращает 4.0 (-9.0)%5.0 возвращает
        -4.0 (-9.0)%(-5.0) возвращает -4.0
    </p>
    <p>Однако стандарт IEEE 754 определяет
        другие правила. Такой способ представлен методом стандартного класса
        Math.lEEEremainder(double f 1, double f2). Результат этого
        метода - значение, которое равно f 1 -f2*n, где п — целое число, ближайшее к значению f
        1/f2, а если два целых
        числа одинаково близки к этому отношению, то выбирается четное. По этому
        правилу значение остатка будет другим:
    </p>
    <p>Math.lEEEremainder(9.0, 5.0) возвращает -1.0 Math.lEEEremainder(9.0, -5.0) возвращает -1.0
        Math.lEEEremainder(-9.0, 5.0) возвращает 1.0 Math.lEEEremainder(-9.0, -5.0) возвращает 1.0
    </p>
    <p>Унарные операторы инкрементации ++ и декрементации --, как обычно, можно
        использовать как справа, так и слева.
    </p>
    <p>int х=1; int у=++х;
    </p>
    <p>В этом примере оператор ++ стоит перед переменной х, это означает, что
        сначала произойдет инкрементация, а затем значение х будет исполь­зовано для
        инициализации у. В результате после выполнения этих строк значения х и у будут равны 2.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>int х=1; int у=х++;
    </p>
    <p>А в этом примере сначала значение х будет использовано для инициализации
        у, и лишь затем
        произойдет инкрементация. В результате значение х будет равно 2, а у будет равно 1.
    </p>
    <p>
    </p>
    <p>Логические операторы
    </p>
    <p>Логические операторы "и" и "или" (&amp; и |) можно
        использовать в двух вариантах. Это связано с тем, что, как легко убедиться, для
        каждого опера­тора возможны случаи, когда значение первого операнда сразу
        определяет значение всего логического выражения. Если вторым операндом является
        значение некоторой функции, то появляется выбор - вызывать ее или нет, причем
        это решение может сказаться как на скорости, так и на функцио­нальности
        программы.
    </p>
    <p>Первый вариант операторов (&amp;, |) всегда вычисляет оба операнда,
        второй же - ( &amp;&amp;, 11 ) не будет продолжать вычисления, если значение выражения уже
        очевидно.
        Например:
    </p>
    <p>
    </p>
    <p>int х=1;
    </p>
    <p>(х&gt;0) | calculate(x) // в таком выражении произойдет вызов calulate (х&gt;0) 11
        calculate(x) // а в этом - нет
    </p>
    <p>
    </p>
    <p>Логический оператор отрицания "не" записывается как ! и,
        конечно, имеет только один вариант использования. Этот оператор меняет булев­ское
        значение на противоположное.
    </p>
    <p>
    </p>
    <p>int х=1;
    </p>
    <p>х&gt;0 // выражение
        истинно !(х&gt;0) // выражение ложно
    </p>
    <p>
    </p>
    <p>Оператор с условием ? : состоит из трех частей - условия и двух выра­жений.
        Сначала вычисляется условие (булевское выражение), а на основа­нии результата
        значение всего оператора определяется первым выражени­ем в случае получения
        истины и вторым - если условие ложно. Например, так можно вычислить модуль
        числа х:
    </p>
    <p>
    </p>
    <p>х&gt;0 ? х : -х
    </p>
    <p>
    </p>
    <p>Битовые операции
    </p>
    <p>Прежде чем переходить к битовым операциям, необходимо уточнить, каким
        именно образом целые числа представляются в двоичном виде. Ко­нечно, для
        неотрицательных величин это практически очевидно:
    </p>
    <p>0
        О
    </p>
    <p>1
        1
    </p>
    <p>2
        10
    </p>
    <p>3
        11
    </p>
    <p>4
        100
    </p>
    <p>5
        101
    </p>
    <p>
    </p>
    <p>и так далее. Однако как представляются отрицательные числа? Во-пер­вых,
        вводят понятие знакового бита. Первый бит начинает отвечать за знак, а именно 0
        означает положительное число, 1 — отрицательное. Но не следует думать, что
        остальные биты остаются неизменными. Напри­мер, если рассмотреть 8-битовое
        представление:
    </p>
    <p>-1 10000001 //это
        НЕВЕРНО! -2 10000010//это НЕВЕРНО! -3 10000011 //это НЕВЕРНО!
    </p>
    <p>Такой подход неверен! В частности, мы получаем сразу два представления дудя - 00000000 и
        100000000, что нерационально. Правильный алгоритм можно
        представить себе так. Чтобы получить значение -1, надо из 0 вычесть 1: 00000000
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>-00000001
    </p>
    <p>
    </p>
    <p>-11111111
    </p>
    <p>Итак, -1 в двоичном виде представляется как 11111111. Продолжаем
        применять тот же алгоритм (вычитаем 1):
    </p>
    <p>0 00000000 -1 11111111 -2 11111110 -3 11111101
    </p>
    <p>и так далее до
        значения 10000000, которое представляет собой наибольшее по модулю
        отрицательное число. Для 8-битового представления наиболь­шее положительное число
        01111111 (=127), а наименьшее отрицательное 10000000 (=-128). Поскольку всего 8
        бит определяет 28=256 значений, причем одно из них отводится для
        нуля, то становится ясно, почему наи­большие по модулю положительные й
        отрицательные значения различа­ются на единицу, а не совпадают.
    </p>
    <p>Как известно, битовые операции "и", "или",
        "исключающее или" принимают два аргумента и выполняют логическое
        действие попарно над соответствующими битами аргументов. При этом используются
        те же обозначения, что и для логических операторов, но, конечно, только в
        первом (одиночном) варианте. Например, вычислим выражение 5&amp;6:
    </p>
    <p>
    </p>
    <p>00000101    // число 5 в двоичном виде &amp;00000110    //число 6 в двоичном виде
    </p>
    <p>00000100    //проделали
        операцию "и" попарно над битами // в каждой позиции
    </p>
    <p>
    </p>
    <p>То есть выражение 5&amp;6
        равно 4.
    </p>
    <p>Исключение составляет лишь оператор "не" или "NOT", который для
        побитовых операций записывается как ~ (для логических было !). Этот оператор
        меняет каждый бит в числе на противоположный. Например,
    </p>
    <p>)=0. Можно легко установить общее правило для получения битового
        представления отрицательных чисел:
    </p>
    <p>Если п - целое положительное число, то -п в битовом представлении Равняется ~(п-1).
    </p>
    <p>Наконец, осталось
        рассмотреть лишь операторы побитового сдвига. В Java есть один оператор сдвига влево и два
        варианта сдвига вправо. Такое
        различие связано с наличием знакового бита.
    </p>
    <p>При сдвиге влево оператором &lt;&lt; все биты числа смещаются на ука­занное
        количество позиций влево, причем освободившиеся справа пози­ции заполняются
        нулями. Эта операция аналогична умножению на 2п и действует вполне
        предсказуемо, как при положительных, так и при отри­цательных аргументах.
    </p>
    <p>Рассмотрим примеры применения операторов сдвига для значений типа int, т.е. 32-битных
        чисел. Пусть положительным аргументом будет число 20, а отрицательным -21.
    </p>
    <p>
    </p>
    <p>// Сдвиг
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>влево для
        положительного числа 20 20 « 00 =
        00000000000000000000000000010100 = 20 20 « 01 =00000000000000000000000000101000
        = 40 20 « 02 = 00000000000000000000000001010000 = 80 20 «03 =
        00000000000000000000000010100000
        = 160 20 « 04 = 00000000000000000000000101000000 = 320
    </p>
    <p>
    </p>
    <p>20 « 25 =
        00101000000000000000000000000000 = 671088640
    </p>
    <p>20 « 26 =
        01010000000000000000000000000000 = 1342177280
    </p>
    <p>20 « 27 = 10100000000000000000000000000000 =
        -1610612736
    </p>
    <p>20 « 28 =
        01000000000000000000000000000000 = 1073741824
    </p>
    <p>20 « 29 = 10000000000000000000000000000000 = -2147483648
    </p>
    <p>20 « 30 =
        00000000000000000000000000000000 = о
    </p>
    <p>20 « 31
        =00000000000000000000000000000000 = о
    </p>
    <p>//
        Сдвиг влево для отрицательного числа -21
    </p>
    <p>-21 «00=
        11111111111111111111111111101011 =-21
    </p>
    <p>-21 «01 =
        11111111111111111111111111010110 = -42
    </p>
    <p>-21 «02 =
        11111111111111111111111110101100 =-84
    </p>
    <p>-21 « 03=11111111111111111111111101011000=-168
    </p>
    <p>-21 &lt;^ 04 = 11111111111111111111111010110000 = -336
    </p>
    <p>-21 «
        05=11111111111111111111110101100000=-672
    </p>
    <p>-21 « 25 =
        11010110000000000000000000000000 = -704643072 -21 « 26 =
        10101100000000000000000000000000 = -1409286144 -21 « 27 =
        01011000000000000000000000000000 = 1476395008 -21 « 28 =
        10110000000000000000000000000000 = -1342177280 -21 « 29 =
        01100000000000000000000000000000 =1610612736 -21 « 30 =
        11000000000000000000000000000000 .= -1073741824 -21 « 31 = 10000000000000000000000000000000
        = -2147483648
    </p>
    <p>Как видно из примера, неожиданности возникают тогда, когда $начащие биты
        начинают занимать первую позицию и влиять на знак результата.
    </p>
    <p>При сдвиге вправо все биты аргумента смещаются на указанное коли­чество
        позиций, соответственно, вправо. Однако встает вопрос — каким значением
        заполнять освобождающиеся позиции слева, в том числе и отве­чающую за знак.
        Есть два варианта. Оператор » использует для заполне­ния этих позиций значение
        знакового бита, то есть результат всегда имеет тот же знак, что и начальное
        значение. Второй оператор »&gt; заполняет их нулями, то есть результат всегда
        положительный.
    </p>
    <p>// Сдвиг вправо для положительного числа 20 // Оператор »
    </p>
    <p>20 » 00 = 00000000000000000000000000010100 = 20 20 » 01 =
        00000000000000000000000000001010 = 10 20 » 02 =
        00000000000000000000000000000101 =5 20 » 03 = 00000000000000000000000000000010
        = 2 20 » 04 = 00000000000000000000000000000001 = 1 20 » 05 =
        00000000000000000000000000000000 = о // Оператор »&gt;
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>20 »&gt; 00 = 00000000000000000000000000010100 = 20 20 »&gt; 01 =
        00000000000000000000000000001010 = 10 20 »&gt; 02 =
        00000000000000000000000000000101 = 5 20 »&gt; 03 =
        00000000000000000000000000000010 = 2 20 »&gt; 04 =
        00000000000000000000000000000001 = 1 20 »&gt; 05 = 00000000000000000000000000000000
        = о
    </p>
    <p>Очевидно, что для положительного аргумента операторы &gt;&gt; и
        &gt;&gt;&gt; Работают совершенно одинаково. Дальнейший сдвиг на большее количе­ство позиций
        будет также давать нулевой результат.
    </p>
    <p>// Сдвиг вправо для отрицательного числа -21 // Оператор &gt;&gt;
    </p>
    <p>-21 » 00 =11111111111111111111111111101011= -21 -21 »01 =
        11111111111111111111111111110101 =-11 -21 »02 =
        11111111111111111111111111111010 = -6 -21 » 03
        =11111111111111111111111111111101 =-3 -21 »04 =
        11111111111111111111111111111110 = -2 -21 »05 = 11111111111111111111111111111111
        =-1 // Оператор »&gt;
    </p>
    <p>-21 »&gt; 00 =
        11111111111111111111111111101011 = -21
    </p>
    <p>-21 &gt;» 01
        =01111111111111111111111111110101 =2147483637
    </p>
    <p>
    </p>
    <table border="0" cellpadding="0" cellspacing="0" class="MsoNormalTable">
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td colspan="2" valign="top" width="50">
                <p>&gt;» 02:
                </p>
            </td>
            <td valign="top" width="261">
                <p>=00111111111111111111111111111010=
                </p>
            </td>
            <td valign="top" width="81">
                <p>1073741818
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>03
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00011111111111111111111111111101 :
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 536870909
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>04
                </p>
            </td>
            <td valign="top" width="261">
                <p>=00001111111111111111111111111110=
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 268435454
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>05
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000111111111111111111111111111 =
                </p>
            </td>
            <td valign="top" width="81">
                <p>=134217727
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>24
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000000000000000000000011111111
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 255
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>25
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000000000000000000000001111111
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 127
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>26
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000000000000000000000000111111
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 63
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>27
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000000000000000000000000011111
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 31
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>28
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000000000000000000000000001111
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 15
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>29
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000000000000000000000000000111
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 7
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>&gt;»
                </p>
            </td>
            <td valign="top" width="20">
                <p>30
                </p>
            </td>
            <td valign="top" width="261">
                <p>=00000000000000000000000000000011
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 3
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="23">
                <p>-21
                </p>
            </td>
            <td valign="top" width="30">
                <p>»&gt;
                </p>
            </td>
            <td valign="top" width="20">
                <p>31
                </p>
            </td>
            <td valign="top" width="261">
                <p>= 00000000000000000000000000000001
                </p>
            </td>
            <td valign="top" width="81">
                <p>= 1
                </p>
            </td>
        </tr>
    </table>
    <p>Как видно из примеров, эти операции аналогичны делению на 2п. При­чем,
        если для положительных аргументов с ростом п результат закономерно стремится к
        0, то для отрицательных предельным значением является -1.
    </p>
    <p>
    </p>
    <p>Заключение
    </p>
    <p>В этой лекции были рассмотрены основы лексического анализа про­грамм Java. Для их записи
        применяется универсальная кодировка ишсос1е,позволяющая использовать любой язык
        помимо традиционного английского. Еще раз напомним, что использование Unicode возможно и
        необходимо в следующих конструкциях:
    </p>
    <p>•
        комментарии;
    </p>
    <p>•
        идентификаторы;
    </p>
    <p>•
        символьные и строковые
        литералы.
    </p>
    <p>Остальные же (пробелы, ключевые слова, числовые,
        булевские и null-ли-тералы, разделители и операторы) легко записываются с применением
        лишь ASCII-символов. В то же время любой Unicode-символ также мож­но
        задать в виде специальной последовательности ASCII-символов.
    </p>
    <p>Во время анализа компилятор выделяет из текста программы
        &lt;про-белы&gt; (были рассмотрены все символы, которые рассматриваются как
        пробелы) и комментарии,которые полностью удаляются из кода (были рассмотрены
        все виды комментариев, в частности комментарий разра­ботчика). Пробелы и все
        виды комментариев служат для разбиения текс­та программы на лексемы. Были
        рассмотрены все виды лексем,в том чис­ле все виды литералов.
    </p>
    <p>В дополнении были рассмотрены особенности применения различ­ных
        операторов.
    </p>
    <p>Вариант 1
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>Как записать в Java-программе символ с кодом 514?
    </p>
    <p>&#9633;
        '514'
    </p>
    <p>&#9633;
        \u0546
    </p>
    <p>&#9633;
        \u222
    </p>
    <p>&#9633;
        \u0222
    </p>
    <p>
    </p>
    <p>Какие
        из перечисленных идентификаторов являются корректными?
    </p>
    <p>&#9633;
        abc
    </p>
    <p>&#9633;
        lab
    </p>
    <p>&#9633;
        _bc
    </p>
    <p>&#9633;
        _1с$ас
    </p>
    <p>&#9633;
        $ас
    </p>
    <p>&#9633;
        for_
    </p>
    <p>&#9633;
        Int
    </p>
    <p>&#9633;
        byte
    </p>
    <p>
    </p>
    <p>Каким будет результат следующих
        действий?
    </p>
    <p>1/0 1./0 i/o-
    </p>
    <p>'\n'+V
    </p>
    <p>&#9633;
        все 4 операции деления вызовут
        ошибку деления на 0, сложение даст "\п\г"
    </p>
    <p>&#9633;
        результатом всех 4 операций
        деления будет POSITIVEJNnNITf,
        сложение даст '\п\г'
    </p>
    <p>&#9633;
        операция 1/0 приведет K/P^MeTM4^b^pos,T|VE INFINITY; следующие
        3 операции будут иметь результат РОЫ ivt_
    </p>
    <p>последнее сложение даст 23
    </p>
    <p>Вариант
        2
    </p>
    <p>Вариант
        3
    </p>
    <p>
    </p>
    <p>Сколько
        пробелов в следующем примере кода: intx = 3; int у=1; int z = х+у;
    </p>
    <p>&#9633;
        7
    </p>
    <p>&#9633;
        8
    </p>
    <p>&#9633;
        9
    </p>
    <p>&#9633;
        11
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.   Являются ли следующие слова ключевыми:
    </p>
    <p>&#9633;
        true
    </p>
    <p>&#9633;
        goto
    </p>
    <p>&#9633;
        null
    </p>
    <p>&#9633;
        const
    </p>
    <p>&#9633;
        false
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>Чему
        будет равно следующее выражение и значение переменной х после вычислений? int х=0;
    </p>
    <p>print(++x==x++);
    </p>
    <p>&#9633;
        true
    </p>
    <p>&#9633;
        false
    </p>
    <p>1.      Сколько комментариев в
        следующем примере кода:
        int х = О; /* text //
        text /*
    </p>
    <p>int у=1;
        // text */ // text */
    </p>
    <p>&#9633;         1
        блочный, 0 строчных
        П        1
        блочный, 1 строчный
        Г~1    1 блочный, 2 строчных
        П        2
        блочных, 3 строчных
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.      Равны
        ли следующие числа:
    </p>
    <p>&#9633;
        5 и 05
    </p>
    <p>&#9633;
        9 и 09
    </p>
    <p>&#9633;
        ЮиОЮ
        •&#9633;   0x5Am90L
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.      Чему будет равно следующее
        выражение и значения
        переменных х и у после вычислений?
    </p>
    <p>int х=0,
        у=0;
    </p>
    <p>print((++x==1) || (у++==1));
    </p>
    <p>&#9633;
        true
    </p>
    <p>&#9633;
        false
    </p>
    <p>
    </p>
    <center>
    </center>
</div>

</body>
</html>
