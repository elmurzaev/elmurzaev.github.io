<!DOCTYPE html>
<html>
<head>

    <title>Лекция 10. Операторы и структура кода. Исключения</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<div class="left">
    <p></p>
    <p></p>
    <center><h2>Лекция
        10. Операторы и структура кода. Исключения</h2></center>
    <p>
    </p>
    <p>
    </p>
    <p>После ознакомления с типами данных в Java, правилами
        объявления ^пассов и интерфейсов, а также с массивами, из базовых свойств языка
        оста-доя рассмотреть лишь управление ходом выполнения программы. В этой лек-щд!
        вводятся важные понятия, связанные с данной темой, описываются мет­ки,
        операторы условного перехода, циклы, операторы break и continue и другие.
    </p>
    <p>Следующая тема посвящена более концептуальным
        механизмам Java, а именно работе с ошибками или исключительными
        ситуациями. Рассматрива­ются причины возникновения сбоев, способы их обработки,
        объявление соб­ственных типов исключительных ситуаций. Описывается разделение
        всех ошибок на проверяемые и непроверяемые компилятором, а также ошибки времени
        исполнения.
    </p>
    <p>
    </p>
    <p>Ключевые слова: метка, проверяемые исключения, непроверяемые исключения
    </p>
    <p>
    </p>
    <p>Управление ходом программы
    </p>
    <p>Управление потоком вычислений является фундаментальной осно­вой всего
        языка программирования. В данной лекции будут рассмотрены основные языковые
        конструкции и способы их применения.
    </p>
    <p>Синтаксис выражений весьма схож с синтаксисом языка С, что об­легчает
        его понимание для программистов, знакомых с этим языком, и вместе с тем имеется
        ряд отличий, которые будут рассмотрены позднее и на которые следует обратить
        внимание.
    </p>
    <p>Порядок выполнения программы определяется операторами. Опе­раторы могут
        содержать другие операторы или выражения.
    </p>
    <p>
    </p>
    <p>Нормальное
        и прерванное выполнение операторов
    </p>
    <p>Последовательность
        выполнения операторов может быть непрерыв­ки, а может и прерываться (при возникновении
        определенных условий). Ьпіолнение оператора может быть прервано, если в потоке вычислений
        ЭДУт обнаружены
        операторы
    </p>
    <p>
    </p>
    <p>break
    </p>
    <p>continue
    </p>
    <p>return
    </p>
    <p>Курс               ______________________________________________ Программирование
        Ha^i^
    </p>
    <p>Тогда управление будет передано в другое место (в соответствии правилами обработки этих
        операторов, которые мы рассмотрим поз*С|~
    </p>
    <p>Нормальное выполнение оператора может быть прервано также nPll возникновении
        исключительных ситуаций, которые тоже будут расемот
    </p>
    <p>реНЫ ПОЗДКее. ЯвНОе Возбуждение ИСКЛЮЧИТеЛЬНОЙ СИТуацИИ С ПОМОЩц
    </p>
    <p>оператора throw также прерывает нормальное выполнение оператора „ передает управление
        выполнением программы (далее просто управление, в другое место.
    </p>
    <p>Прерывание нормального исполнения всегда вызывается опреде. ленной причиной. Приведем список
        таких причин:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>•
        break (без указания метки);
    </p>
    <p>•
        break (с указанием метки);
    </p>
    <p>•
        continue (без указания метки);
    </p>
    <p>•
        continue (с указанием метки);
    </p>
    <p>•
        return (с возвратом значения);
    </p>
    <p>•
        return (без возврата значения;)
    </p>
    <p>•
        throw с указанием объекта
        Throwable, а также все исключения, вызываемые
        виртуальной машиной Java.
    </p>
    <p>Выражения могут завершаться нормально и преждевременно (ава­рийно). В данном случае термин
        "аварийно" вполне применим, т.к. при­чиной необычной последовательности выполнения выражения
        может быть только возникновение исключительной ситуации.
    </p>
    <p>Если в операторе содержится выражение, то в случае его аварийного завершения выполнение
        оператора тоже будет завершено преждевременно (т.е. нормальный ход выполнения оператора
        будет нарушен).
    </p>
    <p>В том случае, если в операторе имеется вложенный оператор и его завершение
        происходит ненормально, то так же ненормально завершает­ся оператор, содержащий вложенный (в
        некоторых случаях это не так. что будет оговариваться особо).
    </p>
    <p>Блоки и локальные переменные
    </p>
    <p>Блок — это последовательность операторов, объявлений локальных классов
        или локальных переменных, заключенных в скобки. Область ви­димости локальных
        переменных и классов ограничена блоком, в которое они определены.
    </p>
    <p>Операторы в блоке выполняются слева направо, сверху вниз. Если все операторы
        (выражения) в блоке выполняются нормально, то и весь блок выполняется
        нормально. Если какой-либо оператор (выражение' завершается ненормально, то и
        весь блок завершается ненормально.
    </p>
    <p>Нельзя объявлять несколько локальных переменных с одинаковым" именами
        в пределах видимости блока. Приведенный ниже код вызове1 ошибку
        времени компиляции.
    </p>
    <p>
    </p>
    <p>public class Test {
    </p>
    <p>public Test() { }
    </p>
    <p>public static void main(String[] args) { Test t = new
        Test() ; intx; 1Ы: {
    </p>
    <p>int x = 0;
    </p>
    <p>System, out. printlnfx = " + x);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>В то же время не следует забывать, что локальные переменные пере­крывают
        видимость переменных-членов. Так, следующий пример отрабо­тает нормально.
    </p>
    <p>public class Test { static int x = 5; public Test() {}
    </p>
    <p>public static void main(String[] args) { Test t = new
        Test() ; ntx = 1;
    </p>
    <p>System, out. printlnfx = " + x);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>На консоль будет выведено x = 1.
    </p>
    <p>To же самое правило применимо к параметрам методов.
    </p>
    <p>
    </p>
    <p>public class Test { static int x; public Test() { }
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>public static void main(String[] args) { Test t = new
        Test() ; t.test(5);
    </p>
    <p>System.out.printlnf'Member value x = " + x);
    </p>
    <p>}
    </p>
    <p>private void test(int x){ this.x = x + 5;
    </p>
    <p>Курс_______________________________________________________ Программирование
        Haja^
    </p>
    <p>System.out.println("Local value x = " + x);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>В результате работы этого примера на консоль будет выведено:
    </p>
    <p>Local value х = 5 Member
        value х = 10
    </p>
    <p>
    </p>
    <p>На следующем примере продемонстрируем, что область видимости локальной
        переменной ограничена областью видимости блока, или one-ратора, в пределах
        которого данная переменная объявлена.
    </p>
    <p>public class Test { static intx = 5; public
        Test() { }
    </p>
    <p>public static void main(String[] args) { Testt =
        newTest(); {
    </p>
    <p>int x = 1;
    </p>
    <p>System,
        out. printlnfFirst block x = " + x);
    </p>
    <p>} {
    </p>
    <p>intx = 2;
    </p>
    <p>System.out.printlnfSecond
        blockx =" + x);
    </p>
    <p>}
    </p>
    <p>System.out.print("For
        cycle x = "); for(intx=0;x&lt;5;x++) { System.out.print("" + x);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Данный пример откомпилируется без ошибок и на консоль буДеТ выведен
        следующий результат:
    </p>
    <p>First block х = 1 Second
        block х =2 For cycle x = 0 1 2 3 4
    </p>
    <p>^я -|0                                                             Операторы
        и структура кода. Исключения
    </p>
    <p>Следует помнить, что определение локальной переменной есть испол-мый
        оператор. Если задана инициализация переменой, то выражение сдолняется слева
        направо и его результат присваивается локальной пере-11 иной.
        Использование неинициализированных локальных переменных лрешено и вызывает
        ошибку компиляции. Следующий пример кода
    </p>
    <p>
    </p>
    <p>public class Test { static int x = 5; public
        Test() {
    </p>
    <p>}
    </p>
    <p>public static void main(String[] args) { Testt = new
        Test() ; intx; inty = 5; if( y &gt; 3) x = 1 ; System.out.println(x);
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>вызовет ошибку времени компиляции, т.к. возможны условия, при кото­рых
        переменная х может быть не инициализирована до ее использования (несмотря на
        то, что в данном случае оператор гї(у &gt; 3) и следующее
        за ним выражение х = 1; будут выполняться всегда).
    </p>
    <p>
    </p>
    <p>Пустой оператор
    </p>
    <p>Точка с запятой (;) является пустым оператором. Данная конструк­ция
        вполне применима там, где не предполагается выполнение никаких Действий.
        Преждевременное завершение пустого оператора невозможно.
    </p>
    <p>
    </p>
    <p>Метки
    </p>
    <p>Любой оператор, или блок, может иметь метку. Метку можно указы-^ть в
        качестве параметра для операторов break и continue. Область види­мости метки ограничивается
        оператором, или блоком, к
        которому она от­носится. Так, в следующем примере мы получим ошибку компиляции:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>Public class Test { static int x = 5; static { }
    </p>
    <p></p>
    <center><img align="left"
                 alt="Подпись: оправданно, но, конечно, их применение следует ограничивать лишь са-"
                 height="24" hspace="3" src="http://kufas.ru/java.files/image017.png" width="445">
    </center>
    public Test() { }
    <p>public static void main(String[] args) { Test t = newTest();
        int x = 1; Lbl1: {
    </p>
    <p>if(x ==0) break Lbl1;
    </p>
    <p>}
    </p>
    <p>Lbl2:{
    </p>
    <p>if(x &gt;0) break Lbl1;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>В случае, если имеется несколько вложенных блоков и операторов
        допускается обращение из внутренних блоков к меткам, относящимся к внешним.
    </p>
    <p>Этот пример является вполне корректным:
    </p>
    <p>public class Test { static int x = 5; static {
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>public Test() { }
    </p>
    <p>public static void main(String[] args) { Testt =
        newTest(); int L2 - 0;
    </p>
    <p>Test: for(int i = 0; i&lt; 10;i++) { test:
        for(int j = 0; j&lt; 10;j++) { if( i*j &gt; 50) break Test;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>private void test() { }
    </p>
    <p>}
    </p>
    <p>В этом же примере можно увидеть, что метки используют пространств0 имен,
        отличное от пространства имен переменных, методов и классов.
    </p>
    <p>Традиционно использование меток не рекомендуется, особенно в
        л^ктно-ориентированных языках, поскольку серьезно усложняет пони-порядка
        выполнения кода, а значит, и его тестирование и отладку, rfitil Java этот запРет можно
        считать не столь строгим, поскольку
        самый дзсньш оператор goto отсутствует. В
        некоторых ситуациях (как в рассмо­тренном примере с вложенными циклами)
        использование меток вполне
    </p>
    <p>ft0Oi необходимыми
        случаями.
    </p>
    <p>Оператор if
    </p>
    <p>Пожалуй, наиболее распространенной конструкцией в Java, как и в любом
        другом структурном языке программирования, является оператор условного перехода.
    </p>
    <p>В общем случае
        конструкция выглядит так:
    </p>
    <p>if (логическое
        выражение) выражение или блок 1 else выражение или блок 2
    </p>
    <p>Логическое выражение может быть любой языковой конструкцией, которая
        возвращает булевский результат. Отметим отличие от языка С, в котором в
        качестве логического выражения могут использоваться различные типы данных, где
        отличное от нуля выражение трактуется как истинное значение, а ноль - как
        ложное. В Java возможно
        использование только логических выражений.
    </p>
    <p>Если логическое выражение принимает значение "истина", то вы­полняется
        выражение или блок 1, в противном случае - выражение или блок 2. Вторая часть
        оператора (else) не является обязательной и может быть опущена. Т.е. конструкция if(х = 5)
        System.out.printlnf'Five") вполне
        допустима.
    </p>
    <p>Операторы if-else могут
        каскадироваться.
    </p>
    <p>
    </p>
    <p>String test = "smb";
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>if(
        test.equals("value1") {
    </p>
    <p>} else if
        (test.equals("value2") {
    </p>
    <p>} else if
        (test.equals("value3") {
    </p>
    <p>} else {
    </p>
    <p>Следует помнить, что оператор else относится к ближайшему к не\и оператору if. В данном
        случае
        последнее условие else будет выполняться
        только если не выполнено предыдущее. Заключительная конструкцИ(| else относится к самому
        последнему условию if и будет выполнена тольк0 в том случае, если ни одно из
        вышеперечисленных условий не б\'Дег истинным. Если хотя
        бы одно из условий выполнено, то все последующИе выполняться не
        будут.
    </p>
    <p>Например:
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>int x
        =
        5; if( x
        &lt;
        4) {
    </p>
    <p>System.out.println("MeHbLue 4"); } else if (x &gt; 4) {
    </p>
    <p>System.out.ргіпіІп("Больше 4"); }else if (x ==
        5){
    </p>
    <p>System.out.printlnf'PaBHo 4"); } else{
    </p>
    <p>System.out.printlnf'flpyroe значение");
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Предложение "Равно 4" в данном случае напечатано не будет.
    </p>
    <p>
    </p>
    <p>Оператор switch
    </p>
    <p>Оператор switch() удобно использовать в случае необходимости множественного выбора.
        Выбор осуществляется на основе целочислен­ного значения.
    </p>
    <p>Структура оператора:
    </p>
    <p>switch(int value) { case consti :
    </p>
    <p>выражение или блок case
        const2:
    </p>
    <p>выражение или блок case
        constn:
    </p>
    <p>выражение или блок default:
    </p>
    <p>выражение или блок
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Причем, фраза default не является
        обязательной.
    </p>
    <p>В качестве параметра switch может
        использоваться переменная типа byte, short, int, char или выражение. Выражение должно в
        конечном итоге возвращать параметр
        одного из указанных ранее типов. В операторе gase не могут
        применяться значения примитивного типа long и ссылоч­ных типов Long, String, Integer, Byte и
        т.д.
    </p>
    <p>При выполнении оператора switch производится
        последовательное сравнение значения х с константами, указанными после case, и в случае
        совпадения выполняется выражение следующего за этим условием. Если выражение
        выполнено нормально и нет преждевременного его заверше­ния, то производится
        сравнение для последующих case. Если же выраже­ние, следующее за case, завершилось
        ненормально, то будет прекращено выполнение всего оператора switch.
    </p>
    <p>Если не выполнен ни один оператор case, то выполнится
        оператор default, если он имеется в данном switch. Если оператора default нет и ни одно из
        условий case не выполнено, то ни
        одно из выражений switch так­же выполнено не
        будет.
    </p>
    <p>Следует обратить внимание, что, в отличие от многозвенного if-else, если
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>какое-либо
        условие case выполнено, то
        выполнение switch не прекра­тится, а
        будут проверяться следующие за ним условия. Если этого необходи­мо избежать, то
        после кода следующего за оператором case используется оператор break, прерывающий дальнейшее
        выполнение оператора switch.
    </p>
    <p>После оператора case должен следовать
        литерал, который может быть интерпретирован как 32-битовое целое значение.
        Здесь не могут применяться выражения и переменные, если они не являются final static.
    </p>
    <p>Рассмотрим пример:
    </p>
    <p>
    </p>
    <p>intx = 2; switch(x) {
    </p>
    <p>case 1 :
    </p>
    <p>case 2:
    </p>
    <p>System.out.printlnf'PaBHo 1 или 2");
    </p>
    <p>break; case 3: case 4:
    </p>
    <p>System.out.printlnf'PaBHo 3 или 4"); break;
        default:
    </p>
    <p>System.out.ргіпііп("3начение не определено");
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>»,    В данном случае на консоль будет выведен результат "Равно 1
        или 2". Же убрать операторы break, то будут выведены
        все три строки.
    </p>
    <p>Вот такая конструкция вызовет ошибку времени компиляции.
    </p>
    <p>intx = 5; switch (х) {
    </p>
    <p>case у: // только константы!
    </p>
    <p>
    </p>
    <p>break;
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>В операторе switch не может быть двух case с одинаковыми значе­ниями.
    </p>
    <p>Т.е. конструкция
    </p>
    <p>switch(x) { case 1:
    </p>
    <p>System,
        out. printlnfOne");
    </p>
    <p>break;
    </p>
    <p>case 1:
    </p>
    <p>System.out.println("Two");
    </p>
    <p>break;
    </p>
    <p>case 3:
    </p>
    <p>System.out.println("Tree or other value");
    </p>
    <p>}
    </p>
    <p>недопустима.
    </p>
    <p>Также в конструкции switch может быть применен
        только один оператор default.
    </p>
    <p>
    </p>
    <p>Управление циклами
    </p>
    <p>В языке Java имеется три
        основных конструкции управления циклами:
    </p>
    <p>•
        цикл while;
    </p>
    <p>•
        цикл do;
    </p>
    <p>•
        цикл for.
    </p>
    <p>
    </p>
    <p>Цикл
        while
    </p>
    <p>Основная форма цикла while может быть
        представлена так:
    </p>
    <p>
    </p>
    <p>while(norM4ecKoe выражение)
    </p>
    <p>повторяющееся выражение, или блок;
    </p>
    <p>В данной языковой конструкции повторяющееся выражение, или gjjoK будет исполняться до тех
        пор, пока логическое выражение будет ^fftb истинное значение. Этот многократно исполняемый
        блок называ­ет телом
        цикла
    </p>
    <p>Операторы continue и break могут изменять нормальное исполне-^5 тела цикла. Так, если в теле
        цикла
        встретился оператор continue, то оЯбраторы, следующие за ним, будут пропущены и
        выполнение цикла начнется сначала. Если continue используется с меткой и метка принадле-jgjr
        к данному while, то выполнение его будет аналогичным. Если метка не относится к данному
        while, его выполнение будет прекращено и управле­ние будет передано на
        оператор, или блок, к которому относится метка.
    </p>
    <p>Если встретился оператор break, то выполнение цикла будет прекра­щено.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Если выполнение блока было прекращено по какой-то другой причи­не (возникла
        исключительная ситуация), то выполнение всего цикла будет прекращено по той же
        причине.
    </p>
    <p>Рассмотрим несколько примеров:
    </p>
    <p>public class Test { static int x = 5; public
        Test() { }
    </p>
    <p>public static void main(String[] args) { Testt =
        newTest(); intx = 0; while(x&lt; 5) { x++;
    </p>
    <p>if(x % 2
        ==0) continue; System.out.printf " + x); }
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>На консоль будет выведено
    </p>
    <p>
    </p>
    <p>135
    </p>
    <p>т,е. вывод на печать всех четных чисел будет пропущен.
    </p>
    <p>
    </p>
    <p>Public class Test { static int x = 5; public Test() {
    </p>
    <p>
    </p>
    <table align="left" cellpadding="0" cellspacing="0">
        <tr>
            <td height="0" width="466"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <center><img alt="Подпись:  " height="28"
                             src="http://kufas.ru/java.files/image018.png" width="53"></center>
            </td>
        </tr>
    </table>
    <p>public static void main(String[] args) { Testt = new Test() ; intx
        = 0; inty = 0;
    </p>
    <p>Ibi: while(y &lt;
        3) {
    </p>
    <p>y++;
    </p>
    <p>while(x &lt;
        5) { x++;
    </p>
    <p>if(x%2==0)
        continue Ibi;
    </p>
    <p>System.
        out.println("x=" + x + " y="+y);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>На консоль будет выведено
    </p>
    <p>x=1 y=1 x=3 y=2 x=5 y=3
    </p>
    <p>т.е. при выполнении
        условия if(x % 2 == 0) continue Ibi; цикл по перемен­ной
        x будет прерван, а
        цикл по переменной у начнет новую итерацию. Типичный вариант использования выражения
        while():
    </p>
    <p>
    </p>
    <p>int i = 0;
    </p>
    <p>while( i++ &lt; 5) {
    </p>
    <p>System.out.printlnf'Counter is " + i);
    </p>
    <p>}
    </p>
    <p>Следует помнить, что цикл whileO будет выполнен
        только в том слу­чае, если на момент начала его выполнения логическое выражение
        будет истинным. Таким образом, при выполнении программы может иметь
        ме­сто ситуация, когда цикл while()
        не будет выполнен ни разу.
    </p>
    <p>boolean b = false;
        while(b) {
    </p>
    <p>System.out.println("Executed");
    </p>
    <p>}
    </p>
    <p>В данном случае строка System.out.printlnf'Executed");
        выполнен3 не будет.
    </p>
    <p>Цикл
        do
    </p>
    <p>Основная форма цикла do имеет следующий
        вид: do
    </p>
    <p>повторяющееся выражение
        или блок; while(norn4ecKoe выражение)
    </p>
    <p>Цикл do будет выполняться
        до тех пор, пока логическое выражение будет истинным. В отличие от цикла while, этот цикл
        будет
        выполнен, как минимум, один раз.
    </p>
    <p>Типичная конструкция цикла do:
    </p>
    <p>
    </p>
    <p>int counter = 0; do{
    </p>
    <p>counter ++;
    </p>
    <p>System.out.printlnf'Counter
        is " + counter); } while(counter &gt; 5);
    </p>
    <p>
    </p>
    <p>В остальном выполнение цикла do аналогично выполнению цикла while, включая
        использование операторов break и continue.
    </p>
    <p>
    </p>
    <p>Цикл
        for
    </p>
    <p>Довольно часто бывает необходимо изменять значение какой-либо П|ременной
        в заданном диапазоне и выполнять повторяющуюся последо-щгельность операторов с
        использованием этой переменной. Для выпол­нения такой последовательности
        действий как нельзя лучше подходит Конструкция цикла for.
    </p>
    <p>Основная форма цикла for выглядит следующим образом:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>^(выражение инициализации; условие; выражение обновления) повторяющееся
        выражение или блок;
    </p>
    <p>
    </p>
    <p>Ключевыми элементами данной языковой конструкции являются •Федложения,
        заключенные в круглые скобки и разделенные точкой с запятой.
    </p>
    <p>Выражение инициализации выполняется до начала выполнения тела 1*Икла.
        Чаще всего используется как некое стартовое условие (инициализа-^я» или
        объявление переменной).
    </p>
    <p>\ Условие должно
        быть логическим выражением и трактуется точно ^же, как логическое выражение в
        цикле while(). Тело цикла выполня­ли До тех пор, пока логическое выражение истинно. Как и в
        случае с
    </p>
    <p>циклом \л/Ы1е(), тело цикла может не исполниться ни разу. Это происхо.
        дит, если логическое выражение принимает значение "ложь" до начала
        выполнения цикла.
    </p>
    <p>Выражение обновления выполняется сразу после исполнения тела цикла
        и до того, как проверено условие продолжения выполнения цикла Обычно здесь
        используется выражение инкрементации, но может быть применено и любое другое
        выражение.
    </p>
    <p>Пример использования цикла тог()
    </p>
    <p>
    </p>
    <p>for(counter=0;counter&lt;
        10;counter++) {
    </p>
    <p>System.out.println("Counter
        is " + counter);
    </p>
    <p>}
    </p>
    <p>В данном примере предполагается, что переменная counter была объявлена ранее. Цикл будет
        выполнен 10 раз и будут напечатаны
        значе­ния счетчика от 0 до 9.
    </p>
    <p>Разрешается определять
        переменную прямо в предложении:
    </p>
    <p>for(int cnt = 0;cnt &lt; 10; cnt++) {
    </p>
    <p>System.out.printlnfCounter is " + cnt);
    </p>
    <p>}
    </p>
    <p>Результат выполнения этой конструкции будет аналогичен предыду­щему.
        Однако нужно обратить внимание, что область видимости пере­менной cnt будет ограничена телом
        цикла.
    </p>
    <p>Любая часть конструкции for() может быть опущена. В вырожден­ном случае мы получим оператор
        for с пустыми значениями
    </p>
    <p>for(;;){ }
    </p>
    <p>В данном случае цикл
        будет выполняться бесконечно. Эта конструк­ция аналогична конструкции while(true){}.
        Условия, в которых
        она может быть применена, мы рассмотрим позже.
    </p>
    <p>Возможно также расширенное использование синтаксиса оператора for(). Предложение и
        выражение могут состоять из нескольких частей, разделенных запятыми.
    </p>
    <p>for(i = 0,j = 0;i&lt;5;i++,j+=2){ }
    </p>
    <p>Использование такой
        конструкции вполне правомерно.
    </p>
    <p>Операторы break и continue
    </p>
    <p>В некоторых случаях требуется изменить ход выполнения программы, а традиционных языках
        программирования для этих целей применяется оператор goto, однако в Java он не
        поддерживается. Для этих целей приме-tfOffTcn операторы break и continue.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>Оператор
        continue
    </p>
    <p>Оператор continue может
        использоваться только в циклах while, do, for. Если в потоке вычислений встречается оператор
        continue, то выпол­нение
        текущей последовательности операторов (выражений) должно быть прекращено и
        управление будет передано на начало блока, содержащего этот оператор.
    </p>
    <p>
    </p>
    <p>intx = (int)(Math.random()*lO); intarr[l0] ={....} for(int
        cnt=0;cnt&lt;10;cnt++) { if(arr[cnt] == x) continue;
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>В данном случае, если в массиве агг встретится значение, равное х,
        то выполнится оператор continue и все операторы до конца блока будут пропущены, а управление
        будет
        передано на начало цикла.
    </p>
    <p>Если оператор continue будет применен вне
        контекста оператора Цикла, то будет выдана ошибка времени компиляции. В случае
        использо­вания вложенных циклов оператору continue, в качестве адреса
        перехода, может быть указана метка, относящаяся к одному из этих операторов.
    </p>
    <p>Рассмотрим пример:
    </p>
    <p>public class Test { public Test() { }
    </p>
    <p>public static void main(String[] args) { Testt
        = newTest(); for(intj=0;j&lt; 10;j++){
    </p>
    <p>if(i* % 2== 0) continue;
    </p>
    <p>System. out.print("i=" + i);
    </p>
    <p>}
    </p>
    <p>Программирование на ja,,.
    </p>
    <p>tuna 10
    </p>
    <p>Операторы
        и структура кода. Исключения
    </p>
    <p>В результате работы на консоль будет выведено: 1 3579
    </p>
    <p>При выполнении условия в строке 7 нормальная последовательное,
        выполнения операторов будет прервана и управление будет передано н начало
        цикла. Таким образом, на консоль будут выводиться только нече1 ные
        значения.
    </p>
    <p>
    </p>
    <p>Оператор
        break
    </p>
    <p>Этот оператор, как и оператор continue, изменяет последователь­ность
        выполнения, но не возвращает исполнение к началу цикла, а преры-
    </p>
    <p>вает его.
    </p>
    <p>
    </p>
    <p>public class
        Test { public Test() { }
    </p>
    <p>public static void main( String [] args) { Testt =
        new Test() ; int []x = {1,2,4,0,8}; inty =8;
    </p>
    <p>for(int cnt=0;cnt &lt; x.length;cnt++)
        { if(0 == x[cnt]) break; System, out. printlnfy/x = " + y/x[cnt]);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>На консоль будет
        выведено:
    </p>
    <p>y/x = 8 y/x = 4 y/x = 2
    </p>
    <p>
    </p>
    <p>При этом ошибки, связанной с делением на ноль, не произойдет, т.к. если
        значение элемента массива будет равно 0,
        то будет выполнено усло­вие
        в строке 9 и выполнение цикла for будет прервано.
    </p>
    <p>В качестве аргумента break может быть указана
        метка. Как и в случае с continue, нельзя указывать в качестве аргумента метки блоков, в
        которЫ* оператор
        break не содержится.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Именованные блоки
    </p>
    <p>В реальной практике достаточно часто используются вложенные даслы.
        Соответственно, может возникнуть ситуация, когда из вложенно-Ф цикла нужно прервать внешний.
        Простое использование break или O^ritinue не решает этой
        задачи, однако в Java можно именовать блок
        кода дивно указать операторам, к какому из них относится выполняемое дей­ствие. Делается это
        путем присвоения метки операторам do, while, for.
    </p>
    <p>Метка — это любая допустимая в данном контексте лексема, оканчи­вавшаяся
        двоеточием.
    </p>
    <p>Рассмотрим следующий пример:
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>int array[][] = {....}; for(int
        i=0;i&lt;5;i++) { for(j=0;j&lt;4;      {
    </p>
    <p>
    </p>
    <p>if(array[i][j] == caseValue)
        break;
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>В данном случае при выполнении условия будет прервано выполне­ние цикла по
        j, цикл по i продолжится со следующего значения. Для того, чтобы прервать выполнение
        обоих циклов, используется метка:
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>int array[][] = {....}; outerLoop: for(int
        i=0;i&lt;5;i++) { for(j=0;j&lt;4; j++){
    </p>
    <p>
    </p>
    <p>if(array[i][j] == caseValue)
        break outerLoop;
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Оператор continue также может
        использоваться с именованными боками.
    </p>
    <p>Между  операторами   break  и  continue  есть  еще  одно
        существенное отличие. Оператор break может
        использоваться с
    </p>
    <p>любым именованным
        блоком, в этом случае его действие в чем-т0 похоже на действие goto. Оператор continue (как
        и отмечалось ранее) может быть использован только в теле цикла. То
        есть такая конструк. ция будет вполне приемлемой:
    </p>
    <p>
    </p>
    <p>1ы:{
    </p>
    <p>
    </p>
    <p>if( val &gt; maxVal) break Ibi;
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>В то время как оператор continue здесь применять нельзя. В данном слу­чае при выполнении
        условия if выполнение блока с меткой Ibi будет пре­рвано, то
        есть управление будет передано на оператор (выражение), сле­дующий
        непосредственно за закрывающей фигурной скобкой.
    </p>
    <p>Метки используют пространство имен, отличное от пространства имен
        классов и методов.
    </p>
    <p>Так, следующий пример кода
        будет вполне работоспособным:
    </p>
    <p>public class Test { public
        Test() { }
    </p>
    <p>public static void main(String[] args) { Testt = new Test();
        t.test();
    </p>
    <p>}
    </p>
    <p>void test() { Test: {
    </p>
    <p>test: for(int i =0;true;i++)
        { if(i % 2 ==
        0) continue test;
        if(i &gt; 10) break Test; System.out.print(i + " ");
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Для составления меток применяются те же синтаксические правила, что и
        для переменных, за тем исключением, что метки всегда оканчива­ются двоеточием.
        Метки всегда должны быть привязаны к какому-либо блоку кода
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Допускается
        использование меток с одинаковыми именами, но нельзя применять одинаковые имена
        в пределах видимости блока. Т.е-такая конструкция допустима:
    </p>
    <p>Ibi: {
    </p>
    <p>System, out. printlnf'Block 1");
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>Ibi: {
    </p>
    <p>System.out.println("Block 2");
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>A такая нет: Ibi: {
    </p>
    <p>Ibi: {
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Оператор return
    </p>
    <p>Этот оператор предназначен для возврата управления из вызываемо­го
        метода в вызывающий. Если в последовательности операторов выпол­няется return, то управление
        немедленно (если это не оговорено особо) Передается в вызывающий метод.
        Оператор return может иметь, а может и не иметь аргументов. Если метод не возвращает
        значений (объявлен как void),
        то в этом и только этом
        случае выражение return применяется без
        аргументов. Если возвращаемое значение есть, то return обязательно дол-Щн применяться с
        аргументом, чье значение и будет возвращено.
    </p>
    <p>В качестве аргумента return может использоваться выражение
    </p>
    <p>
    </p>
    <p>return (х*у +10) /11 ;
    </p>
    <p>
    </p>
    <p>В этом случае сначала будет выполнено выражение, а затем результат Ґw
        выполнения будет передан в
        вызывающий метод. Если выражение будет Свершено ненормально, то и оператор return будет
        завершен ненормально, например, если во время выполнения выражения
        в операторе return воз-i*j*HeT исключение, то никакого значения метод не вернет, будет
        обрабаты­вая ошибка.
    </p>
    <p>В методе может быть более
        одного оператора return.
    </p>
    <p>
    </p>
    <p>Оператор
        synchronized
    </p>
    <p>Этот оператор применяется для исключения взаимного влияния не-скольких
        потоков при выполнении кода, он будет подробно рассмотрен в лекции 12,
        посвященной потокам исполнения.
    </p>
    <p>
    </p>
    <p>Ошибки
        при работе программы. Исключения (Exceptions)
    </p>
    <p>При выполнении программы могут возникать ошибки. В одних случа­ях это
        вызвано ошибками программиста, в других — внешними причинами. Например, может
        возникнуть ошибка ввода/вывода при работе с файлом или сетевым соединением. В
        классических языках программирования, на­пример, в С, требовалось проверять
        некое условие, которое указывало на наличие ошибки, и в зависимости от этого
        предпринимать те или иные действия.
    </p>
    <p>Например:
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>int statusCode = someAction();
        if
        (statusCode){
    </p>
    <p>... обработка ошибки } else {
    </p>
    <p>statusCode = anotherAction(); if(statusCode) {
    </p>
    <p>... обработка ошибки ...
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>В Java появилось более
        простое и элегантное решение — обработка исключительных ситуаций.
    </p>
    <p>try{
    </p>
    <p>someAction();
        anotherAction() } catch(Exception e) {
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>... обработка
        исключительной ситуации
    </p>
    <p>}
    </p>
    <p>Легко заметить, что такой подход является не только изящным, но и более
        надежным и простым для понимания.
    </p>
    <p>jj&amp;e"—
    </p>
    <p>Причины
        возникновения ошибок
    </p>
    <p>Существует три причины
        возникновения исключительных ситуаций.
    </p>
    <p>•  Попытка выполнить
        некорректное выражение.
    </p>
    <p>Например, деление на ноль, или обращение к объекту по ссылке, равной null, попытка
        использовать класс, описание которого (class-файл) отсутствует,
        и т.д.
    </p>
    <p>В таких случаях всегда можно точно указать, в каком месте про­изошла
        ошибка, - именно в некорректном выражении.
    </p>
    <p>•  Выполнение оператора throw.
    </p>
    <p>Этот оператор применяется для явного порождения ошибки. Оче­видно, что и
        здесь можно указать место возникновения исключи­тельной ситуации.
    </p>
    <p>•  Асинхронные ошибки во
        время исполнения программы. Причиной таких ошибок могут быть сбои внутри самой
        виртуальной
    </p>
    <p>машины (ведь она
        также является программой), или вызов метода stop() у потока выполнения Thread.
    </p>
    <p>В этом случае невозможно указать точное место программы, где про­исходит
        исключительная ситуация. Если мы попытаемся остановить поток выполнения (вызвав
        метод stop()), нам не удастся предсказать, при выпол­нении какого именно выражения
        этот поток остановится.
    </p>
    <p>Таким образом, все ошибки в Java делятся на синхронные и асинхрон­ные. С первыми сравнительно
        проще
        работать, так как принципиально возможно найти точное место в коде, которое
        является причиной возникно­вения исключительной ситуации. Конечно, Java является строгим
        языком в том смысле, что все выражения до точки сбоя
        обязательно будут выполнены, и в то же время ни одно последующее выражение
        никогда выполнено не будет. Важно помнить, что ошибки могут возникать как по
        причине недостаточной внимательности программиста (отсутствует нужный класс,
        или индекс мас­сива вышел за допустимые границы), так и по независящим от него причинам
        (произошел разрыв сетевого соединения, сбой аппаратного обеспечения, Например,
        жесткого диска и др.).
    </p>
    <p>Асинхронные ошибки гораздо сложнее в обнаружении и исправле­нии.
        Обычному разработчику очень трудно выявить причины сбоев в Виртуальной машине.
        Это могут быть ошибки создателей JVM, несовме­стимость
        с операционной системой, аппаратный сбой и многое другое. Все же современные
        виртуальные машины реализованы довольно хоро­шо и подобные сбои происходят
        крайне редко (при условии использова­ния качественных комплектующих).
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Аналогичная ситуация наблюдается и в случае с принудительной Остановкой
        потоков исполнения. Поскольку это действие выполняет -Ся
        операционной системой, никогда нельзя предсказать, в каком ^енно месте
        остановится поток. Это означает, что программа может
    </p>
    <p>многократно отработать корректно, а потом неожиданно дать сбой просто
        из-за того, что поток остановился в каком-то другом месте. По этой причине
        принудительная остановка не рекомендуется. В лекции 12 рассматриваются примеры
        корректного управления жизненным циклом потока.
    </p>
    <p>При возникновении исключительной ситуации управление переда­ется от
        кода, вызвавшего исключительную ситуацию, на ближайший блок catch (или вверх по
        стеку) и создается объект, унаследованный от класса Throwable, или его потомков (см.
        диаграмму иерархии классов-исключе­ний), который
        содержит информацию об исключительной ситуации и ис­пользуется при ее
        обработке. Собственно, в блоке catch указывается именно класс обрабатываемой ситуации.
        Подробно обработка
        ошибок рассматривается ниже.
    </p>
    <p>Иерархия, по которой передается информация об исключительной ситуации,
        зависит от того, где эта исключительная ситуация возникла. Если это
    </p>
    <p>•
        метод, то управление будет
        передаваться в то место, где данный метод был вызван;
    </p>
    <p>•
        конструктор, то управление
        будет передаваться туда, где попыта­лись создать объект (как правило, применяя
        оператор new);
    </p>
    <p>•
        статический инициализатор,
        то управление будет передано туда, где произошло первое обращение к классу,
        потребовавшее его инициа­лизации.
    </p>
    <p>Допускается создание собственных классов исключительных ситуаций.
        Осуществляется это с помощью механизма наследования, то есть класс
        пользовательской исключительной ситуации должен быть унаследован от класса Throwable, или
        его потомков.
    </p>
    <p>
    </p>
    <p>Обработка
        исключительных ситуаций
    </p>
    <p>
    </p>
    <p>Конструкция try-catch
    </p>
    <p>В общем случае конструкция
        выглядит так:
    </p>
    <p>
    </p>
    <p>try {
    </p>
    <p>} catch(SomeExceptionClass
        e) { } catch(AnotherExceptionClass e) {
    </p>
    <p>Работает она следующим образом. Сначала выполняется код, заклю­ченный в
        фигурные скобки оператора try. Если во время его выполнения не происходит никаких нештатных
        ситуаций,
        то далее управление пере­дается за закрывающую фигурную скобку последнего
        оператора catch, ассоциированного с данным оператором try.
    </p>
    <p>Если в пределах try возникает
        исключительная ситуация, то далее вы­полнение кода производится по одному из
        перечисленных ниже сценариев.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Возникла исключительная ситуация, класс которой указан в качест­ве
        параметра одного из блоков catch. В этом случае производится выпол­нение блока кода,
        ассоциированного с
        данным catch (заключенного в фигурные скобки). Далее, если код в этом блоке
        завершается нормально, то и весть оператор try завершается нормально и управление передается
        на оператор (выражение),
        следующий за закрывающей фигурной скобкой последнего catch. Если код в catch завершается не
        штатно, то и весь try завершается
        нештатно по той же причине.
    </p>
    <p>Если возникла исключительная ситуация, класс которой не указан в
        качестве аргумента ни в одном catch, то выполнение всего try завершается
        нештатно.
    </p>
    <p>
    </p>
    <p>Конструкция try-catch-finally
    </p>
    <p>Оператор finally предназначен для
        того, чтобы обеспечить гарантиро­ванное выполнение какого-либо фрагмента кода.
        Вне зависимости от того, возникла ли исключительная ситуация в блоке try, задан ли
        подходящий блок catch, не возникла ли ошибка в самом блоке catch,- все равно блок finally
        будет в конце концов исполнен.
    </p>
    <p>Последовательность выполнения такой конструкции следующая: если оператор
        try выполнен нормально,
        то будет выполнен блок finally. В свою очередь, если оператор finally выполняется нормально,
        то и весь оператор try выполняется нормально.
    </p>
    <p>Если во время выполнения блока try возникает исключение и суще­ствует оператор catch, который
        перехватывает данный тип исключения, Происходит выполнение связанного с catch блока. Если
        блок catch вы­полняется
        нормально, либо ненормально, все равно затем выполняется блок finally. Если блок finally
        завершается нормально, то оператор try за­вершается так же, как завершился блок catch.
    </p>
    <p>Если в списке операторов catch не находится такого, который обра­ботал бы возникшее
        исключение, то все
        равно выполняется блок finally. В Этом случае, если finally завершится
        нормально, весь try завершится не­формально
        по той же причине, по которой было нарушено исполнение try.
    </p>
    <p>Во всех случаях, если блок finally завершается ненормально, то весь fry завершится
        ненормально по той же причине.
    </p>
    <p>Рассмотрим пример применения конструкции try-catch-finally, try {
    </p>
    <p>byte f] buffer = new byte[128];
        FilelnputStream fis = new FilelnputStream("file.txt");
        while(fis.read(buffer) &gt; 0)
        { ... обработка данных
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>}
    </p>
    <p>} catch(IOExceptмon
        es) {
    </p>
    <p>... обработка исключения ... } finally {
    </p>
    <p>fis.flushO;
    </p>
    <p>fis.closeO;
    </p>
    <p>}
    </p>
    <p>Если в данном примере поместить операторы очистки буфера и за­крытия
        файла сразу после окончания обработки данных, то при возникно­вении ошибки
        ввода/вывода корректного закрытия файла не произойдет. Еще раз отметим, что
        блок finally будет выполнен в
        любом случае, вне за­висимости от того, произошла обработка исключения или нет,
        возникло это исключение или нет.
    </p>
    <p>В конструкции try-catch-finally обязательным
        является использование одной из частей оператора catch или finally. То есть
        конструкция
    </p>
    <p>
    </p>
    <p>try {
    </p>
    <p>} finally { }
    </p>
    <p>является вполне допустимой. В этом случае блок finally при возникнове­нии исключительной
        ситуации должен быть выполнен, хотя
        сама исклю­чительная ситуация обработана не будет и будет передана для
        обработки на более высокий уровень иерархии.
    </p>
    <p>Если обработка исключительной ситуации в коде не предусмотре­на, то при
        ее возникновении выполнение метода будет прекращено и исключительная ситуация
        будет передана для обработки коду более вы­сокого уровня. Таким образом, если
        исключительная ситуация произой­дет в вызываемом методе, то управление будет
        передано вызывающему методу и обработку исключительной ситуации должен
        произвести он. Если исключительная ситуация возникла в коде самого высокого
        уроп~ ня (например, методе main()), то управление будет передано исполняю­цдей системе Java
        и выполнение программы будет прекращено (более цочно — будет остановлен
        поток исполнения, в котором произошла та-^ая ошибка).
    </p>
    <p>
    </p>
    <p>Использование
        оператора throw
    </p>
    <p>Помимо того, что предопределенная исключительная ситуация может быть
        возбуждена исполняющей системой Java, программист сам может дано породить ошибку. Делается
        это с помощью
        оператора throw.
    </p>
    <p>Например:
    </p>
    <p>
    </p>
    <p>public int calculate(int theValue) { if( theValue &lt; 0) {
    </p>
    <p>throw new Ехсерпоп("Параметр для вычисления не должен быть
        отрицательным");
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>В данном случае предполагается, что в качестве параметра методу может
        быть передано только положительное значение; если это условие не выполнено, то
        с помощью оператора throw порождается исключи­тельная ситуация. (Для успешной компиляции
        также
        требуется в заго­ловке метода указать throws Exception — это выражение рассматривает­ся
        ниже.)
    </p>
    <p>Метод должен делегировать обработку исключительной ситуации вызвавшему
        его коду
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Для этого в сигнатуре метода применяется ключе­вое слово throws, после которого
        должны быть перечислены через запя­тую все исключительные ситуации, которые
        может вызывать данный ме­тод. То есть приведенный выше пример должен быть
        приведен к следую­щему виду:
    </p>
    <p>public int
        calculate(int theValue) throws Exception { if(
        theValue &lt; 0) {
    </p>
    <p>throw new Exceptionf'Some descriptive info");
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Таким образом, создание исключительной ситуации в программе ВьШолняется
        с помощью оператора throw с аргументом,
        значение которого ^°Жет быть приведено к типу Throwable.
    </p>
    <p>В некоторых случаях после обработки исключительной ситуации может
        возникнуть необходимость передать информацию о ней в вызыва­ющий код.
    </p>
    <p>В этом случае
        ошибка появляется вторично. Например:
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>try{
    </p>
    <p>} catch(IOException ex) {
    </p>
    <p>
    </p>
    <p>// Обработка исключительной ситуации
    </p>
    <p>// Повторное
        возбуждение исключительной ситуации throw ex;
    </p>
    <p>}
    </p>
    <p>Рассмотрим еще один
        случай.
    </p>
    <p>Предположим, что оператор throw применяется внутри
        конструк­ции try-catch.
    </p>
    <p>
    </p>
    <p>try{
    </p>
    <p>throw new IOException(); } catch(Exception
        e) { }
    </p>
    <p>В этом случае исключение, возбужденное в блоке try, не будет пере­дано
        для обработки на более высокий уровень иерархии, а обработается в пределах
        блока try-catch, так как здесь содержится оператор, который может это исключение
        перехватить. То есть произойдет неявная передача управления на соответствующий
        блок cacth.
    </p>
    <p>
    </p>
    <p>Проверяемые
        и непроверяемые исключения
    </p>
    <p>Все исключительные ситуации можно разделить на две категории проверяемые
        (checked) и непроверяемые (unchecked).
    </p>
    <p>Все исключения, порождаемые OTThrowable, можно разбить на
        три группы. Они определяются тремя базовыми типами: наследникам11 Throwable - классами Error
        и Exception, а также наследником Excepti°n - RuntimeException.
    </p>
    <p>Ошибки, порожденные от Exception (и не являющиеся наследниками puntimeException), являются
        проверяемыми. Т.е. во время компиляции Проверяется,
        предусмотрена ли обработка
        возможных исключительных си­туаций. Как правило, это ошибки, связанные с
        окружением программы (сетевым, файловым вводом-выводом и др.), которые могут возникнуть вне
        зависимости
        от того, корректно написан код или нет. Например, открытие сетевого соединения
        или файла может привести к возникновению ошибки Л компилятор требует от программиста
        предусмотреть некие действия для обработки
        возможных проблем
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Таким
        образом повышается надежность Программы, ее устойчивость при возможных сбоях.
    </p>
    <p>Исключения, порожденные от RuntimeException, являются непро­веряемыми и компилятор не требует
        обязательной их
        обработки.
    </p>
    <p>Как правило, это ошибки программы, которые при правильном ко­дировании
        возникать не должны
        (например, IndexOfBoundException
        -выход за границы массива,
        java.lang.ArifmeticException
        - деление на ноль).
        Поэтому, чтобы не загромождать программу, компилятор оставляет &#9632;а
        усмотрение программиста обработку таких исключений с помощью |йоков
        try-catch.
    </p>
    <p>&#9632; Исключения,
        порожденные от Error, также не являются проверяе­мыми. Они предназначены для того, чтобы
        уведомить приложение о воз­никновении фатальной ситуации, которую программным
        способом уст­ранить практически невозможно (хотя формально обработчик
        допускает-сд). Они могут свидетельствовать об ошибках программы, но, как прави-
    </p>
    <table cellpadding="0" cellspacing="0" hspace="0" vspace="0">
        <tr>
            <td align="left" valign="top">
                <p>{
                </p>
            </td>
        </tr>
    </table>
    <p>|,
        это неустранимые проблемы на
        уровне JVM. В качестве примера мож-| привести StackOverflowError (переполнение стека),
        OutOfMemoryError
        ехватка памяти).
    </p>
    <p>Если в конструкции обработки исключений используется несколько
        ^итераторов catch, классы исключений нужно перечислять в них последо-Щтельно, от менее
        общих к более общим. Рассмотрим два примера:
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>catch (Exception e) { }
    </p>
    <p>catch(lOException ioe) { }
    </p>
    <p>catch(UserExcetion ue) {
    </p>
    <p></p>
    <center><img height="440" src="http://kufas.ru/java.files/image019.png" width="443"></center>
    В данном примере при возникновении исключительной
    ситуации (класс, порожденный от Exception) будет выполняться всегда только пер­вый блок catch.
    Остальные не
    будут выполнены ни при каких условиях. Эта ситуация отслеживается компилятором,
    который сообщает об UnreachableCodeException (ошибка -
    недостижимый код). Правильно данная конструкция будет выглядеть так:
    <p>
    </p>
    <p>try {
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>catch(UserExcetion ue) { catch(IOException
        ioe) { }
    </p>
    <p>catch(Exception е) { }
    </p>
    <p>В этом случае будет выполняться последовательная обработка ис­ключений.
        И в случае, если не предусмотрена обработка того типа исклю­чения, которое
        возникло (например, AnotherUserException),
        будет вы­полнен блок catch(Exception е){...}
    </p>
    <p>Если срабатывает один из блоков catch, то остальные блоки
        в данной конструкции try-catch выполняться не будут.
    </p>
    <p>
    </p>
    <p>Создание
        пользовательских классов исключений
    </p>
    <p>Как уже отмечалось, допускается создание собственных классов ис-
        -ключений
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Для этого достаточно создать свой класс, унаследовав его от любого
        наследника java.lang.Throwable
        (или от самого Throwable).
    </p>
    <p>Пример:
    </p>
    <p>public class UserException extends Exception { public
        UserExceptionQ { super();
    </p>
    <p>}
    </p>
    <p>public
        UserException(String descry) { super(descr);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Соответственно, данное исключение будет создаваться
        следующим образом:
    </p>
    <p>
    </p>
    <p>throw new ивегЕхсерпопС'Дополнительное описание");
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>Переопределение
        методов и исключения
    </p>
    <p>При переопределении методов следует помнить, что если переопре­деляемый
        метод объявляет список возможных исключений, то переопре­деляющий метод не
        может расширять этот список, но может его сужать. Усмотрим пример:
    </p>
    <p>public class BaseClass{
    </p>
    <p>public void method () throws lOException {
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>public
        class LegalOne extends BaseClass { public void method () throws lOException {
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>public class LegalTwo extends BaseClass { public void
        method () {
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>public class LegalTree extends BaseClass { public void
        method ()
    </p>
    <p>throws EOFException.MalformedURLException {
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>public class IllegalOne extends BaseClass { public void
        method ()
    </p>
    <p>throws lOException,INegalAccessException {
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>public class lllegalTwo extends BaseClass { public void
        method () {
    </p>
    <p>
    </p>
    <p>throw new Exception();
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>В данном случае:
    </p>
    <p>• определение класса LegalOne будет корректным, так как переопре­деление метода method()
        верное (список
        ошибок не изменился);
    </p>
    <p>• определение класса LegalTwo будет корректным,
        так как пере­определение метода method() верное (новый метод не может вы­брасывать ошибок, а
        значит, не
        расширяет список возможных ошибок старого метода);
    </p>
    <p>•
        определение класса LegalTree будет корректным,
        так как пере­определение метода method() будет верным (новый метод может создавать
        исключения, которые
        являются подклассами исключения, возбуждаемого в старом методе, то есть список
        сузился);
    </p>
    <p>•
        определение класса IlegalOne будет некорректным, так как пере­определение метода method()
        неверно (lllegalAccessException не является
        подклассом lOException, список расширился);
    </p>
    <p>•
        определение класса IlegalTwo будет некорректным: хотя заголовок method() объявлен верно
        (список не расширился), в теле метода бросается исключение, не указанное в throws.
    </p>
    <p>
    </p>
    <p>Особые
        случаи
    </p>
    <p>Во время исполнения кода могут возникать ситуации, которые почти не
        описаны в литературе.
    </p>
    <p>Рассмотрим такую ситуацию:
    </p>
    <p>import java.io.*; public class Test {
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>public Test() { }
    </p>
    <p>public static
        void main(String[]
        args) { Test test = new Test();
        try{
    </p>
    <p>test. doFilelnputfbogus. file");
    </p>
    <p>}
    </p>
    <p>catch (lOException ex) {
    </p>
    <p>System.out.printlnfSecond exception hadle starck trace"); ex. printStackTrace( ) ;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>private String doFilelnput(String fileName)
    </p>
    <p>throws FileNotFoundException,lOException
        { String retStr =
        ""; java.io.FilelnputStream
        fis = null; try{
    </p>
    <p>f is = new java.io.FilelnputStream(fileName);
    </p>
    <p>}
    </p>
    <p>catch (FileNotFoundException ex) {
    </p>
    <p>System.out.printlnf'First exception hadle starck
        trace");
    </p>
    <p>ex.printStackTrace();
    </p>
    <p>throw ex;
    </p>
    <p>}
    </p>
    <p>return retStr;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Результат работы будет выглядеть следующим образом:
    </p>
    <p>
    </p>
    <p>Java.io.FileNotFoundException: bogus.file (The system
        cannot find the file specified)
    </p>
    <p>at java.io.FilelnputStream.open(Native Method)
    </p>
    <p>at
        java.io.FilelnputStream.&lt;init&gt;(FilelnputStream.java:64)
    </p>
    <p>at experiment.Test.doFilelnput(Test.java:33)
    </p>
    <p>at experiment.Test.main(Test.java:21) First exception
        hadle starck trace
    </p>
    <p>Java.io.FileNotFoundException: bogus.file (The system
        cannot find the file specified)
    </p>
    <p>at java.io.FilelnputStream.open(Native Method)
    </p>
    <p>at java.io.FilelnputStream.&lt;init&gt;(FilelnputStream.java:64)
    </p>
    <p>at experiment.Test.doFilelnput(Test.java:33)
    </p>
    <p>at
        experiment.Test.main(Test.java:21) Second exception hadle starck trace
    </p>
    <p>
    </p>
    <p>Так как при вторичном возбуждении используется один и тот же объект Exception, стек в обоих
        случаях будет содержать одну и ту же последователь­ность
        вызовов. То есть при повторном возбуждении исключения, если мы используем тот же объект,
        изменения его параметров не происходит.
    </p>
    <p>Рассмотрим другой пример:
    </p>
    <p>import Java.io.*;
    </p>
    <p>public class Test {
    </p>
    <p>public Test() {
        }
    </p>
    <p>public static void main(String[] args) { Test test = new
        Test();
    </p>
    <p>try {
    </p>
    <p>test.doFilelnput();
    </p>
    <p>}
    </p>
    <p>catch (lOException ex) {
    </p>
    <p>System.out.printlnf'Exception hash code" +
        ex.hashCode()); ex. pri ntStackTrace();
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>private String doFilelnput()
    </p>
    <p>throws FileNotFoundException,IOException{
        String retStr =""; java.io.FilelnputStream fis = null; try {
    </p>
    <p>fis = new
        Java.io.FilelnputStreamf'bogus.file");
    </p>
    <p>}
    </p>
    <p>catch (FileNotFoundException ex) {
    </p>
    <p>System, out. printlnfException hash code" +
        ex.hashCode()); ex. pri ntStackTrace();
    </p>
    <p>fis = new
        java.io.FilelnputStream("anotherBogus.file"); throw ex;
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>}
    </p>
    <p>return retStr;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>java.io.FileNotFoundException: bogus.file (The system
        cannot find the file specified)
    </p>
    <p>at java.io.FilelnputStream.open(Native Method)
    </p>
    <p>at
        java.io.FilelnputStream.&lt;init&gt;(FilelnputStream.java:64)
    </p>
    <p>at experiment.Test.doFilelnput(Test.java:33)
    </p>
    <p>at experiment.Test.main(Test.java:21)
        Exception hash code 3214658
    </p>
    <p>java.io.FileNotFoundException: (The system cannot find
        the path specified)
    </p>
    <p>at
        java.io.FilelnputStream.open(Native Method) at java.io.FilelnputStream.&lt;init&gt;(FilelnputStream.java:64)
        at experiment.Test.doFilelnput(Test.java:38) at
        experiment.Test.main(Test.java:21) Exception hash code 6129586
    </p>
    <p>Несложно заметить, что, хотя последовательность вызовов одна и ту же, в вызываемом и
        вызывающем методах обрабатываются разные объек­ты исключений.
    </p>
    <p>
    </p>
    <p>Заключение
    </p>
    <p>В данной лекции
        рассмотрены основные языковые конструкции.
    </p>
    <p>Для организации циклов в Java предназначены три
        основных конст­рукции: while, do, for. Для изменения порядка выполнения операторов
        применяются continue и break (с меткой или без).
        Также существуют два оператора ветвления: if и switch.
    </p>
    <p>Важной темой является обработка ошибок, поскольку без нее не об­ходится
        ни одна программа, ведь причиной сбоев может служить не только ошибка
        программиста, но и внешние события, например, разрыв сетевого соединения.
        Основной конструкцией обработки исключительных ситуа­ций является try-catch-finally. Для
        явной
        инициализации исключительной ситуации служит ключевое слово throw.
    </p>
    <p>Ошибки делятся на проверяемые и непроверяемые. Чтобы повысить надежность
        программы, компилятор требует обработки исключений, классы которых наследуются
        от Exception, кроме классов-наследников RuntimeException. Предполагается, что такие ошибки
        могут возникать не столько по ошибке
        разработчика, сколько по внешним неконтролиру­емым причинам.
    </p>
    <p>Классы, унаследованные от RuntimeException, описывают про­граммные сбои. Ожидается, что
        программист сведет
        вероятность таких ошибок к минимуму, а потому, чтобы не загромождать код, они
        являются непроверяемыми, компилятор оставляет обработку на усмотрение разра­ботчика.
        Ошибки-наследники Error свидетельствуют о
        фатальных сбоях, поэтому их также необязательно обрабатывать.
    </p>
    <p>Методы, код которых может порождать проверяемые
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>исключения, должны либо
        сами их обрабатывать, либо в заголовке метода должно быть указано ключевое
        слово throws с перечислением
        необрабатываемых про­веряемых исключений. На непроверяемые ошибки это правило
        не распро­страняется.
    </p>
    <p>Переопределенный (overridden) метод не может расширять список возможных исключений исходного
        метода.
    </p>
    <p>Вариант 1
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>I _   Приведенная ниже программа должна вывести на
        консоль Hello World! Выберите
        строки, которые нужно модифицировать в вашей программе, чтобы получить
        правильный результат.
    </p>
    <p>1   public class Test {
    </p>
    <p>2
        public Test() {
    </p>
    <p>3
        }
    </p>
    <p>4 public static void main (String [] args) {
    </p>
    <p>
    </p>
    <p>5
        Test test = new Test();
    </p>
    <p>6
        String [] arr =
        {"Н","е","Г,"Г,"о"," ","w","o","r",'T',"d","!"};
    </p>
    <p>7
        String result =
        "";
    </p>
    <p>8
        int i= 0;
    </p>
    <p>9
        for(;;;){
    </p>
    <p>10             result+=
        arr[i++];
    </p>
    <p>11
        }
    </p>
    <p>12
        System, out.
        println(result);
    </p>
    <p>13       }
    </p>
    <p>14    }
    </p>
    <p>&#9633;
        заменить строку 9 на for(i =
        0; i &lt;
        arr.length;){
    </p>
    <p>&#9633;
        заменить строку 9 на for(int int i = 0; i &lt; arr.length;){
    </p>
    <p>&#9633;
        заменить строку 9 на for(i =
        0; i &lt; arr.length;i++){
    </p>
    <p>&#9633;
        заменить строку 9 на for(i =
        1; i &lt;= arr.length;i++){
    </p>
    <p>
    </p>
    <p>Какая
        строка будет выдана на консоль после выполнения фрагмента кода, приведенного
        ниже? public class Test { public Test()
        (
    </p>
    <p>}
    </p>
    <p>public static void main(String[] args) { inti.j;
    </p>
    <p>lab: for(i = 0; i &lt; 6; i++){ for(j = 3;j&gt;1;j«){ if(i ==j){ System.out.printlnf' " + j);
        break lab;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <table cellpadding="0" cellspacing="0" height="96" hspace="0" vspace="0" width="18">
        <tr>
            <td align="left" height="96" valign="top">
                <p>&#9633; &#9633;
                    &#9633; &#9633;
                </p>
            </td>
        </tr>
    </table>
    <p>
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>2345
        234 3 2
    </p>
    <p>
    </p>
    <table cellpadding="0" cellspacing="0" height="259" hspace="0" vspace="0" width="19">
        <tr>
            <td align="left" height="259" valign="top">
                <p>1 2 3 4 5 6 7 8 9 10 11 12 13
                </p>
            </td>
        </tr>
    </table>
    <p>3-
    </p>
    <p>Предположим,
        нам необходимо создать собственную иерархию исключений. Рассмотрим следующий
        пример.
    </p>
    <p>Exception
    </p>
    <p>I
    </p>
    <p>+--LengthException
    </p>
    <p>I
    </p>
    <p>+--TooLongException
    </p>
    <p>I
    </p>
    <p>+--TooShort
        Exception
    </p>
    <p>
    </p>
    <p>class BaseMeasurer{ public BaseMeasurer(){
    </p>
    <p>}
    </p>
    <p>int measureLength(Dimension
        d) throws LengthException{
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>class DerivedMeasurer extends BaseMeasurer{ public
        BaseMeasurer(){
    </p>
    <p>}
    </p>
    <p>XXX {
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Какое
        из перечисленных ниже выражений можно использовать в строке 11с тем, чтобы код успешно
        откомпилировался?
    </p>
    <p>&#9633;   int measureLength(Dimension
        d) throws LengthException П   int measureLength(Dimension d) throws Exception П   int
        measureLength(Dimension d) throws TooLongException П   int measureLength(Dimension d)
    </p>
    <p>курс
    </p>
    <p>Программирование на.Ь,
    </p>
    <p>Вариант
        2
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>1.  
        Каков будет результат выполнения программы:
    </p>
    <p>1   public class Test {
    </p>
    <p>2
        public Test() {
    </p>
    <p>3
        } 4
    </p>
    <p>5      public static void main(String[] args) {
    </p>
    <p>6
        Test test = new Test();
    </p>
    <p>7
        int i =
        5;
    </p>
    <p>8
        while(i = 5){
    </p>
    <p>9             System.out.println(i++); Ю     }
    </p>
    <p>11       }
    </p>
    <p>12    }
    </p>
    <p>П   компилятор
        выдаст сообщение об ошибке в строке 8
    </p>
    <p>Г")   на
        консоль будут последовательно выведены значения 01234
    </p>
    <p>[~1   на консоль будут последовательно
        выведены значения 43210
    </p>
    <p>Г~1   программа откомпилируется, но на
        консоль ничего выведено не будет
    </p>
    <p>секция Ю                                                         Операторы
        и структура кода. Исключения
    </p>
    <p>2  
        выберите все правильные варианты ответов в этом примере:
    </p>
    <p>public class Test {
    </p>
    <p>float fVal = 0. Of;
    </p>
    <p>public Test() {
    </p>
    <p>}
    </p>
    <p>public static void main(String[] args) {
    </p>
    <p>Test t = new Test();
    </p>
    <p>String testVal = "0.123";
    </p>
    <p>System.out.println("Was returned " + t.testParse(testVal)
        + " with value " + t.tVal);
    </p>
    <p>}
    </p>
    <p>private boolean
        testParse(String val){ try {
    </p>
    <p>fVal = Float. parseFloat(val); return true;
    </p>
    <p>}
    </p>
    <p>catch
        (NumberFormatException ex) {
    </p>
    <p>System.out.println("Test.testParse()
        Bad number -&gt; "
    </p>
    <p>+ val);
    </p>
    <p>fVal = Float. NaN; } finally{
    </p>
    <p>System.out.println( "Finally part executed");
    </p>
    <p>}
    </p>
    <p>return false;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>&#9633;   testVal="0.123"; Finally part
        executed Was returned true with value 0.123
    </p>
    <p>П   testVal = "0,123"; Finally part executed Was
        returned false with value 0.123
    </p>
    <p>П   testVal = null; Finally part executed
    </p>
    <p>Далее будет вызвано исключение NullPointer
    </p>
    <p>П   testVal = "0.123"; Finally part executed Was
        returned false with value null
    </p>
    <p>3.   Предположим, нам необходимо
        создать собственную иерархию исключений. Рассмотрим следующий пример. Exception
    </p>
    <p>I
    </p>
    <p>+--LengthException
    </p>
    <p>I
    </p>
    <p>+--TooLongException
    </p>
    <p>I
    </p>
    <p>+- - TooShortException
    </p>
    <p>
    </p>
    <p>1   class TooShortException extends Exception!
    </p>
    <p>2          public TooShortException(String description){
    </p>
    <p>3                super(description);
    </p>
    <p>4          }
    </p>
    <p>5   } 6
    </p>
    <p>7   class Measurer {
    </p>
    <p>8          public Measurer(){
    </p>
    <p>9                super(); 10     }
    </p>
    <p>11
    </p>
    <p>12          int measureLength(Dimension d) throws LengthException {
    </p>
    <p>13               XXX
    </p>
    <p>14         }
    </p>
    <p>15   }
    </p>
    <p>В строке 13 необходимо вызвать исключение.
    </p>
    <p>Какой из предложенных вариантов
        будет правильным?
    </p>
    <p>&#9633;      new
        TooShortExceptionC'Shhhhort");
    </p>
    <p>П    throws new TooShortExceptionC'Shhhhort");
    </p>
    <p>П    throw new TooShortExceptionC'Shhhhort");
    </p>
    <p>П    throw TooShortExceptionC'Shhhhort").
    </p>
    <p>Вариант 3
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>В данном случае выберите все правильные ответы, private void say(int digit) { switch(x){ case
        1: System.out.print("ONE");
    </p>
    <p>break;
    </p>
    <p>case 2: System.out.printf TWO'); case 3: System.out.print("TREE");
        default:System.out.pritn("Unknown value")
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>&#9633;
        digit = 1 ONE
    </p>
    <p>&#9633;
        digit = 0 TWO TREE
    </p>
    <p>&#9633;
        digit = 2 TWO Unknown
        value
    </p>
    <p>&#9633;
        digit = 3 TREE Unknown
        value
    </p>
    <p>2.   Рассмотрим пример.
    </p>
    <p>Эти
        исключения имеют следующую иерархию наследования: StringlndexOutOfBoundsException и
        ArraylndexOutOfBoundsException
    </p>
    <p>java.lang.Object
    </p>
    <p>I
    </p>
    <p>+--java.lang.Throwable
    </p>
    <p>I
    </p>
    <p>+- -java. lang. Exception
    </p>
    <p>I
    </p>
    <p>+--java.lang.RuntimeException
    </p>
    <p>I
    </p>
    <p>+- -java. lang. IndexOutOf BoundsException
    </p>
    <p>I
    </p>
    <p>+--java.lang.StringlndexOutOf
        BoundsException
    </p>
    <p>
    </p>
    <p>+--java.lang.ArraylndexOutOfBoundsException
    </p>
    <p>Предположим,
        что в методе testSomeValue могут
        быть возбуждены оба вида исключений, при этом они не обрабатываются в блоке try - catch.
    </p>
    <p>Какое
        из перечисленных ниже утверждений будет верным?
    </p>
    <p>Г~1   определение
        метода testSomeValue должно
        включать throws StringlndexOutOf
        BoundsException, ArraylndexOutOfBoundsException
    </p>
    <p>П   если метод, вызывающий testSomeValue, перехватывает IndexOutOfBoundsException, то
        исключения StringlndexOutOf BoundsException,
    </p>
    <p>ArraylndexOutOfBoundsException
        тоже будут перехватываться
    </p>
    <p>П   так как в определении метода указано throws StringlndexOutOf BoundsException,
    </p>
    <p>ArraylndexOutOfBoundsException, любой
        вызывающий его метод должен перехватывать эти типы исключений, вне зависимости
        от того, возбуждается во время работы исключение или нет
    </p>
    <p>П   при
        объявлении метода testSomeValue не
        обязательно указывать возбуждаемые исключения
    </p>
    <p>3.  
        Каков будет результат работы следующего кода: 1 public class Test { 2
    </p>
    <p>3
        public Test() {
    </p>
    <p>4
        }
    </p>
    <p>5 public static void main(String[] args) {
    </p>
    <p>
    </p>
    <p>6
        Test t = new Test();
    </p>
    <p>7
        XXX
    </p>
    <p>
    </p>
    <p>8
        }
    </p>
    <p>9 private int check(String x,int n){
    </p>
    <p>
    </p>
    <p>10 if( n ==0
        )return n;
    </p>
    <p>11 elseif(n== 1){
    </p>
    <p>12            if (x != null) return 5;
    </p>
    <p>13 }
    </p>
    <p>14
        else if (n==2&amp;&amp;x!=null){
    </p>
    <p>
    </p>
    <p>15
        if
        (x.equals("YES"» return 3;
    </p>
    <p>16
        else if ( x.equals("NO"))
        return 4;
    </p>
    <p>
    </p>
    <p>17 }
    </p>
    <p>18 return-1;
    </p>
    <p>19       }
    </p>
    <p>20    }
    </p>
    <p>Если
        в строке 7 поместить код вызова метода check, то
        какое из предложений будет верным?
    </p>
    <p>П   t.check("ANY",1) в этом случае
        обязательно будет выполнена строка 14
    </p>
    <p>Г~| t.check("NO",2) в
        этом случае функция вернет значение 4 П t.checkfYES",
        1) в этом случае функция вернет значение 3 Г~!  
        else в строке 14 относится к if в
        строке 11
    </p>
    <p>
    </p>
    <center>
    </center>
</div>

</body>
</html>
