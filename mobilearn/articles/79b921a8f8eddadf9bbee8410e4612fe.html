<!DOCTYPE html>
<html>
<head>

    <title>Лекция 6. Объявление классов</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<div class="left">
    <p></p>
    <p></p>
    <center><h2>Лекция 6. Объявление классов</h2></center>
    <p>
    </p>
    <p>
    </p>
    <p>Центральная тема лекции — объявление классов, поскольку
        любое Java-приложение является набором классов.
    </p>
    <p>Первый рассматриваемый вопрос — система разграничения
        доступа в Java. Описывается, зачем вообще нужно управление доступом в
        ОО-языке программирования и как оно осуществляется в Java. Затем подробно
        рассма­тривается структура объявления заголовка класса и его тела, которое
        состо­ит из элементов (полей и методов), конструкторов и инициализаторов. До­полнительно
        описывается сигнатура метода main, с которого
        начинается ра­бота Java-приложения, правила передачи параметров различных
        типов в ме­тоды, перегруженные методы.
    </p>
    <p>
    </p>
    <p>Ключевые слова: метод, тело метода, заголовок метода, сигнатура, инизиализатор,
        перегруженные методы.
    </p>
    <p>
    </p>
    <p>Введение
    </p>
    <p>Объявление классов является центральной темой курса, поскольку любая
        программа на Java — это набор
        классов. Поскольку типы являются ключевой конструкцией языка, их структура
        довольно сложна, имеет много тонкостей. Поэтому данная тема разделена на две
        лекции.
    </p>
    <p>Эта лекция начинается с продолжения темы прошлой лекции — име­на и
        доступ к именованным элементам языка. Необходимо рассмотреть механизм
        разграничения доступа в Java, как он устроен, для чего применя­ется. Затем будут описаны
        ключевые
        правила объявления классов.
    </p>
    <p>Следующая лекция подробно рассматривает особенности объектной модели Java. Вводится понятие
        интерфейса. Уточняются правила объяв­ления классов и описывается объявление
        интерфейса.
    </p>
    <p>
    </p>
    <p>Модификаторы доступа
    </p>
    <p>Во многих языках существуют права доступа, которые ограничивают возможность
        использования, например, переменной в классе. Например, легко представить два
        крайних вида прав доступа: это public, когда поле доступно из любой точки программы, и
        private, когда поле может
        исполь­зоваться только внутри того класса, в котором оно объявлено.
    </p>
    <p>Однако прежде, чем переходить к подробному рассмотрению этих и Других
        модификаторов доступа, необходимо внимательно разобраться, зачем они вообще
        нужны.
    </p>
    <p>Предназначение
        модификаторов доступа
    </p>
    <p>Очень часто права доступа расцениваются как некий элемент безо­пасности
        кода: мол, необходимо защищать классы от "неправильного"
        использования. Например, если в классе Human (человек) есть поле age (возраст человека), то
        какой-нибудь программист намеренно
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <center><h2>Лекция 6. Объявление классов</h2></center>
    <p>
    </p>
    <p>
    </p>
    <p>Центральная тема лекции — объявление классов, поскольку
        любое Java-приложение является набором классов.
    </p>
    <p>Первый рассматриваемый вопрос — система разграничения
        доступа в Java. Описывается, зачем вообще нужно управление доступом в
        ОО-языке программирования и как оно осуществляется в Java. Затем подробно
        рассма­тривается структура объявления заголовка класса и его тела, которое
        состо­ит из элементов (полей и методов), конструкторов и инициализаторов. До­полнительно
        описывается сигнатура метода main, с которого
        начинается ра­бота Java-приложения, правила передачи параметров различных
        типов в ме­тоды, перегруженные методы.
    </p>
    <p>
    </p>
    <p>Ключевые слова: метод, тело метода, заголовок метода, сигнатура, инизиализатор,
        перегруженные методы.
    </p>
    <p>
    </p>
    <p>Введение
    </p>
    <p>Объявление классов является центральной темой курса, поскольку любая
        программа на Java — это набор
        классов. Поскольку типы являются ключевой конструкцией языка, их структура
        довольно сложна, имеет много тонкостей. Поэтому данная тема разделена на две
        лекции.
    </p>
    <p>Эта лекция начинается с продолжения темы прошлой лекции — име­на и
        доступ к именованным элементам языка. Необходимо рассмотреть механизм
        разграничения доступа в Java, как он устроен, для чего применя­ется. Затем будут описаны
        ключевые
        правила объявления классов.
    </p>
    <p>Следующая лекция подробно рассматривает особенности объектной модели Java. Вводится понятие
        интерфейса. Уточняются правила объяв­ления классов и описывается объявление
        интерфейса.
    </p>
    <p>
    </p>
    <p>Модификаторы доступа
    </p>
    <p>Во многих языках существуют права доступа, которые ограничивают возможность
        использования, например, переменной в классе. Например, легко представить два
        крайних вида прав доступа: это public, когда поле доступно из любой точки программы, и
        private, когда поле может
        исполь­зоваться только внутри того класса, в котором оно объявлено.
    </p>
    <p>Однако прежде, чем переходить к подробному рассмотрению этих и Других
        модификаторов доступа, необходимо внимательно разобраться, зачем они вообще
        нужны.
    </p>
    <p>Предназначение
        модификаторов доступа
    </p>
    <p>Очень часто права доступа расцениваются как некий элемент безо­пасности
        кода: мол, необходимо защищать классы от "неправильного"
        использования. Например, если в классе Human (человек) есть поле age (возраст человека), то
        какой-нибудь программист намеренно
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>или по не­знанию может присвоить этому полю
        отрицательное значение, после чего объект станет работать неправильно, могут
        появиться ошибки. Для защи­ты такого поля age необходимо объявить его private.
    </p>
    <p>Это довольно распространенная точка зрения, однако нужно при­знать, что
        она далека от истины. Основным смыслом разграничения прав доступа является
        обеспечение неотъемлемого свойства объектной модели - инкапсуляции, то есть
        сокрытия реализации. Исправим пример таким образом, чтобы он корректно отражал
        предназначение модификаторов доступа. Итак, пусть в классе Human есть поле age
        целочисленного типа, и
        чтобы все желающие могли пользоваться этим полем, оно объявляется public.
    </p>
    <p>
    </p>
    <p>public class Human { public int age;
    </p>
    <p>}
    </p>
    <p>Проходит время, и если в группу программистов, работающих над системой,
        входят десятки разработчиков, логично предположить, что все, или многие, из них
        начнут использовать это поле.
    </p>
    <p>Может получиться так, что целочисленного типа данных будет уже
        недостаточно и захочется сменить тип поля на дробный. Однако если про­сто
        изменить int на double, вскоре все разработчики, которые пользовались классом Human и его
        полем age, обнаружат, что в их коде появились ошиб­ки, потому что поле вдруг стало
        дробным, и в строках, подобных этим:
    </p>
    <p>Human h = getHuman();
        int i=h.age; // ошибка!!
    </p>
    <p>будет возникать ошибка из-за попытки провести неявным образом суже­ние
        примитивного типа.
    </p>
    <p>Получается, что подобное изменение (в общем, небольшое и локаль­ное)
        потребует модификации многих и многих классов. Поэтому внесение его окажется
        недопустимым, неоправданным с точки зрения количества усилий, которые необходимо
        затратить. То есть, объявив один раз поле или метод как public, можно оказаться в
        ситуации, когда малейшие изменения
    </p>
    <p>(имени, типа,
        характеристик, правил использования) в дальнейшем станут невозможны.
    </p>
    <p>Напротив, если бы поле было объявлено как private, а для чтения и изменения
        его значения были бы введены дополнительные методы, ситу­ация поменялась бы в
        корне:
    </p>
    <p>public class Human { private
        int age;
    </p>
    <p>// метод, возвращающий значение age public int getAge() { return age;
    </p>
    <p>}
    </p>
    <p>// метод, устанавливающий значение age public void setAge(int a) { age=a;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>В этом случае с данным классом могло бы работать множество про­граммистов
        и могло быть создано большое количество классов, использу­ющих тип Human, но модификатор
        private
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>дает гарантию, что никто
        на­прямую этим полем не пользуется и изменение его типа было бы совсем
        несложной операцией, связанной с изменением только в одном классе.
    </p>
    <p>Получение величины
        возраста выглядело бы следующим образом:
    </p>
    <p>
    </p>
    <p>Human h - getHuman();
    </p>
    <p>int i=h.getAge(); // обращение через метод
    </p>
    <p>
    </p>
    <p>Рассмотрим, как выглядит
        процесс смены типа поля age:
    </p>
    <p>
    </p>
    <p>public class Human {
    </p>
    <p>
    </p>
    <p>// поле получает новый тип double private /*int*/ double age;
    </p>
    <p>
    </p>
    <p>//
        старые методы работают с округлением значения public int getAge() {
    </p>
    <p>return (int)Math.round(age);
    </p>
    <p>}
    </p>
    <p>public void setAge(int a) { age=a;
    </p>
    <p>// добавляются новые методы для работы с типом double
        public double getExactAge() { return age;
    </p>
    <p>}
    </p>
    <p>public
        void setExactAge(double a) { age=a;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Видно, что старые методы, которые, возможно, уже применяются во многих
        местах, остались без изменения. Точнее, остался без изменений их внешний
        формат, а внутренняя реализация усложнилась. Но такая пере­мена не потребует
        никаких модификаций остальных классов системы. Пример использования
    </p>
    <p>
    </p>
    <p>Human h = getHuman();
    </p>
    <p>int i=h.getAge(); // корректно
    </p>
    <p>остается верным, переменная i получает корректное
        целое значение. Од­нако изменения вводились для того, чтобы можно было работать
        с дроб­ными величинами. Для этого были добавлены новые методы и во всех ме­стах,
        где требуется точное значение возраста, необходимо обращаться к ним:
    </p>
    <p>
    </p>
    <p>Human h = getHuman();
    </p>
    <p>double d=h.getExactAge(); // точное значение возраста
    </p>
    <p>Итак, в класс была добавлена новая возможность, не потребовавшая никаких
        изменений кода.
    </p>
    <p>За счет чего была достигнута такая гибкость? Необходимо выделить
        свойства объекта, которые потребуются будущим пользователям этого класса, и
        сделать их доступными (в данном случае, public). Те же элемен­ты
        класса, что содержат детали внутренней реализации логики класса, же­лательно
        скрывать, чтобы не образовались нежелательные зависимости, которые могут
        сдерживать развитие системы.
    </p>
    <p>Этот пример одновременно иллюстрирует и другое теоретическое правило
        написания объектов, а именно: в большинстве случаев доступ к полям лучше
        реализовывать через специальные методы (accessors) для чтения (getters) и записи (setters).
        То есть само поле рассматривается как деталь внутренней реализации.
        Действительно, если рассматривать внешний интерфейс объекта как целиком
        состоящий из допустимых дей­ствий, то доступными элементами должны быть только
        методы, реализу­ющие эти действия
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Один из случаев, в котором такой подход
        приносит необходимую гибкость, уже рассмотрен.
    </p>
    <p>Есть и другие соображения. Например, вернемся к вопросу о кор­ректном
        использовании объекта и установки верных значений полей. Как следствие,
        правильное разграничение доступа позволяет ввести механиз­мы проверки входных
        значений:
    </p>
    <p>public void setAge(int а) { (if а&gt;=0) { age=a;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>В этом примере поле age никогда не примет некорректное отрица­тельное значение. (Недостатком
        приведенного примера является то, что в случае неправильных входных данных они
        просто игнорируются, нет ни­каких сообщений, позволяющих узнать, что изменения
        поля возраста на самом деле не произошло; для полноценной реализации метода
        необхо­димо освоить работу с ошибками в Java.)
    </p>
    <p>Бывают и более существенные изменения логики класса. Например, данные
        можно начать хранить не в полях класса, а в более надежном хра­нилище,
        например, файловой системе или базе данных. В этом случае ме-тоды-аксессоры
        опять изменят свою реализацию и начнут обращаться к persistent storage (постоянное
        хранилище, например, БД) для чтения/запи­си значений. Если доступа к полям
        класса не было, а открытыми были только методы для работы с их значениями, то
        можно изменить код этих методов, а наружные типы, которые использовали данный
        класс, совер­шенно не изменятся, логика их работы останется той же.
    </p>
    <p>Подведем итоги. Функциональность класса необходимо разделять на открытый
        интерфейс, описывающий действия, которые будут использо­вать внешние типы, и на
        внутреннюю реализацию, которая применяется только внутри самого класса. Внешний
        интерфейс в дальнейшем моди­фицировать невозможно, или очень сложно, для
        больших систем, поэто­му его требуется продумывать особенно тщательно. Детали
        внутренней ре­ализации могут быть изменены на любом этапе, если они не меняют
        логи­ку работы всего класса. Благодаря такому подходу реализуется одна из ба­зовых
        характеристик объектной модели — инкапсуляция, и обеспечива­ется важное
        преимущество технологии ООП — модульность.
    </p>
    <p>Таким образом, модификаторы доступа вводятся не для защиты типа °т
        внешнего пользователя, а, напротив, для защиты, или избавления, Пользователя от
        излишних зависимостей от деталей внутренней реализа­ции. Что же касается
        неправильного применения класса,
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>то его создателям нужно стремиться к тому,
        чтобы класс был прост в применении, тогда та­ких проблем не возникнет, ведь
        программист не станет намеренно писать код, который порождает ошибки з его
        программе.
    </p>
    <p>Конечно, такое разбиение на внешний интерфейс и внутреннюю реа­лизацию
        не всегда очевидно, часто условно. Для облегчения задачи техни­ческих
        дизайнеров классов в Java введено не два (public и private), а четыре уровня доступа.
        Рассмотрим их и весь механизм разграничения
        доступа в Java более подробно.
    </p>
    <p>
    </p>
    <p>Разграничение
        доступа в Java
    </p>
    <p>Уровень доступа элемента языка является статическим свойством, задается
        на уровне кода и всегда проверяется во время компиляции. По­пытка обратиться к
        закрытому элементу вызовет ошибку.
    </p>
    <p>В Java модификаторы доступа указываются для:
    </p>
    <p>•
        типов (классов и интерфейсов)
        объявления верхнего уровня;
    </p>
    <p>•
        элементов ссылочных типов
        (полей, методов, внутренних типов);
    </p>
    <p>•
        конструкторов классов.
    </p>
    <p>Как следствие, массив также может быть недоступен в том
        случае, если недоступен тип, на основе которого он объявлен. Все четыре уровня доступа
        имеют только элементы типов и конст­рукторы. Это:
    </p>
    <p>•
        public;
    </p>
    <p>•
        private;
    </p>
    <p>•
        protected;
    </p>
    <p>•
        если не указан ни один из
        этих трех типов, то уровень доступа оп­ределяется по умолчанию (default).
    </p>
    <p>Первые два из них уже были рассмотрены. Последний уровень (доступ по умолчанию)
        упоминался в прошлой лекции — он допускает обращения из того же пакета, где
        объявлен и сам этот класс. По этой причине пакеты в Java являются не просто набором типов, а
        более структурированной едини­цей,
        так как типы внутри одного пакета могут больше взаимодействовать друг с другом,
        чем с типами из других пакетов.
    </p>
    <p>Наконец, protected дает доступ
        наследникам класса. Понятно, что наследникам может потребоваться доступ к
        некоторым элементам роди­теля, с которыми не приходится иметь дело внешним
        классам.
    </p>
    <p>Однако описанная структура не позволяет упорядочить модифи­каторы
        доступа так, чтобы каждый следующий строго расширял преды­дущий. Модификатор protected может
        быть указан
        для наследника из другого пакета, а доступ по умолчанию допускает обращения из
        клас­сов-ненаследников, если они находятся в том же пакете. По этой при­чине
        возможности protected были расширены
        таким образом, что он включает в себя доступ внутри пакета. Итак, модификаторы
        доступа упорядочиваются следующим образом (от менее открытых - к более
        открытым):
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>private
    </p>
    <p>(none) default
    </p>
    <p>protected
    </p>
    <p>public
    </p>
    <p>Эта последовательность будет использована далее при изучении де­талей
        наследования классов.
    </p>
    <p>Теперь рассмотрим, какие модификаторы доступа возможны для различных
        элементов языка.
    </p>
    <p>• Пакеты доступны всегда, поэтому у них нет модификаторов досту­па (можно
        сказать, что все они public, то есть любой существующий в системе пакет может использоваться
        из
        любой точки программы).
    </p>
    <p>•
        Типы (классы и интерфейсы)
        верхнего уровня объявления. При их объявлении существует всего две возможности:
        указать мо­дификатор public или не указывать
        его. Если доступ к типу яв­ляется public, то это означает,
        что он доступен из любой точки кода. Если же он не public, то уровень
        доступа назначается по умолчанию: тип доступен только внутри того пакета, где
        он объявлен.
    </p>
    <p>• Массив имеет тот же уровень доступа, что и тип, на основе кото­рого он
        объявлен (естественно, все примитивные типы являются полностью доступными).
    </p>
    <p>• Элементы и конструкторы объектных типов. Обладают всеми че­тырьмя
        возможными значениями уровня доступа. Все элементы интерфейсов являются public.
    </p>
    <p>Для типов объявления верхнего уровня нет необходимости во всех четырех
        уровнях доступа. Private-типы образовывали бы закрытую мини-программу, никто не мог бы их
        использовать. Типы, доступные только для наследников, также не были признаны
        полезными.
    </p>
    <p>Разграничения доступа сказываются не только на обращении к эле­ментам
        объектных типов или пакетов (через составное имя или прямое обращение), но
        также при вызове конструкторов, наследовании, приве­дении типов. Импортировать
        недоступные типы запрещается.
    </p>
    <p>Проверка уровня доступа проводится компилятором. Обратите вни­мание на
        следующие примеры:
    </p>
    <p>
    </p>
    <p>public class Wheel { private double radius;
    </p>
    <p>public double getRadius() { return radius;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Значение поля radius недоступно снаружи
        класса, однако открытый метод getRadius() корректно возвращает его.
    </p>
    <p>Рассмотрим следующие два модуля компиляции:
    </p>
    <p>
    </p>
    <p>package first;
    </p>
    <p>
    </p>
    <p>// Некоторый класс Parent
    </p>
    <p>public class Parent {
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>package first;
    </p>
    <p>
    </p>
    <p>// Класс Child наследуется от класса Parent, //
        но имеет ограничение доступа по умолчанию class Child extends Parent { }
    </p>
    <p>public class Provider { public Parent getValue() { return
        new Child();
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>К методу getValue() класса Provider можно обратиться и
        из дру­гого пакета, не только из пакета first, поскольку метод
        объявлен как public
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Данный метод возвращает экземпляр класса Child, который не­доступен
        из других пакетов. Однако следующий вызов является кор­ректным:
    </p>
    <p>
    </p>
    <p>package second;
    </p>
    <p>
    </p>
    <p>import first.*;
    </p>
    <p>
    </p>
    <p>public class Test {
    </p>
    <p>public static void main(String s[]) { Provider pr = new
        Provider(); Parent p = pr.getValue();
    </p>
    <p>System.out.println(p.getClass().getName()); // (Child)p
        - приведет к ошибке компиляции!
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Результатом будет: first.Child
    </p>
    <p>То есть на самом деле в классе Test работа идет с экземпляром недо­ступного класса Child, что
        возможно,
        поскольку обращение к нему делается через открытый класс Parent. Попытка же
        выполнить явное приведение вы­зовет ошибку. Да, тип объекта "угадан"
        верно, но доступ к закрытому типу всегда запрещен.
    </p>
    <p>Следующий пример:
    </p>
    <p>
    </p>
    <p>public class Point { private intx, у;
    </p>
    <p>public boolean equals(Object o) { if (o instanceof
        Point) { Point p = (Point)o; return p.x==x &amp;&amp; p.y==y;
    </p>
    <p>}
    </p>
    <p>return false;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>В этом примере объявляется класс Point с двумя полями, описы­вающими координаты точки.
        Обратите внимание, что
        поля полностью закрыты - private. Далее попытаемся переопределить стандартный метод equals()
        таким образом,
        чтобы для аргументов, являющихся эк­земплярами класса Point, или его
        наследников (логика работы опера­тора intsanceof), в случае равенства координат возвращалось
        истин­ное значение.
        Обратите внимание на строку, где делается сравнение координат,- для этого
        приходится обращаться к private-полям друго­го объекта!
    </p>
    <p>Тем не менее, такое действие корректно, поскольку private допускает обращения из любой точки
        класса, независимо от того, к какому
        именно объекту оно производится.
    </p>
    <p>Другие примеры разграничения доступа в Java будут рассматривать­ся По ходу курса.
    </p>
    <p>Объявление классов
    </p>
    <p>Рассмотрим базовые возможности объявления классов. Объявление класса
        состоит из заголовка и тела класса.
    </p>
    <p>
    </p>
    <p>Заголовок класса
    </p>
    <p>Вначале указываются модификаторы класса. Модификаторы досту­па для
        класса уже обсуждались. Допустимым является public, либо его от­сутствие
        — доступ по умолчанию.
    </p>
    <p>Класс может быть объявлен как final. В этом случае не
        допускается создание наследников такого класса. На своей ветке наследования он
        яв­ляется последним. Класс String и классы-обертки,
        например, представля­ют собой final-классы.
    </p>
    <p>После списка модификаторов указывается ключевое слово class, а затем имя
        класса — корректный Java-идентификатор. Таким образом, кратчайшим объявлением класса может
        быть
        такой модуль компиляции:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>class А {}
    </p>
    <p>
    </p>
    <p>Фигурные скобки
        обозначают тело класса, но о нем позже.
    </p>
    <p>Указанный идентификатор становится простым именем класса. Полное
        составное имя класса строится из полного составного имени па­кета, в котором он
        объявлен (если это не безымянный пакет), и простого имени класса, разделенных
        точкой. Область видимости класса, где он мо­жет быть доступен по своему
        простому имени, — его пакет.
    </p>
    <p>Далее заголовок может содержать ключевое слово extends, после ко­торого
        должно быть указано имя (простое или составное) доступного не-final класса. В этом случае
        объявляемый класс наследуется от указанного
        класса. Если выражение extends не применяется, то
        класс наследуется на­прямую от Object. Выражение extends
        Object допускается и игнорируется.
    </p>
    <p>class Parent {} // = class Parent extends Object {}
    </p>
    <p>final class LastChild extends Parent {}
    </p>
    <p>// class WrongChild extends LastChild {} // ошибка!!
    </p>
    <p>Попытка расширить final-класс приведет к
        ошибке компиляции. Если в объявлении класса А указано выражение extends В, то класс А
        называют прямым наследником класса В.
    </p>
    <p>Класс А считается
        наследником класса В, если: • А является прямым наследником В;
    </p>
    <p>188
    </p>
    <p>•  существует класс С,
        который является наследником В, а А явля­ется наследником С (это правило
        применяется рекурсивно).
    </p>
    <p>Таким образом можно проследить цепочки наследования на несколь­ко
        уровней вверх.
    </p>
    <p>Если компилятор обнаруживает, что класс является своим наследни­ком, возникает
        ошибка компиляции:
    </p>
    <p>// пример вызовет
        ошибку компиляции class A extends В {} class В extends С {}
    </p>
    <p>class С extends А {} // ошибка!
        Класс А стал своим наследником
    </p>
    <p>
    </p>
    <p>Далее в заголовке может быть указано ключевое слово implements, за которым должно следовать
        перечисление через запятую имен (простых или
        составных, повторения запрещены) доступных интерфейсов:
    </p>
    <p>
    </p>
    <p>public final class String implements Serializable,
        Comparable {}
    </p>
    <p>
    </p>
    <p>В этом случае говорят, что класс реализует перечисленные интерфей­сы.
        Как видно из примера, класс может реализовывать любое количество ин­терфейсов.
        Если выражение implements отсутствует, то класс действительно не реализует никаких
        интерфейсов,
        здесь значений по умолчанию нет.
    </p>
    <p>Далее следует пара фигурных скобок, которые могут быть пустыми или
        содержать описание тела класса.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>Тело класса
    </p>
    <p>Тело класса может
        содержать объявление элементов (members) класса:
    </p>
    <p>•
        полей;
    </p>
    <p>•
        методов;
    </p>
    <p>•   внутренних типов (классов и интерфейсов); и остальных допустимых
        конструкций:
    </p>
    <p>•
        конструкторов;
    </p>
    <p>•
        инициализаторов;
    </p>
    <p>•
        статических
        инициализаторов.
    </p>
    <p>Элементы класса имеют имена и передаются по наследству, не-эле-менты -
        нет. Для элементов простые имена указываются при объявлении, составные
        формируются из имени класса, или имени переменной объект­ного типа, и простого
        имени элемента. Областью видимости элементов является все объявление тела
        класса. Допускается применение любого из всех четырех модификаторов
        доступа. Напоминаем, что соглашения по именованию классов и их элементов
        обсуждались в прошлой лекции.
    </p>
    <p>He-элементы не
        обладают именами, а потому не могут быть вызва­ны явно. Их вызывает сама
        виртуальная машина. Например, конструктор вызывается при создании объекта. По
        той же причине не-элементы не об­ладают модификаторами доступа.
    </p>
    <p>Элементами класса являются элементы, описанные в объявлении тела класса
        и переданные по наследству от класса-родителя (кроме Object — единственного класса, не
        имеющего родителя) и всех реализуемых ин­терфейсов
        при условии достаточного уровня доступа. Таким образом, ес­ли класс содержит
        элементы с доступом по умолчанию, то его наследни­ки из разных пакетов будут
        обладать разным набором элементов. Классы из того же пакета могут пользоваться
        полным набором элементов, а из других пакетов — только protected и public, private-элементы
        по наслед­ству
        не передаются.
    </p>
    <p>Поля и методы могут иметь одинаковые имена, поскольку обращение к полям
        всегда записывается без скобок, а к методам — всегда со скобками.
    </p>
    <p>Рассмотрим все эти
        конструкции более подробно.
    </p>
    <p>
    </p>
    <p>Объявление полей
    </p>
    <p>Объявление полей начинается с перечисления модификаторов. Воз­можно
        применение любого из трех модификаторов доступа, либо никакого вовсе, что
        означает уровень доступа по умолчанию.
    </p>
    <p>Поле может быть объявлено как final, это означает, что
        оно инициали­зируется один раз и больше не будет менять своего значения.
        Простейший способ работы с final-переменными - инициализация при объявлении:
    </p>
    <p>
    </p>
    <p>final double Pl=3.1415;
    </p>
    <p>
    </p>
    <p>Также допускается инициализация final-полей в конце
        каждого кон­структора класса.
    </p>
    <p>Не обязательно использовать для инициализации константы компи­ляции, возможно
        обращение к различным функциям, например:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>final long
        creationTime=System.currentTimeMillis();
    </p>
    <p>
    </p>
    <p>Данное поле будет хранить время создания объекта. Существует еше два
        специальных модификатора - transient и volatile. Они будут рассмот­рены
        в соответствующих лекциях.
    </p>
    <p>После списка модификаторов указывается тип поля. Затем идет пе­речисление
        одного или нескольких имен полей с возможными инициали­заторами:
    </p>
    <p>int а;
    </p>
    <p>int b=3, c=b+5, d;
    </p>
    <p>Point p, p1=null,
        p2=new Point();
    </p>
    <p>Повторяющиеся имена полей запрещены. Указанный
        идентифика­тор при объявлении становится простым именем поля. Составное имя
        формируется из имени класса или имени переменной объектного типа, и простого
        имени поля. Областью видимости поля является все объявление тела класса.
    </p>
    <p>Запрещается использовать поле в инициализации других полей до его
        объявления.
    </p>
    <p>int у=х; intx=3;
    </p>
    <p>
    </p>
    <p>Однако в остальном поля
        можно объявлять и ниже их использования:
    </p>
    <p>
    </p>
    <p>class Point {
    </p>
    <p>int getX() {return x;}
    </p>
    <p>
    </p>
    <p>int y=getX();
        intx=3;
    </p>
    <p>public static void main (String s[]) { Point p=new Point();
        System.out.println(p.x+", "+p.y);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Результатом будет: 3,0
    </p>
    <p>Данный пример корректен, но для понимания его результата необ­ходимо
        вспомнить, что все поля класса имеют значение по умолчанию:
    </p>
    <p>•
        для числовых полей
        примитивных типов - 0;
    </p>
    <p>•
        для булевского типа - false;
    </p>
    <p>•
        для ссылочных — null.
    </p>
    <p>Таким образом, при инициализации переменной у был использован Результат
        метода getX(), который вернул значение по умолчанию пере­менной х, то есть 0. Затем
        переменная х получила значение 3.
    </p>
    <p>Объявление методов
    </p>
    <p>Объявление метода состоит из заголовка и тела метода. Заголовок состоит
        из:
    </p>
    <p>•
        модификаторов (доступа в
        том числе);
    </p>
    <p>•
        типа возвращаемого
        значения или ключевого слова void;
    </p>
    <p>•
        имени метода;
    </p>
    <p>•
        списка аргументов в
        круглых скобках (аргументов может не быть);
    </p>
    <p>•
        специального throws-выражения.
    </p>
    <p>Заголовок начинается с перечисления модификаторов. Для методов доступен
        любой из трех возможных модификаторов доступа. Также допу­скается использование
        доступа по умолчанию.
    </p>
    <p>Кроме того, существует модификатор final, который говорит о
        том. что такой метод нельзя переопределять в наследниках. Можно считать, что
        все методы final-класса, а также все private-методы любого класса, яв­ляются final.
    </p>
    <p>Также поддерживается модификатор native. Метод,
        объявленный с таким модификатором, не имеет реализации на Java. Он должен быть на­писан
        на другом языке (C/C++, Fortran и т
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>д.) и добавлен
        в систему в ви­де загружаемой динамической библиотеки (например, DLL для Windows).
        Существует специальная спецификация JNI (Java Native Interface), опи­сывающая правила
        создания и использования native-методов.
    </p>
    <p>Такая возможность для Java необходима,
        поскольку многие компа­нии имеют обширные программные библиотеки, написанные на
        более старых языках. Их было бы очень трудоемко и неэффективно переписы­вать на
        Java, поэтому необходима возможность подключать их в таком ви­де, в каком
        они есть. Безусловно, при этом Java-приложения теряют целый ряд своих преимуществ, таких,
        как
        переносимость, безопасность и другие. Поэтому применять JNI следует только в случае крайней
        необходимости.
    </p>
    <p>Эта спецификация накладывает требования на имена процедур во внешних
        библиотеках (она составляет их из имени пакета, класса и само­го native-метода), а
        поскольку библиотеки менять, как правило, очень неудобно, часто пишут
        специальные библиотеки-"обертки", к которым обращаются Java-классы через JNI, а они сами
        обращаются к целевым модулям.
    </p>
    <p>Наконец, существует еще один специальный модификатор synchro­nized, который будет
        рассмотрен в лекции, описывающей потоки выпол­нения.
    </p>
    <p>После перечисления модификаторов указывается имя (простое или составное)
        типа возвращаемого значения; это может быть как примитив­ный, так и объектный
        тип. Если метод не возвращает никакого значения, указывается ключевое слово void.
    </p>
    <p>Затем определяется имя метода. Указанный идентификатор при объ­явлении
        становится простым именем метода. Составное имя формирует­ся из имени класса
        или имени переменной объектного типа и простого имени метода. Областью
        видимости метода является все объявление тела класса.
    </p>
    <p>Аргументы метода перечисляются через запятую. Для каждого ука­зывается
        сначала тип, затем имя параметра. В отличие от объявления пе­ременной здесь
        запрещается указывать два имени для одного типа:
    </p>
    <p>// void cale (double х, у); - ошибка! void cale (double х, double у);
    </p>
    <p>Если аргументы отсутствуют, указываются пустые круглые скобки.
        Одноименные параметры запрещены. Создание локальных переменных в методе, с
        именами, совпадающими с именами параметров, запрещено. Для каждого аргумента
        можно ввести ключевое слово final перед указани­ем
        его типа. В этом случае такой параметр не может менять своего значе­ния в теле
        метода (то есть участвовать в операции присвоения в качестве левого операнда).
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>public void process(int х, final double у) { x=x*x+Math.sqrt(x);
    </p>
    <p>// y=Math.sin(x); - так писать нельзя, т.к. у - final!
    </p>
    <p>}
    </p>
    <p>О том, как происходит изменение значений аргументов
        метода, рас­сказано в конце этой лекции.
    </p>
    <p>Важным понятием является сигнатура (signature) метода. Сигнатура определяется именем метода и
        его аргументами
        (количеством, типом, по­рядком следования). Если для полей запрещается
        совпадение имен, то Для методов в классе запрещено создание двух методов с
        одинаковыми сигнатурами.
    </p>
    <p>Например,
    </p>
    <p>
    </p>
    <p>class Point { void get(){} void get(int x) {}
        void get(int x, double y) {} void get(double x, int y) {}
    </p>
    <p>}
    </p>
    <p>Такой класс объявлен
        корректно. Следующие пары методов в одном классе друг с другом несовместимы:
    </p>
    <p>
    </p>
    <p>void get() {} int
        get(){}
    </p>
    <p>void get(intx) {} void get(inty) {}
    </p>
    <p>public intget()
        {} private int get() {}
    </p>
    <p>В первом случае методы отличаются типом возвращаемого значения, которое,
        однако, не входит в определение сигнатуры. Стало быть, это два метода с
        одинаковыми сигнатурами и они не могут одновременно^ по­явиться в объявлении
        тела класса. Можно составить пример, который со­здал бы неразрешимую проблему
        для компилятора, если бы был допустим:
    </p>
    <p>// пример вызовет ошибку
        компиляции class Test { int get(){ return 5;
    </p>
    <p>}
    </p>
    <p>Point get() {
    </p>
    <p>return new Point(3,5);
    </p>
    <p>}
    </p>
    <p>void print(intx) {
    </p>
    <p>System.out.println("it's int! "+x);
    </p>
    <p>}
    </p>
    <p>void print(Point p) {
    </p>
    <p>System.out.printlnfit's Point! "+p.x+",
        "+p.y);
    </p>
    <p>}
    </p>
    <p>public static void main (String s[]) { Testt
        = newTest(); t.print(t.get()); // Двусмысленность!
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>В классе определена
        запрещенная пара методов get() с одинаковыми сигнатурами и различными возвращаемыми
        значениями.
        Обратимся к выделенной строке в методе main, где возникает
        конфликтная ситуация, с которой компилятор не может справиться. Определены два
        метода print() (у них разные аргументы, а значит, и сигнатуры, то есть это допус­тимые
        методы), и чтобы разобраться, какой из них будет вызван, нужно знать точный тип
        возвращаемого значения метода get(), что невозможно.
    </p>
    <p>На основе этого примера можно понять, как составлено понятие сигнатуры.
        Действительно, при вызове указывается имя метода и пере­числяются его
        аргументы, причем компилятор всегда может определить их тип. Как раз эти
        понятия и составляют сигнатуру, и требование ее уни­кальности позволяет
        компилятору всегда однозначно определить, какой метод будет вызван.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Точно так же в предыдущем примере вторая пара методов различает­ся
        именем аргументов, которые также не входят в определение сигнатуры и не
        позволяют определить, какой из двух методов должен быть вызван.
    </p>
    <p>Аналогично, третья пара различается лишь модификаторами доступа, что
        также недопустимо.
    </p>
    <p>Наконец, завершает заголовок метода throws-выражение. Оно при­меняется
        для корректной работы с ошибками в Java и будет подробно рас­смотрено в соответствующей
        лекции.
    </p>
    <p>Пример объявления метода:
    </p>
    <p>
    </p>
    <p>public final java.awt.Point createPositivePoint(int x, int y) throws
        NlegalArgumentException
    </p>
    <p>{
    </p>
    <p>return (x&gt;0 &amp;&amp; y&gt;0) ? new Point(x, y) : null;
    </p>
    <p>}
    </p>
    <p>Далее, после заголовка метода следует тело метода. Оно может быть пустым
        и тогда записывается одним символом "точка с запятой". Native-методы всегда
        имеют только пустое тело, поскольку настоящая реализа­ция написана на другом
        языке.
    </p>
    <p>Обычные же методы имеют непустое тело, которое описывается в фигурных
        скобках, что показано в многочисленных примерах в этой и Других лекциях. Если
        текущая реализация метода не выполняет никаких Действий, тело все равно должно
        описываться парой пустых фигурных скобок:
    </p>
    <p>
    </p>
    <p>Public void empty() {}
    </p>
    <p>
    </p>
    <p>Если в заголовке метода указан тип возвращаемого значения, а не ^°'d, то в теле метода
        обязательно должно встречаться return-выражение.
    </p>
    <p>Ри этом компилятор проводит анализ структуры метода, чтобы гаранти-13»
    </p>
    <p>Однако логика работы конструкторов имеет и некоторые важные особенности.
        Поскольку при их вызове осуществляется создание и ини­циализация объекта,
        становится понятно, что такой процесс не может происходить без обращения к
        конструкторам всех родительских классов. Поэтому вводится обязательное правило
        - первой строкой в конструкто­ре должно быть обращение к родительскому классу,
        которое записывает­ся с помощью ключевого слова super.
    </p>
    <p>
    </p>
    <p>public class Parent { private int x, у;
    </p>
    <p>
    </p>
    <p>public Parent() { x=y=0;
    </p>
    <p>}
    </p>
    <p>public Parent(int newx, int newy) { x=newx;
        y=newy;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>public class Child extends Parent { public
        Child() { super();
    </p>
    <p>}
    </p>
    <p>public Child(int newx, int newy) { super(newx,
        newy);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Как видно, обращение к родительскому конструктору записывает­ся с
        помощью super, за которым идет перечисление аргументов
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Этот набор определяет, какой
        из родительских конструкторов будет исполь­зован. В приведенном примере в
        каждом классе имеется по два конст­руктора и каждый конструктор в наследнике
        обращается к аналогично­му в родителе (это довольно распространенный, но,
        конечно, не обяза­тельный способ).
    </p>
    <p>Проследим мысленно весь алгоритм создания объекта. Он начина­ется при
        исполнении выражения с ключевым словом new, за которым
        следует имя класса, от которого будет порождаться объект, и набор аргу­ментов
        для его конструктора. По этому набору определяется, какой именно конструктор
        будет использован, и происходит его вызов. Первая строка его тела содержит
        вызов родительского конструктора. В свою оче­редь, первая строка тела
        конструктора родителя будет содержать вызов к его родителю, и так далее.
        Восхождение по дереву наследования закан­чивается, очевидно, на классе Object, у которого
        есть
        единственный конструктор без параметров. Его тело пустое (записывается парой
        пус­тых фигурных скобок), однако можно считать, что именно в этот момент JVM порождает
        объект и далее начинается процесс его инициализации.
        Выполнение начинает обратный путь вниз по дереву наследования. У са­мого
        верхнего родителя, прямого наследника от Object, происходит про­должение
        исполнения конструктора со второй строки. Когда он будет полностью выполнен,
        необходимо перейти к следующему родителю, на один уровень наследования вниз, и
        завершить выполнение его конструк­тора, и так далее. Наконец, можно будет
        вернуться к конструктору ис­ходного класса, который был вызван с помощью new, и также
        продол­жить
        его выполнение со второй строки. По его завершении объект счи­тается полностью
        созданным, исполнение выражения new будет закон­чено, а
        в качестве результата будет возвращена ссылка на порожденный объект.
    </p>
    <p>Проиллюстрируем этот алгоритм следующим примером:
    </p>
    <p>
    </p>
    <p>public class GraphicElement {
    </p>
    <p>private int x, у; // положение на экране
    </p>
    <p>
    </p>
    <p>public GraphicElement(int пх, int пу) {
    </p>
    <p>super(); // обращение к конструктору родителя Object
    </p>
    <p>System, out. printlnC'GraphicElement");
    </p>
    <p>x=nx;
    </p>
    <p>y=nx;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>public class Square extends GraphicElement { private
        int side;
    </p>
    <p>public Square(int x, int y, int nside) { super(x, y);
    </p>
    <p>System.out.println("Square"); side=nside;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>public class SmallColorSquare extends Square { private
        Color color;
    </p>
    <p>public SmallColorSquare(int x, int y, Color c) { super(x,
        y, 5);
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>System.out.println("SmallColorSquare");
        color=c;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>После выполнения выражения создания объекта на экране
        появится следующее:
    </p>
    <p>GraphicElement Square
    </p>
    <p>SmallColorSquare
    </p>
    <p>
    </p>
    <p>Выражение super может стоять только
        на первой строке конструкто­ра. Часто можно увидеть конструкторы вообще без
        такого выражения. В этом случае компилятор первой строкой по умолчанию
        добавляет вызов родительского конструктора без параметров (super()). Если у
        родитель­ского класса такого конструктора нет, выражение super обязательно должно быть
        записано явно (и именно на первой строке),
        поскольку не­обходима передача входных параметров.
    </p>
    <p>Напомним, что, во-первых, конструкторы не имеют имени и их нельзя
        вызвать явно, только через выражение создания объекта. Кроме того, конструкторы
        не передаются по наследству. То есть, если в роди­тельском классе объявлено
        пять разных полезных конструкторов и требу­ется, чтобы класс-наследник имел
        аналогичный набор, необходимо все их описать заново.
    </p>
    <p>Класс обязательно должен иметь конструктор, иначе невозможно порождать
        объекты ни от него, ни от его наследников. Поэтому если в классе не объявлен ни
        один конструктор, компилятор добавляет один по умолчанию. Это public-конструктор без
        параметров и с телом, опи­санным парой пустых фигурных скобок. Из этого
        следует, что такое возможно только для классов, у родителей которых объявлен
        конструк­тор без параметров, иначе возникнет ошибка компиляции. Обратите
        внимание, что если затем в такой класс добавляется конструктор (не важно, с
        параметрами или без), то конструктор по умолчанию больше не вставляется:
    </p>
    <p>/*
    </p>
    <p>* Этот класс имеет один конструктор.
    </p>
    <p>7
    </p>
    <p>public class One {
    </p>
    <p>// Будет создан
        конструктор по умолчанию // Родительский класс Object имеет // конструктор без параметров.
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>/*
    </p>
    <p>* Этот класс имеет один конструктор.
    </p>
    <p>7
    </p>
    <p>public class Two {
    </p>
    <p>// Единственный конструктор класса Second. // Выражение new Second() ошибочно! public
        Second(int х) { }
    </p>
    <p>
    </p>
    <p>/*
    </p>
    <p>* Этот класс имеет два конструктора.
    </p>
    <p>7
    </p>
    <p>public class Three extends Two { public Three() {
    </p>
    <p>super(1 ); // выражение super требуется
    </p>
    <p>}
    </p>
    <p>public Three(int x) {
    </p>
    <p>super(x); // выражение super требуется
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Если класс имеет более одного конструктора, допускается в первой строке
        некоторых из них указывать не super, a this - выражение, вызыва­ющее
        другой конструктор этого же класса.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Рассмотрим следующий пример:
    </p>
    <p>public class Vector { private int vx, vy; protected
        double length;
    </p>
    <p>
    </p>
    <p>public Vector(int x, int y) {
    </p>
    <p>super(); vx=x;
    </p>
    <p>vy=y;
    </p>
    <p>length=Math.sqrt(vx*vx+vy*vy);
    </p>
    <p>}
    </p>
    <p>public Vector(int x1, int y1, int x2, int
        y2) { super(); vx=x2-x1; vy=y2-y1;
    </p>
    <p>len gth=Math. sq
        rt ( vx* vx+vy* vy ) ;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Видно, что оба конструктора совершают практически идентичные действия,
        поэтому можно применить более компактный вид записи:
    </p>
    <p>public class Vector { private int vx, vy; protected
        double length;
    </p>
    <p>public Vector(int x, int y) { super(); vx=x;
        vy=y;
    </p>
    <p>length=Math.sqrt(vx*vx+vy*vy);
    </p>
    <p>}
    </p>
    <p>public Vector(int x1, int y1, int x2, int
        y2) { this(x2-x1, y2-y1 );
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Большим достоинством такого метода записи является то, что уда­лось
        избежать дублирования идентичного кода. Например, если процесс инициализации
        объектов этого класса удлинится на один шаг (скажем, до­бавится проверка длины
        на ноль), то такое изменение надо будет внести только в первый конструктор.
        Такой подход помогает избежать случай­ных ошибок, так как исчезает
        необходимость тиражировать изменения в нескольких местах.
    </p>
    <p>Разумеется, такое обращение к конструкторам своего класса не должно
        приводить к зацикливаниям, иначе будет выдана ошибка компи­дяции. Цепочка this должна в
        итоге приводить к super, который должен
        присутствовать (явно или неявно) хотя бы в одном из конструкторов. По­сле того,
        как отработают конструкторы всех родительских классов, будет продолжено
        выполнение каждого конструктора, вовлеченного в процесс создания объекта.
    </p>
    <p>public class Test { public Test() {
    </p>
    <p>System.out.println("Test()");
    </p>
    <p>}
    </p>
    <p>public Test(int x) { thisO;
    </p>
    <p>System. out. pri ntln("Test( int x)" ) ;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>После выполнения выражения
        new Test(0) на консоли появится:
    </p>
    <p>Test() Test(intx)
    </p>
    <p>В заключение рассмотрим применение модификаторов доступа для
        конструкторов. Может вызвать удивление возможность объявлять конст­рукторы как private. Ведь
        они нужны для генерации объектов, а к таким конструкторам ни у кого
        не будет доступа. Однако в ряде случаев моди­фикатор private может быть полезен.
        Например:
    </p>
    <p>• private-конструктор может
        содержать инициализирующие дейст­вия, а остальные конструкторы будут использовать
        его с помощью this, причем прямое обращение к этому конструктору по каким-то причинам
        нежелательно;
    </p>
    <p>•
        запрет на создание
        объектов этого класса, например, невозможно создать экземпляр класса Math;
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>• реализация специального шаблона проектирования из ООП Singleton, для работы которого
        требуется контролировать создание объектов, что
        невозможно в случае наличия не-private конструк­торов.
    </p>
    <p>
    </p>
    <p>Инициализаторы
    </p>
    <p>Наконец, последней допустимой конструкцией в теле класса являет-Ся
        объявление инициализаторов. Записываются объектные инициализа-ТоРЫ очень просто —
        внутри фигурных скобок.
    </p>
    <p>public class Test { private int x, у, z;
    </p>
    <p>// инициализатор объекта {
    </p>
    <p>х=3; if (х&gt;0) У=4;
    </p>
    <p>z=Math.max(x, у);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Инициализаторы не имеют имен, исполняются при создании объек­тов, не
        могут быть вызваны явно, не передаются по наследству (хотя, ко­нечно,
        инициализаторы в родительском классе продолжают исполняться при создании
        объекта класса-наследника).
    </p>
    <p>Было указано уже три вида инициализирующего кода в классах - кон­структоры,
        инициализаторы переменных, а теперь добавились объектные инициализаторы.
        Необходимо разобраться, в какой последовательности что выполняется, в том числе
        при наследовании. При создании экземпля­ра класса вызванный конструктор
        выполняется следующим образом:
    </p>
    <p>• если первой строкой идет обращение к конструктору родительско­го класса
        (явное или добавленное компилятором по умолчанию), то этот конструктор
        исполняется;
    </p>
    <p>•
        в случае успешного
        исполнения вызываются все инициализаторы полей и объекта в том порядке, в каком
        они объявлены в теле класса;
    </p>
    <p>•
        если первой строкой идет
        обращение к другому конструктору этого же класса, то он вызывается. Повторное
        выполнение ини­циализаторов не производится.
    </p>
    <p>Второй пункт имеет ряд важных следствий. Во-первых, из него сле­дует,
        что в инициализаторах нельзя использовать переменные класса, если их объявление
        записано позже.
    </p>
    <p>Во-вторых, теперь можно сформулировать наиболее гибкий подход к
        инициализации final-полей. Главное требование — чтобы такие поля были проинициализированы
        ровно один раз. Это можно обеспечить в следую­щих случаях:
    </p>
    <p>•
        если инициализировать поле
        при объявлении;
    </p>
    <p>• если инициализировать поле только один раз в инициализаторе объекта (он
        должен быть записан после объявления поля);
    </p>
    <p>• если инициализировать поле только один раз в каждом конструк­торе, в
        первой строке которого стоит явное или неявное обраще­ние к конструктору
        родителя. Конструктор, в первой строке ко­торого стоит this, не может
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>и не
        должен инициализировать final-поле, так как цепочка this-вызовов приведет к конструктору с
        super, в котором эта инициализация
        обязательно присутствует. Для иллюстрации порядка исполнения инициализирующих
        конст­рукций рассмотрим следующий пример:
    </p>
    <p>public class Test { {
    </p>
    <p>System.out.println("initializer");
    </p>
    <p>}
    </p>
    <p>intx, y=getY(); final int z; {
    </p>
    <p>System.out.println("initializer2");
    </p>
    <p>}
    </p>
    <p>private int getY() {
    </p>
    <p>System.out.println("getY() "+z); return z;
    </p>
    <p>}
    </p>
    <p>public Test() {
    </p>
    <p>System.out.println("Test()"); z=3;
    </p>
    <p>}
    </p>
    <p>public Test(int x) { this();
    </p>
    <p>System.out.println("Test(int)");
    </p>
    <p>// z=4; - нельзя! final-поле уже было инициализировано
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>После выполнения выражения newTest() на консоли
        появится:
    </p>
    <p>
    </p>
    <p>initializer getY() 0 initialized Test()
    </p>
    <p>Обратите внимание, что для инициализации поля у вызывается метод 9efY(), который возвращает
        значение final-поля z, которое еще не было инициализировано. Поэтому в итоге поле у получит
        значение по умолча-10110 0, а затем поле z получит постоянное
        значение 3, которое никогда У*6 не изменится.
    </p>
    <p>После выполнения выражения new Test(3) на консоли появится:
    </p>
    <p>initializer
        getY() О initialized Test() Test(int)
    </p>
    <p>
    </p>
    <p>Дополнительные свойства
        классов
    </p>
    <p>Рассмотрим в этом разделе некоторые особенности работы с класса­ми в Java. Обсуждение данного
        вопроса будет продолжено в специальной лекции, посвященной объектной модели в Java.
    </p>
    <p>
    </p>
    <p>Метод
        main
    </p>
    <p>Итак, виртуальная машина реализуется приложением операционной системы и
        запускается по обычным правилам. Программа, написанная на Java, является набором
        классов. Понятно, что требуется некая входная точка, с которой должно
        начинаться выполнение приложения.
    </p>
    <p>Такой входной точкой, по аналогии с языками C/C++, является ме­тод main(). Пример его
        объявления:
    </p>
    <p>
    </p>
    <p>public static void main(String[] args) {}
    </p>
    <p>
    </p>
    <p>Модификатор static в этой лекции не
        рассматривался и будет изучен позже. Он позволяет вызвать метод main(), не создавая
        объектов. Метод не возвращает никакого значения, хотя в С есть возможность
        указать код воз­врата из программы. В Java для этой цели существует метод System.exit(),
        который
        закрывает виртуальную машину и имеет аргумент типа int.
    </p>
    <p>Аргументом метода main() является массив строк. Он заполняется до­полнительными параметрами,
        которые были указаны при вызове метода.
    </p>
    <p>
    </p>
    <p>package test.first;
    </p>
    <p>
    </p>
    <p>public
        class Test {
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>public static void main(String[] args) { for
        (int i=0; i&lt;args.length; i++) { System.out.print(args[i]+" ");
    </p>
    <p>}
    </p>
    <p>System.out.println();
    </p>
    <p>}
    </p>
    <p>Для вызова программы виртуальной машине передается в качест­ве параметра
        имя класса, у которого объявлен метод main(). Посколь­ку это
        имя класса, а не имя файла, то не должно указываться никако­го расширения (.class или .java)
        и расположение класса записывает­ся через точку (разделитель имен
        пакетов), а не с помощью файлово­го разделителя. Компилятору же, напротив,
        передается имя и путь к файлу.
    </p>
    <p>Если приведенный выше модуль компиляции сохранен в файле Test.java, который лежит в каталоге
        test\first,
        то вызов компилятора запи­сывается
        следующим образом:
    </p>
    <p>javac test\first\Test.java
    </p>
    <p>А вызов виртуальной
        машины:
    </p>
    <p>java test.first.Test
    </p>
    <p>Чтобы проиллюстрировать работу с параметрами, изменим строку запуска
        приложения:
    </p>
    <p>java test.first.Test Hello, World!
    </p>
    <p>Результатом работы
        программы будет:
    </p>
    <p>Hello, World!
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>Параметры
        методов
    </p>
    <p>Для лучшего понимания работы с параметрами методов в Java необ­ходимо рассмотреть несколько
        вопросов.
    </p>
    <p>Как передаются аргументы в методы — по значению или по ссылке? Сточки
        зрения программы вопрос формулируется, например, следующим образом. Пусть есть
        переменная и она в качестве аргумента передается в некоторый метод. Могут ли
        произойти какие-либо изменения с этой пе­ременной после завершения работы
        метода?
    </p>
    <p>
    </p>
    <p>int х=3;
    </p>
    <p>process(x);
    </p>
    <p>print(x);
    </p>
    <p>
    </p>
    <p>Предположим, используемый
        метод объявлен следующим образом:
    </p>
    <p>public void process(int x) { x=5;
    </p>
    <p>}
    </p>
    <p>Какое значение появится на консоли после выполнения примера? Чтобы
        ответить на этот вопрос, необходимо вспомнить, как переменные разных типов
        хранят свои значения в Java.
    </p>
    <p>Напомним, что примитивные переменные являются истинными хранилищами
        своих значений и изменение значения одной переменной никогда не скажется на
        значении другой. Параметр метода process(), хоть и имеет
        такое же имя х, на самом деле является полноценным храни­лищем целочисленной
        величины. А потому присвоение ему значения 5 не скажется на внешних переменных.
        То есть результатом примера будет 3 и аргументы примитивного типа передаются в методы по
        значению.
        Единственный способ изменить такую переменную в результате работы метода —
        возвращать нужные величины из метода и использовать их при присвоении:
    </p>
    <p>
    </p>
    <p>public int
        double(int х) { return х+х;
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>}
    </p>
    <p>public void test() { int x=3; x=double(x);
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Перейдем к ссылочным типам.
    </p>
    <p>
    </p>
    <p>public void process(Point p) { p.x=3;
    </p>
    <p>}
    </p>
    <p>public void test() {
    </p>
    <p>Point p = new Point(1,2);
    </p>
    <p>process(p);
    </p>
    <p>print(p.x);
    </p>
    <p>}
    </p>
    <p>Ссылочная переменная хранит ссылку на объект, находящийся в па­мяти
        виртуальной машины. Поэтому аргумент метода processo будет иметь в качестве значения ту же
        самую ссылку и, стало
        быть, ссылаться на тот же самый объект. Изменения состояния объекта,
        осуществленные с по-мошью одной ссылки, всегда видны при обращении к этому
        объекту с по­мощью другой. Поэтому результатом примера будет значение 3.
        Объектные значения
        передаются в Java по ссылке.
    </p>
    <p>Однако если изменять не состояние объекта, а саму ссылку, то ре­зультат
        будет другим:
    </p>
    <p>public void process(Point p) { p = new Point(4,5);
    </p>
    <p>}
    </p>
    <p>public void test() {
    </p>
    <p>Point p = new Point(1,2);
    </p>
    <p>process(p);
    </p>
    <p>print(p.x);
    </p>
    <p>}
    </p>
    <p>В этом примере аргумент метода processo после присвоения начи­нает ссылаться на другой
        объект, нежели исходная
        переменная p, а зна­чит, результатом примера станет значение 1. Можно сказать, что
        ссылоч­ные величины передаются по значению, но значением является именно ссылка
        на объект.
    </p>
    <p>Теперь можно уточнить, что означает возможность объявлять пара­метры
        методов и конструкторов как final. Поскольку изменения значений параметров (но не объектов,
        на которые они
        ссылаются) никак не сказы­ваются на переменных вне метода, модификатор final говорит лишь о
        том,
        что значение этого параметра не будет меняться на протяжении работы метода.
        Разумеется, для аргумента final Point
        р выражение р.х=5 является допустимым (запрещается p=new Point(5, 5)).
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>Перегруженные методы
    </p>
    <p>Перегруженными (overloading) методами называются методы одного класса с одинаковыми именами.
        Сигнатуры у них должны быть различ­ными и различие может быть только в наборе
        аргументов.
    </p>
    <p>Если в классе параметры перегруженных методов заметно различа­йся:
        например, у одного метода один параметр, у другого - два, то для ava это совершенно
        независимые методы и совпадение их имен может служить
        только для повышения наглядности работы класса. Каждый вы-3ов&gt; в
        зависимости от количества параметров, однозначно адресуется то-МУ
        Или иному методу.
    </p>
    <p>Однако если количество параметров одинаковое, а типы их различа­ются
        незначительно, при вызове может сложиться двойственная ситуа­ция, когда
        несколько перегруженных методов одинаково хорошо подхо­дят для использования.
        Например, если объявлены типы Parent и Child, где Child расширяет Parent, то для следующих
        двух методов:
    </p>
    <p>void process(Parent р, Child с) {} void
        process(Child с, Parent p) {}
    </p>
    <p>можно сказать, что они допустимы, их сигнатуры различаются. Однако при
        вызове
    </p>
    <p>
    </p>
    <p>process(new
        Child(), new Child());
    </p>
    <p>
    </p>
    <p>обнаруживается, что оба метода одинаково годятся для использования.
        Другой пример, методы:
    </p>
    <p>
    </p>
    <p>process(Object о) {} process(String s) {}
    </p>
    <p>
    </p>
    <p>и примеры вызовов:
    </p>
    <p>
    </p>
    <p>process(new
        Objecto); process(new Point(4,5)); process("abc");
    </p>
    <p>Очевидно, что для первых двух вызовов подходит только первый метод, и
        именно он будет вызван. Для последнего же вызова подходят оба перегру­женных
        метода, однако класс String является более
        "специфичным", или узким, чем класс Object. Действительно,
        значения типа String можно пе­редавать в
        качестве аргументов типа Object, обратное же неверно. Компи­лятор попытается отыскать
        наиболее
        специфичный метод, подходящий для указанных параметров, и вызовет именно его.
        Поэтому при третьем вы­зове будет использован второй метод.
    </p>
    <p>Однако для предыдущего примера такой подход не дает однозначного ответа.
        Оба метода одинаково специфичны для указанного вызова, поэто­му возникнет
        ошибка компиляции. Необходимо, используя явное приведе­ние, указать
        компилятору, какой метод следует применить:
    </p>
    <p>process((Parent)(new Child()), new Child()); // или
    </p>
    <p>process(new
        Child(),(Parent)(new Child()));
    </p>
    <p>Это верно и в случае использования значения null:
    </p>
    <p>
    </p>
    <p>process((Parent)null,
        null); // или
    </p>
    <p>process(null,(Parent)null);
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>Заключение
    </p>
    <p>В этой лекции началось рассмотрение ключевой конструкции языка Java — объявление класса.
    </p>
    <p>Первая тема посвящена средствам разграничения доступа. Главный вопрос —
        для чего этот механизм вводится в практически каждом совре­менном языке
        высокого уровня. Необходимо понимать, что он предназ­начен не для обеспечения
        "безопасности" или "защиты" объекта от неких неправильных
        действий. Самая важная задача — разделить внешний ин­терфейс класса и детали
        его реализации с тем, чтобы в дальнейшем вос­пользоваться такими преимуществами
        ООП, как инкапсуляция и модуль­ность.
    </p>
    <p>Затем были рассмотрены все четыре модификатора доступа, а также
        возможность их применения для различных элементов языка. Проверка уровня
        доступа выполняется уже во время компиляции и запрещает лишь явное
        использование типов. Например, с ними все же можно работать че­рез их более
        открытых наследников.
    </p>
    <p>Объявление класса состоит из заголовка и тела класса. Формат заго­ловка
        был подробно описан. Для изучения тела класса необходимо вспомнить понятие
        элементов (members) класса. Ими могут быть поля, методы и внутренние типы. Для методов
        важным понятием является сиг­натура.
    </p>
    <p>Кроме того, в теле класса объявляются конструкторы и инициализа­торы.
        Поскольку они не являются элементами, к ним нельзя обратиться явно, они
        вызываются самой виртуальной машиной. Также конструкторы и
        инициализаторы не передаются по наследству.
    </p>
    <p>Дополнительно был рассмотрен метод main, который
        вызывается пРи старте виртуальной машины. Далее описываются
        тонкости, возника­ющие при передаче параметров, и связанный с этим вопрос о
        перегру-Женных методах.
    </p>
    <p>Классы Java мы продолжим рассматривать в следующих лекциях.
    </p>
    <p>Вариант
        1
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>1.  
        Какие модификаторы позволяют обращаться к элементу из классов того же пакета?
    </p>
    <p>О     public
    </p>
    <p>О      protected
    </p>
    <p>|~1   по умолчанию
    </p>
    <p>fjj    private
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.   Корректен ли следующий код? public class Test { private int id; public Test(int i) {
    </p>
    <p>id=i;
    </p>
    <p>}
    </p>
    <p>public static boolean test(Test t, int id) { return
        t.id==id;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>&#9633;   да, так
        как метод test является элементом
        класса Test
    </p>
    <p>П   нет, так как поле id объявлено как private, а значит
        недоступно извне объекта
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.   Как записывается заголовок метода
        main?
    </p>
    <p>G   public
        int main()
    </p>
    <p>П   public int main(String[] args)
    </p>
    <p>G   public static void main(String[] args)
    </p>
    <p>П   public void main()
    </p>
    <p>
    </p>
    <p>Вариант 2
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>1.      Если
        в классе заводится новый элемент и пока нет
        никаких факторов, позволяющих выбрать тот или иной
        модификатор доступа, какой модификатор следует
        использовать?
    </p>
    <p>О   public
    </p>
    <p>П   protected
    </p>
    <p>Г~!   по умолчанию
    </p>
    <p>&#9633;       private
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.       Если
        метод использует переменную класса, должна ли
        она быть объявлена выше объявления метода?
    </p>
    <p>&#9633;
        да
    </p>
    <p>&#9633;
        нет
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.       Может
        ли измениться содержимое переменной типа
        String, если
        передать ее в качестве аргумента при вызове
        метода?
    </p>
    <p>&#9633;
        да
    </p>
    <p>&#9633;
        нет
    </p>
    <p>Вариант 3
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>1.      Пусть
        класс User описывает пользователя системы.
        В качестве имени используется его e-mail адрес,
        который всем известен, а пароль, конечно, не должен
        быть доступен никому, кроме самого пользователя.
        Корректна ли следующая реализация?
    </p>
    <p>
    </p>
    <p>public class User {
    </p>
    <p>public String login; // e-mail private String password;
        // пароль
    </p>
    <p>}
    </p>
    <p>П   код
        некорректен
    </p>
    <p>f~|   код корректен с точки зрения
        компилятора, но, скорее всего, неверен с позиций ООП; лучше ограничить доступ к
        переменной login с помощью метода getLogin(),
        чтобы значение переменной не могло измениться непредсказуемо
    </p>
    <p>П   код
        полностью верен
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.      Может
        ли класс не иметь ни одного конструктора?
    </p>
    <p>&#9633;  
        да О   нет
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.      Какие заголовки методов
        являются корректными с точки
        зрения компилятора?
    </p>
    <p>П     public void getX()
    </p>
    <p>П     static private int setY()
    </p>
    <p>П     public void static main (String s[])
    </p>
    <p>П     String toString(final int x)
    </p>
    <p>
    </p>
    <center>
    </center>
</div>

</body>
</html>
