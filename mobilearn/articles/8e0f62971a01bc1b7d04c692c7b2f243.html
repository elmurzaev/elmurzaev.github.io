<!DOCTYPE html>
<html>
<head>

    <title>Лекция 8. Объектная модель в Java</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<div class="left">
    <p></p>
    <p></p>
    <center><h2>Лекция 8. Объектная модель в Java</h2></center>
    <p>
    </p>
    <p>
    </p>
    <p>Эта лекция является некоторым отступлением от
        рассмотрения техни­ческих особенностей Java и посвящена в основном изучению ключевых свойств
        объектной модели Java, таких как статические элементы, абстракт­ные методы и
        классы, интерфейсы, являющиеся альтернативой множествен­ного наследования. Без
        этих мощных конструкций язык Java был бы неспо­собен решать серьезные задачи.
    </p>
    <p>В заключение рассматриваются принципы работы
        полиморфизма для нолей н методов, статических и динамических. Уточняется
        классификация типов переменных и типов значений, которые они могут хранить.
    </p>
    <p>
    </p>
    <p>Ключевые слова: предопределение, реализация, интерфейс, "скрывающее"
        объявление.
    </p>
    <p>
    </p>
    <p>Статические элементы
    </p>
    <p>До этого момента под полями объекта мы всегда понимали
        значения, которые имеют смысл только в контексте некоторого экземпляра класса.
        Например:
    </p>
    <p>class Human {
    </p>
    <p>private String name;
    </p>
    <p>}
    </p>
    <p>Прежде, чем обратиться к полю name, необходимо
        получить ссылку на экземпляр класса Human, невозможно узнать
        имя вообще, оно всегда Принадлежит какому-то конкретному человеку.
    </p>
    <p>Но бывают данные и иного характера. Предположим,
        необходимо хранить количество всех людей (экземпляров класса Human, существую-•Чих в
        системе). Понятно, что общее число людей не является характери­стикой какого-то одного
        человека, оно относится ко всему типу в целом, ^сюда
        появляется название "поле класса", в отличие от "поля
        объекта". Объявляются такие поля с помощью модификатора static:
    </p>
    <p>
    </p>
    <p>class Human {
    </p>
    <p>public static int totalCount;
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Чтобы обратиться к такому
        полю, ссылка на объект не требуется, °лне достаточно имени класса:
    </p>
    <p>
    </p>
    <p>Humans.totalCount++; // рождение еще одного человека
    </p>
    <p>
    </p>
    <p>Для удобства разрешено обращаться к статическим полям и через ссылки:
    </p>
    <p>
    </p>
    <p>Human h = new
        Human(); h.totalCount=100;
    </p>
    <p>
    </p>
    <p>Однако такое обращение конвертируется компилятором. Он исполь­зует тип
        ссылки, в данном случае переменная h объявлена как Human, по­этому последняя строка будет
        неявно преобразована в:
    </p>
    <p>
    </p>
    <p>Human. totalCount=100;
    </p>
    <p>
    </p>
    <p>В этом можно убедиться на
        следующем примере:
    </p>
    <p>Human h = null;
        h.totalCount+=10;
    </p>
    <p>
    </p>
    <p>Значение ссылки равно null, но это не имеет значения в силу описан­ной конвертации. Данный
        код
        успешно скомпилируется и корректно ис­полнится. Таким образом, в следующем
        примере
    </p>
    <p>
    </p>
    <p>Human hi - new
        Human(), h2 = new Human();
    </p>
    <p>Human.
        totalCount=5;
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>h1.totalCount++;
    </p>
    <p>System.
        out.println(h2.totalCount);
    </p>
    <p>
    </p>
    <p>все обращения к переменной totalCount приводят к одному
        единственно­му полю, и результатом работы такой программы будет 6. Это поле будет
        существовать в единственном экземпляре независимо от
        того, сколько объектов было порождено от данного класса и был ли вообще создан
        хоть один объект.
    </p>
    <p>Аналогично объявляются
        статические методы.
    </p>
    <p>
    </p>
    <p>class Human {
    </p>
    <p>private static int totalCount;
    </p>
    <p>
    </p>
    <p>public static int getTotalCount() { return
        totalCount;
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>Для вызова статического метода ссылки на объект не требуется. Human. getTotalCountO;
    </p>
    <p>Хотя для удобства обращения через ссылку разрешены, но принима­ется во
        внимание только тип ссылки:
    </p>
    <p>Human h=null;
    </p>
    <p>h. getTotalCountO; //два эквивалентных обращения к Human.getTotalCountO; // одному и тому же
        методу
    </p>
    <p>Хотя приведенный пример технически корректен, все же использо­вание
        ссылки на объект для обращения к статическим полям и методам не рекомендуется,
        поскольку это усложняет код.
    </p>
    <p>Обращение к статическому полю является корректным независимо оттого,
        были ли порождены объекты от этого класса и в каком количестве. Например,
        стартовый метод main() запускается до того, как программа создаст хотя бы один объект.
    </p>
    <p>Кроме полей и методов, статическими могут быть инициализаторы. Они также
        называются инициализаторами класса, в отличие от инициа­лизаторов объекта,
        рассматривавшихся ранее. Их код выполняется один раз во время загрузки класса в
        память виртуальной машины. Их запись начинается с модификатора static:
    </p>
    <p>class Human { static {
    </p>
    <p>System, out. printlnfClass loaded");
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Если объявление статического поля совмещается с его инициализа­цией, то
        поле инициализируется также однократно при загрузке класса. На объявление и
        применение статических полей накладываются те же ог­раничения, что и для
        динамических,— нельзя использовать поле в иници­ализаторах других полей или в
        инициализаторах класса до того, как это Поле объявлено:
    </p>
    <p>
    </p>
    <p>class Test { static int a; static { a=5;
    </p>
    <p>// b=7; // Нельзя использовать до объявления!
    </p>
    <p>}
    </p>
    <p>static int b=a;
    </p>
    <p>}
    </p>
    <p>Это правило распространяется только на обращения к полям по про­стому
        имени. Если использовать составное имя, то обращаться к полю можно будет раньше
        (выше в тексте программы), чем оно будет объявлено:
    </p>
    <p>
    </p>
    <p>class Test {
    </p>
    <p>static int
        b=Test.a; static int a=3; static {
    </p>
    <p>System.out.printlnf'a-'+a+", b="+b);
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Если класс будет загружен в систему, на консоли появится текст: а=3, Ь=0
    </p>
    <p>Видно, что поле b при инициализации получило значение по умол­чанию поля а, т.е. 0. Затем
        полю а было присвоено значение 3.
    </p>
    <p>Статические поля также могут быть объявлены как final, это означает, что
        они должны быть проинициализированы строго один раз и затем уже больше не
        менять своего значения. Аналогично, статические методы могут быть объявлены как
        final, а это означает, что их нельзя перекрывать в классах-наследниках.
    </p>
    <p>Для инициализации статических полей можно пользоваться стати­ческими
        методами и нельзя обращаться к динамическим. Вводят специаль­ные понятия —
        статический и динамический контексты. К статическому контексту относят
        статические методы, статические инициализаторы, инициализаторы статических
        полей. Все остальные части кода имеют ди­намический контекст.
    </p>
    <p>При выполнении кода в динамическом контексте всегда есть объект, с
        которым идет работа в данный момент. Например, для динамического метода это
        объект, у которого он был вызван, и так далее.
    </p>
    <p>Напротив, со статическим контекстом ассоциированных объектов нет.
        Например, как уже указывалось, стартовый метод main() вызывается в тот
        момент, когда ни один объект еще не создан. При обращении к ста­тическому
        методу, например, MyClass.staticMethod(), также может не быть ни одного экземпляра MyClass.
        Обращаться к
        статическим метода' класса Math можно, а создавать его экземпляры нельзя.
    </p>
    <p>А раз нет ассоциированных объектов, то и пользоваться динамичес­кими
        конструкциями нельзя. Можно только ссылаться на статические целя и вызывать
        статические методы. Либо обращаться к объектам через ссылки на них, полученные
        в результате вызова конструктора или в каче­стве аргумента метода и т.п.
    </p>
    <p>class Test {
    </p>
    <p>public void processo { }
    </p>
    <p>public
        static void main(String s[]) {
    </p>
    <p>// process(); - ошибка! у какого объекта его вызывать?
    </p>
    <p>
    </p>
    <p>Test test = new Test();
    </p>
    <p>test.process(); // так правильно
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>Ключевые слова this и super
    </p>
    <p>Эти ключевые слова уже упоминались, рассматривались и некоторые случаи
        их применения. Здесь они будут описаны более подробно.
    </p>
    <p>Если выполнение кода происходит в динамическом контексте, то должен быть
        объект, ассоциированный с ним. В этом случае ключевое слово this возвращает ссылку на данный
        объект:
    </p>
    <p>class Test {
    </p>
    <p>public Object getThis() {
    </p>
    <p>return this; // Проверим, куда указывает эта ссылка
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>}
    </p>
    <p>public static void main(String s[]) { Testt
        = newTest();
    </p>
    <p>System.out.println(t.getThis()==t); // Сравнение
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Результатом работы
        программы будет: true
    </p>
    <p>То есть внутри методов слово this возвращает ссылку на объект, у ко-ТоРого этот метод вызван.
        Оно необходимо, если нужно передать аргумент, РаЬный ссылке на
        данный объект, в какой-нибудь метод.
    </p>
    <p>class Human {
    </p>
    <p>public static void register(Human h) {
    </p>
    <p>System.out.println(h.name+" is registered.");
    </p>
    <p>}
    </p>
    <p>private String name; public Human (String s) { name = s;
    </p>
    <p>register(this); // саморегистрация
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>public static void main(String s[]) { new
        Human("John");
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Результатом будет: John is
        registered.
    </p>
    <p>Другое применение this рассматривалось в
        случае "затемняющих" объявлений:
    </p>
    <p>
    </p>
    <p>class Human {
    </p>
    <p>private
        String name;
    </p>
    <p>
    </p>
    <p>public void setName(String name) { this.name=name;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Слово this можно использовать
        для обращения к полям, которые объявляются ниже:
    </p>
    <p>
    </p>
    <p>class Test {
    </p>
    <p>// int b=a; нельзя обращаться к необъявленному полю! int
        b=this.a; int а=5; {
    </p>
    <p>System.out.println("a="+a+",
        b="+b);
    </p>
    <p>}
    </p>
    <p>public
        static void main(String s[]) {
    </p>
    <p>newTest();
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Результатом работы
        программы будет: а=5,Ь=0
    </p>
    <p>Все происходит так же, как и для статических полей — b получает значение по умолчанию для а,
        т.е. ноль, а затем а
        инициализируется зна­чением 5.
    </p>
    <p>Наконец, слово this применяется в
        конструкторах для явного вызова впервой строке другого конструктора этого же
        класса. Там же может при­меняться и слово super, только уже для
        обращения к конструктору роди­тельского класса.
    </p>
    <p>Другие применения слова super также связаны с
        обращением к роди­тельскому классу объекта. Например, оно может потребоваться в
        случае переопределения (overriding) родительского метода.
    </p>
    <p>Переопределением называют объявление метода, сигнатура которо­го
        совпадает с одним из методов родительского класса.
    </p>
    <p>
    </p>
    <p>class Parent {
    </p>
    <p>public int getValue() { return 5;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>class Child extends Parent { // Переопределение метода public
        int getValue() { return 3;
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>public static void main(String s[]) { Child с = new Child();
    </p>
    <p>// пример вызова переопределенного метода System.our.println(c.getValue());
    </p>
    <p>}
    </p>
    <p>Вызов переопределенного метода использует механизм полимор­физма, который
        подробно рассматривается в конце этой лекции. Однако ясно, что результатом
        выполнения примера будет значение 3.
        Невозможно, используя
        ссылку типа Child, получить из метода getVaue() значение 5, родительский метод перекрыт и
        уже недоступен.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Иногда при переопределении бывает полезно воспользоваться ре­зультатом
        работы родительского метода. Предположим, он делал сложные вычисления, а
        переопределенный метод должен вернуть округленный ре­зультат этих вычислений.
        Понятно, что гораздо удобнее обратиться к роди­тельскому методу, чем заново
        описывать весь алгоритм. Здесь применяется слово super. Из класса
        наследника с его помощью можно обращаться к переопределенным методам родителя:
    </p>
    <p>
    </p>
    <p>class Parent {
    </p>
    <p>public int
        getValue() { return 5;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>class Child
        extends Parent {
    </p>
    <p>
    </p>
    <p>// переопределение метода public int getValue() {
    </p>
    <p>// обращение к методу родителя
    </p>
    <p>return super.getValue()+1;
    </p>
    <p>}
    </p>
    <p>public static void main(String s[]) { Childc =
        newChild(); System.our.println(c.getValue());
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Результатом работы
        программы будет значение 6.
    </p>
    <p>Обращаться с помощью ключевого слова super к переопределенному методу родителя родителя, т.е.
        на два уровня
        наследования вверх, невоз­можно. Если родительский класс переопределил
        функциональность своего родителя, значит, она не будет доступна его наследникам.
    </p>
    <p>Поскольку ключевые слова this и super требуют наличия ассоцииро­ванного объекта, т.е.
        динамического контекста,
        использование их в стати­ческом контексте запрещено.
    </p>
    <p>Ключевое слово abstract
    </p>
    <p>Следующее важное понятие, которое необходимо рассмотреть,— ключевое
        слово abstract.
    </p>
    <p>Иногда имеет смысл описать только заголовок метода, без его тела, Л
        таким образом объявить, что данный метод будет существовать в этом классе.
        Реализацию этого метода, то есть его тело, можно описать позже.
    </p>
    <p>Рассмотрим пример. Предположим, необходимо создать набор гра­фических
        элементов, неважно, каких именно. Например, они могут пред­ставлять собой
        геометрические фигуры - круг, квадрат, звезда и т.д.; или элементы
        пользовательского интерфейса — кнопки, поля ввода и т.д. Сей­час это не имеет
        решающего значения. Кроме того, существует специаль­ный контейнер, который
        занимается их отрисовкой. Понятно, что внеш­ний вид каждой компоненты уникален,
        а значит, соответствующий метод (назовем его paint()) будет
        реализован в разных элементах по-разному.
    </p>
    <p>Но в то же время у компонент может быть много общего. Например, любая из
        них занимает некоторую прямоугольную область контейнера
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Сложные контуры фигуры
        необходимо вписать в прямоугольник, чтобы можно было анализировать перекрытия,
        проверять, не вылезает ли ком­понент за границы контейнера, и т.д. Каждая
        фигура может иметь цвет, которым ее надо рисовать, может быть видимой, или
        невидимой и т.д. Очевидно, что полезно создать родительский класс для всех
        компонент и один раз объявить в нем все общие свойства, чтобы каждая компонента
        лишь наследовала их.
    </p>
    <p>Но как поступить с методом отрисовки? Ведь родительский класс не
        представляет собой какую-либо фигуру, у него нет визуального пред­ставления.
        Можно объявить метод paint() в каждой компоненте незави­симо. Но тогда контейнер должен
        будет
        обладать сложной функциональ­ностью, чтобы анализировать, какая именно
        компонента сейчас обраба­тывается, выполнять приведение типа и только после
        этого вызывать нужный метод.
    </p>
    <p>Именно здесь удобно объявить абстрактный метод в родительском Классе. У
        него нет внешнего вида, но известно, что он есть у каждого на­следника. Поэтому
        заголовок метода описывается в родительском классе, тело метода у каждого
        наследника свое, а контейнер может спокойно Пользоваться только базовым типом,
        не делая никаких приведений.
    </p>
    <p>Приведем упрощенный
        пример:
    </p>
    <p>// Базовая арифметическая
        операция abstract class Operation {
    </p>
    <p>public abstract int calculate(int
        a, int b);
    </p>
    <p>Курс
    </p>
    <p>Программирование
        на Ja^
    </p>
    <p>ПекЦияД
    </p>
    <p>Объектная модель в Java
    </p>
    <p>// Сложение class
        Addition {
    </p>
    <p>public int calculate(int a, int b) { return a+b;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>// Вычитание class
        Subtraction {
    </p>
    <p>public int calculate(int a, int b) { return a-b;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>class Test {
    </p>
    <p>public static
        void main(String s[]) { Operation
        o1 = new Addition(); Operation o2 = new Subtraction();
    </p>
    <p>o1.calculate(2, 3); o2.calculate(3, 5);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Видно, что выполнения операций сложения и вычитания в методе main() записываются
        одинаково.
    </p>
    <p>Обратите внимание - поскольку абстрактный метод не имеет тела, после
        описания его заголовка ставится точка с запятой. А раз у него нет тела, то к
        нему нельзя обращаться, пока его наследники не опишут реали­зацию. Это
        означает, что нельзя создавать экземпляры класса, у которого есть абстрактные
        методы. Такой класс сам объявляется абстрактным.
    </p>
    <p>Класс может быть абстрактным и в том случае, если у него нет абстрактных
        методов, но должен быть абстрактным, если такие методы есть. Разработчик может
        указать ключевое слово abstract в списке
        модификаторов класса, если хочет запретить создание эк­земпляров этого класса
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>
        Классы-наследники должны реализовать (implements) все абстрактные методы (если они есть)
        своего абст­рактного родителя,
        чтобы их можно было объявлять неабстракт­ными и порождать от них экземпляры.
    </p>
    <p>Конечно, класс не может быть одновременно abstract и final. Это же верно и для методов. Кроме
        того, абстрактный метод не может
        быть private, native, static.
    </p>
    <p>Сам класс может без ограничений пользоваться своими абстрактны­ми
        методами.
    </p>
    <p>abstract class
        Test {
    </p>
    <p>public abstract int getX();
        public abstract int getY(); pulic double getLength() {
    </p>
    <p>return
        Math.sqrt(getX()*getX()+getY()*getY());
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Это корректно, поскольку метод getl_ength() может быть
        вызван только у объекта. Объект может быть порожден только от неабстрактного
        класса, который является наследником от Test, и должен был реализовать
        все абстрактные методы.
    </p>
    <p>По этой же причине можно объявлять переменные типа абстрактный класс.
        Они могут иметь значение null или ссылаться на
        объект, порожден­ный от неабстрактного наследника этого класса.
    </p>
    <p>
    </p>
    <p>Интерфейсы
    </p>
    <p>Концепция абстрактных методов позволяет предложить альтернативу
        множественному наследованию. В Java класс может иметь
        только одного родителя, поскольку при множественном наследовании могут
        возникать конфликты, которые запутывают объектную модель. Например, если у класса есть два
        родителя, которые имеют одинаковый метод с различной ре­ализацией, то какой из них
        унаследует новый класс? И как будет работать
        Функциональность родительского класса, который лишился своего метода?
    </p>
    <p>Все эти проблемы не возникают в том случае, если наследуются только абстрактные методы от
        нескольких
        родителей. Даже если унасле­довано несколько одинаковых методов, все равно у них нет
        реализации и Можно один раз описать тело метода, которое будет использоваться при Вызове
        любого из этих методов.
    </p>
    <p>Именно так устроены интерфейсы в Java. От них нельзя
        порождать объекты, но другие классы могут реализовывать их.
    </p>
    <p>
    </p>
    <p>Объявление интерфейсов
    </p>
    <p>Объявление интерфейсов очень похоже на упрощенное объявление Классов.
    </p>
    <p>^ Оно начинается с
        заголовка. Сначала указываются модификаторы. Нтерфейс Может быть объявлен
        как public и тогда он будет
        доступен для °&amp;то использования, либо модификатор доступа может не указываться,
    </p>
    <p>в этом случае интерфейс доступен только для типов своего пакета
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Моди­фикатор
        abstract для интерфейса не требуется, поскольку все интерфейсы являются
        абстрактными. Его можно указать, но делать этого не рекомен­дуется, чтобы не
        загромождать код.
    </p>
    <p>Далее записывается
        ключевое слово interface и имя интерфейса.
    </p>
    <p>После этого может следовать ключевое слово extends и список интер­фейсов,
        от которых будет наследоваться объявляемый интерфейс. Родитель­ских типов может
        быть много, главное, чтобы не было повторений и чтобы отношение наследования не
        образовывало циклической зависимости.
    </p>
    <p>Наследование интерфейсов действительно очень гибкое. Так, если есть два
        интерфейса, А и В, причем В наследуется от А, то новый интер­фейс С может
        наследоваться от них обоих. Впрочем, понятно, что указа­ние наследования от А
        является избыточным, все элементы этого интер­фейса и так будут получены по
        наследству через интерфейс В.
    </p>
    <p>Затем в фигурных скобках
        записывается тело интерфейса.
    </p>
    <p>public interface
        Drawble extends Colorable, Resizable { }
    </p>
    <p>Тело интерфейса состоит из объявления элементов, то есть полей-констант
        и абстрактных методов.
    </p>
    <p>Все поля интерфейса должны быть public final static, так что эти мо­дификаторы указывать
        необязательно и даже нежелательно,
        чтобы не за­громождать код. Поскольку поля объявляются финальными, необходимо
        их сразу инициализировать.
    </p>
    <p>public interface Directions { int RIGTH=1 ; int LETFT=2; int UP=3; int DOWN=4;
    </p>
    <p>}
    </p>
    <p>Все методы интерфейса являются public abstract и эти модификато­ры также необязательны.
    </p>
    <p>public interface Moveable { void
        moveRightO; void moveLeft(); void moveUp(); void moveDown();
    </p>
    <p>}
    </p>
    <p>Как мы видим, описание интерфейса гораздо проще, чем объявление класса.
    </p>
    <p>Реализация
        интерфейса
    </p>
    <p>Каждый класс может реализовывать любые доступные интерфейсы. Цри этом в
        классе должны быть реализованы все абстрактные методы, появившиеся при
        наследовании от интерфейсов или родительского класса, чтобы новый класс мог
        быть объявлен неабстрактным.
    </p>
    <p>Если из разных источников наследуются методы с одинаковой сиг­натурой,
        то достаточно один раз описать реализацию и она будет приме­няться для всех
        этих методов. Однако если у них различное возвращаемое значение, то возникает
        конфликт:
    </p>
    <p>interface А { int getValue();
    </p>
    <p>}
    </p>
    <p>interface В {
    </p>
    <p>double getValue();
    </p>
    <p>}
    </p>
    <p>Если попытаться объявить класс, реализующий оба эти интерфейса, то
        возникнет ошибка компиляции
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> В классе оказывается два разных ме­тода с
        одинаковой сигнатурой, что является неразрешимым конфликтом. Это единственное
        ограничение на набор интерфейсов, которые может ре­ализовывать класс.
    </p>
    <p>Подобный конфликт с
        полями-константами не столь критичен:
    </p>
    <p>
    </p>
    <p>interface А { int value=3;
    </p>
    <p>}
    </p>
    <p>interface В {
    </p>
    <p>double value=5.4;
    </p>
    <p>}
    </p>
    <p>class С implements A, В {
    </p>
    <p>public static void main(String s[]) { Cc = new
        C();
    </p>
    <p>// System.out.println(c.value);
        - ошибка! System.out.println(((A)c).value);
        System.out.println(((B)c).value);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Как видно из примера, обращаться к такому полю через
        сам класс Нельзя, компилятор не сможет понять, какое из двух полей
        нужно ис­
    </p>
    <p>
    </p>
    <p>пользовать. Но можно с помощью явного приведения сослаться на одн0 из
        них.
    </p>
    <p>Итак, если имя интерфейса указано после implements в объявлении
        класса, то класс реализует этот интерфейс. Наследники данного кл также
        реализуют интерфейс, поскольку им достаются по наследству его элементы.
    </p>
    <p>Если интерфейс А наследуется от интерфейса В, а класс реализует А, то
        считается, что интерфейс В также реализуется этим классом по той же причине — все элементы
        передаются по наследству в два этапа — сначала
        интерфейсу А, затем классу.
    </p>
    <p>Наконец, если класс С1 наследуется от класса С2, класс С2 реализует
        интерфейс А1, а интерфейс А1 наследуется от интерфейса А2, то класс С1 также
        реализует интерфейс А2.
    </p>
    <p>Все это позволяет утверждать, что переменные типа интерфейс так­же
        допустимы. Они могут иметь значение null, или ссылаться на
        объекты, порожденные от классов, реализующих этот интерфейс. Поскольку объ­екты
        порождаются только от классов, а все они наследуются от Object, это означает, что
        значения типа интерфейс обладают всеми элементами класса Object.
    </p>
    <p>
    </p>
    <p>Применение
        интерфейсов
    </p>
    <p>До сих пор интерфейсы рассматривались с технической точки зрения — как
        их объявлять, какие конфликты могут возникать, как их разрешать. Однако важно
        понимать, как применяются интерфейсы с концептуальной точки зрения.
    </p>
    <p>Распространенное мнение, что интерфейс — это полностью абстракт­ный
        класс, в целом верно, но оно не отражает всех преимуществ, которые дают
        интерфейсы объектной модели. Как уже отмечалось, множествен­ное наследование
        порождает ряд конфликтов, но отказ от него, хоть и де­лает язык проще, но не
        устраняет ситуации, в которых требуются подобные подходы.
    </p>
    <p>Возьмем в качестве примера дерева наследования классификацию живых
        организмов
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Известно, что растения и животные принадлежат к разным царствам.
        Основным различием между ними является то, что рас­тения поглощают
        неорганические элементы, а животные питаются органи­ческими веществами.
        Животные делятся на две большие группы — птицы и млекопитающие. Предположим,
        что на основе этой классификации пост­роено дерево наследования, в каждом
        классе определены элементы с учетом наследования от родительских классов.
    </p>
    <p>Рассмотрим такое свойство живого организма, как способность пи­таться
        насекомыми. Очевидно, что это свойство нельзя приписать всей
    </p>
    <p>^К1дИя
        8____________________________________________ Объектная модель в Java
    </p>
    <p>             _
    </p>
    <p>группе птиц, или млекопитающих, а тем более растений. Но существуют
        ^дставители каждой из названных групп, которые этим свойством обла­дают, - для
        растений это росянка, для птиц, например, ласточки, а для мле­копитающих -
        муравьеды. Причем, очевидно, "реализовано" это свойство у каждого
        вида совсем по-разному.
    </p>
    <p>Можно было бы объявить соответствующий метод (скажем, consumelnsect(lnsect))
        у каждого представителя
        независимо. Но если за­дача состоит в моделировании, например, зоопарка, то
        однотипную про­цедуру _ кормление насекомыми - пришлось бы описывать
        для каждого вида отдельно, что существенно осложнило бы код, причем без
        какой-либо пользы.
    </p>
    <p>Java предлагает другое решение. Объявляется интерфейс InsectConsumer:
    </p>
    <p>public interface InsectConsumer { void
        consumelnsect(lnsect i);
    </p>
    <p>}
    </p>
    <p>Его реализуют все подходящие животные и растения:
    </p>
    <p>
    </p>
    <p>// росянка расширяет класс растение
    </p>
    <p>public class Sundew extends Plant implements
        InsectConsumer { public void consumelnsect(lnsect i) {
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>// ласточка расширяет класс птица
    </p>
    <p>public class Swallow extends Bird implements
        InsectConsumer { public void consumelnsect(lnsect i) {
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>// муравьед расширяет класс млекопитающее public class AntEater extends Mammal implements
        InsectConsumer {
    </p>
    <p>public void
        consumelnsect(lnsect i) {
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>В результате в классе, моделирующем служащего зоопарка, можно объявить
        соответствующий метод:
    </p>
    <p>
    </p>
    <p>// служащий, отвечающий за кормление, расширяет класс служащий class FeedWorker extends
        Worker {
    </p>
    <p>
    </p>
    <p>// с помощью этого метода можно накормить
    </p>
    <p>// и росянку, и ласточку, и муравьеда
    </p>
    <p>public void feedOnlnsects(lnsectConsumer consumer) {
    </p>
    <p>
    </p>
    <p>consumer.consumelnsect(insect);
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>В результате удалось свести работу с одним свойством
        трех разнород­ных классов в одно место, сделать код более универсальным.
        Обратите внимание, что при добавлении еще одного насекомоядного такая модель
        зоопарка не потребует никаких изменений, чтобы обслуживать новый вид, в отличие
        от первоначального громоздкого решения. Благодаря введению интерфейса удалось
        отделить классы, реализующие его (живые организ­мы) и использующие его
        (служащий зоопарка). После любых изменений этих классов при условии сохранения
        интерфейса их взаимодействие не нарушится.
    </p>
    <p>Данный пример иллюстрирует, как интерфейсы предоставляют аль­тернативный,
        более строгий и гибкий подход вместо множественного на­следования.
    </p>
    <p>
    </p>
    <p>Полиморфизм
    </p>
    <p>Ранее были рассмотрены правила объявления классов с учетом их
        наследования. В этой лекции было введено понятие переопределенного метода.
        Однако полиморфизм требует более глубокого изучения. При объявлении одноименных
        полей или методов с совпадающими сигнату­рами происходит перекрытие элементов
        из родительского и наследую­щего класса. Рассмотрим, как функционируют классы и
        объекты в таких ситуациях.
    </p>
    <p>
    </p>
    <p>Поля
    </p>
    <p>Начнем с полей, которые могут быть статическими или динамичес­кими.
        Рассмотрим пример:
    </p>
    <p>class Parent { int a=2;
    </p>
    <p>}
    </p>
    <p>class Child extends Parent { int a=3;
    </p>
    <p>}
    </p>
    <p>Прежде всего, нужно сказать, что такое объявление корректно. На­следники
        могут объявлять поля с любыми именами, даже совпадающими с родительскими.
        Затем, необходимо понять, как два одноименных поля будут сосуществовать.
        Действительно, объекты класса Child будут содер­жать
        сразу две переменных, а поскольку они могут отличаться не только значением, но
        и типом (ведь это два независимых поля), именно компи­лятор будет определять,
        какое из значений использовать. Компилятор может опираться только на тип
        ссылки, с помощью которой происходит обращение к полю:
    </p>
    <p>Child с = new Child(); System.out.println(c.а); Parent p = с; System.out.println(p.a);
    </p>
    <p>Обе ссылки указывают на один и тот же объект,
        порожденный от класса Child, но одна из них имеет такой же тип, а другая - Parent. Отсюда
        следуют и
        результаты:
    </p>
    <p>3 2
    </p>
    <p>Объявление поля в классе-наследнике "скрыло" родительское
        поле. Данное объявление так и называется — "скрывающим" (hiding). Это осо­бый случай
        перекрытия областей
        видимости, отличный от &amp;quot
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>затеняющего" (shadowing) и "заслоняющего" (obscuring) объявлений. Тем не менее, ро­дительское
        поле продолжает существовать.
        К нему можно обратиться и явно:
    </p>
    <p>
    </p>
    <p>class Child
        extends Parent {
    </p>
    <p>int a=3; // скрывающее объявление
    </p>
    <p>int
        b=((Parent)this).a; // более громоздкое
        объявление
    </p>
    <p>int c=super.a; // более простое
    </p>
    <p>Переменные b и с получат
        значение, хранящееся в родительском по­ле а. Хотя выражение с super более простое, оно не
        позволит обратиться на два уровня вверх по дереву
        наследования. А ведь вполне возможно, что в родительском классе это поле также
        было скрывающим и в родителе ро­дителя хранится еще одно значение. К нему можно
        обратиться явным приведением, как это делается для Ь.
    </p>
    <p>Рассмотрим следующий
        пример:
    </p>
    <p>class Parent { int х=0;
    </p>
    <p>public void
        printXQ { System.out.println(x);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>class Child extends Parent { int x=-1;
    </p>
    <p>}
    </p>
    <p>Каков будет
        результат следующих строк? newChild().printX();
    </p>
    <p>Значение какого поля будет распечатано? Метод вызывается с помо­щью
        ссылки типа Child, но это не сыграет никакой роли. Вызывается метод, определенный в
        классе Parent, и компилятор, конечно, расценил обращение к полю х в этом методе
        именно как к полю класса Parent. Поэтому результа­том будет 0.
    </p>
    <p>Перейдем к статическим
        полям. На самом деле, для них проблем и конфликтов, связанных с полиморфизмом,
        не существует. Рассмотрим пример:
    </p>
    <p>class Parent { static int a=2;
    </p>
    <p>}
    </p>
    <p>class Child extends Parent { static int a=3;
    </p>
    <p>}
    </p>
    <p>Каков будет результат
        следующих строк?
    </p>
    <p>Child с = new Child(); System.out.println(c.а); Parent p = c;
        System.out.println(p.a);
    </p>
    <p>Нужно вспомнить, как компилятор обрабатывает обращения к ста-^еским
        полям через ссылочные значения. Неважно, на какой объект указывает ссылка.
        Более того, она может быть даже равна null. Все опре­деляется
        типом ссылки.
    </p>
    <p>Поэтому рассматриваемый
        пример эквивалентен:
    </p>
    <p>Systems. out.println(Child. а) Systems. out.println(Parent.a)
    </p>
    <p>
    </p>
    <p>А его результат сомнений уже не вызывает:
    </p>
    <p>
    </p>
    <p>3 2
    </p>
    <p>Можно привести следующее пояснение. Статическое поле принад­лежит
        классу, а не объекту. В результате появление классов-наследников со скрывающими
        (hiding) объявлениями никак не сказывается на работе с исходным полем.
        Компилятор всегда может определить, через ссылку какого типа происходит
        обращение к нему.
    </p>
    <p>Обратите внимание на
        следующий пример:
    </p>
    <p>
    </p>
    <p>class
        Parent { static int a;
    </p>
    <p>}
    </p>
    <p>class Child extends Parent { }
    </p>
    <p>Каков будет результат следующих строк?
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>Child.а=10; Parent. а=5;
    </p>
    <p>System.
        out.println(Child. а);
    </p>
    <p>В этом примере поле а не было скрыто и передалось по наследству классу Child. Однако
        результат
        показывает, что это все же одно поле:
    </p>
    <p>
    </p>
    <p>5
    </p>
    <p>Несмотря на то, что к полю класса идут обращения через разные классы,
        переменная всего одна.
    </p>
    <p>Итак, наследники могут объявлять поля с именами, совпадающими с
        Родительскими полями. Такие объявления называют скрывающими.
    </p>
    <p>261
    </p>
    <p>При этом объекты
        будут содержать оба значения, а компилятор будет каждый раз определять, с каким
        из них надо работать.
    </p>
    <p>
    </p>
    <p>Методы
    </p>
    <p>Рассмотрим случай переопределения (overriding) методов:
    </p>
    <p>class Parent {
    </p>
    <p>public int getValue() { return 0;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>class Child extends Parent { public int getValue()
        { return 1;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>И строки, демонстрирующие работу с этими методами:
    </p>
    <p>Child с = new Child();
    </p>
    <p>System.out.println(c.getValue());
    </p>
    <p>Parent p = c;
    </p>
    <p>System.out.println(p.getValue());
    </p>
    <p>Результатом будет:
    </p>
    <p>1 1
    </p>
    <p>
    </p>
    <p>Можно видеть, что родительский метод полностью перекрыт, значе­ние 0
        никак нельзя получить через ссылку, указывающую на объект класса Child. В этом ключевая
        особенность полиморфизма — наследники могут изменять родительское поведение,
        даже если обращение к ним произво­дится по ссылке родительского типа. Напомним,
        что, хотя старый метод снаружи уже недоступен, внутри класса-наследника к нему
        все же можно обратиться с помощью super.
    </p>
    <p>Рассмотрим более сложный пример:
    </p>
    <p>class Parent {
    </p>
    <p>public int getValue() { return 0;
    </p>
    <p>public void print() {
    </p>
    <p>System, out. println(getValue());
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>class Child extends Parent { public int getValue() { return
        1;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Что появится на консоли после выполнения следующих строк?
    </p>
    <p>
    </p>
    <p>Parent р = new Child();
        p.print();
    </p>
    <p>
    </p>
    <p>С помощью ссылки типа Parent вызывается метод print(), объявлен­ный в
        классе Parent. Из этого метода делается обращение к getValue(), которое в
        классе Parent возвращает 0. Но
        компилятор уже не может пред­сказать, к динамическому методу какого класса
        произойдет обращение во время работы программы. Это определяет виртуальная
        машина на основе объекта, на который указывает ссылка. И раз этот объект
        порожден от Child, то существует лишь один метод getValue().
    </p>
    <p>Результатом работы примера будет:
    </p>
    <p>
    </p>
    <p>1
    </p>
    <p>
    </p>
    <p>Данный пример демонстрирует, что переопределение методов долж­но
        производиться с осторожностью. Если слишком сильно изменить логи­ку их работы,
        нарушить принятые соглашения (например,
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>начать возвра­щать null в качестве значения ссылочного типа, если родительский метод такого
        не
        допускал), это может привести к сбоям в работе родительского класса, а значит,
        объекта наследника. Более того, существуют и некоторые обязательные
        ограничения.
    </p>
    <p>Вспомним, что заголовок метода состоит из модификаторов, воз-вРащаемого
        значения, сигнатуры и throws-выражения. Сигнатура (имя и набор аргументов) остается
        неизменной, если
        говорить о пере­определении. Возвращаемое значение также не может меняться,
        ина-Че это приведет к появлению двух разных методов с одинаковыми
        сиг-Натурами.
    </p>
    <p>Рассмотрим модификаторы доступа.
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>class Parent {
    </p>
    <p>protected int getValueO { return 0;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>class Child
        extends Parent {
    </p>
    <p>/* ??? 7 protected int getValueO { return 1;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Пусть родительский метод был объявлен как protected.
        Понято, что метод
        наследника можно оставить с таким же уровнем доступа, но можно ли его расширить
        (public), или сузить (доступ по умолчанию)? Несколько строк для проверки:
    </p>
    <p>
    </p>
    <p>Parent р = new Child(); p.getValue();
    </p>
    <p>
    </p>
    <p>Обращение к методу осуществляется с помощью ссылки типа Parent. Именно компилятор
        выполняет проверку уровня доступа, и он будет ори­ентироваться на родительский
        класс. Но ссылка-то указывает на объект, порожденный от Child, и по правилам
        полиморфизма исполняться будет метод именно этого класса. А значит, доступ к
        переопределенному методу не может быть более ограниченным, чем к исходному.
        Итак, методы с до­ступом по умолчанию можно переопределять с таким же доступом,
        либо protected или public. Protected-методы переопределяются такими же, или public, а для
        public менять модификатор доступа и вовсе нельзя.
    </p>
    <p>Что касается private-методов, то они определены только внутри класса, снаружи не видны, а
        потому наследники могут без ограничений объявлять методы с такими же
        сигнатурами и произвольными возвраща­емыми значениями, модификаторами доступа и
        т.д.
    </p>
    <p>Аналогичные ограничения накладываются и на throws-выражение, которое
        будет рассмотрено в следующих лекциях.
    </p>
    <p>Если абстрактный метод переопределяется неабстрактным, то гово­рят, что
        он его реализовал (implements). Как ни странно, абстрактный ме­тод может переопределить
        другой
        абстрактный, или даже неабстрактный, метод. В первом случае такое действие
        может иметь смысл только при из­менении модификатора доступа (расширении), либо
        throws-выражения. Во втором случае полностью утрачивается старая реализация
        метода, что может потребоваться в особенных случаях.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Объектная
        модель в Java
    </p>
    <p>-- _                  —  -        —--
    </p>
    <p>Перейдем к статическим методам. Рассмотрим пример:
    </p>
    <p>
    </p>
    <p>class Parent {
    </p>
    <p>static public int getValue() { return 0;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>class Child extends Parent { static public
        int getValue() { return 1;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>И строки, демонстрирующие работу с этими методами:
    </p>
    <p>
    </p>
    <p>Child с = new Child();
    </p>
    <p>System.out.println(c.getValue());
    </p>
    <p>Parent p = c;
    </p>
    <p>System. out.println(p.getValue());
    </p>
    <p>Аналогично случаю со статическими переменными, вспоминаем ал­горитм
        обработки компилятором таких обращений к статическим элемен­там и получаем, что
        код эквивалентен следующим строкам:
    </p>
    <p>System.
        out.println(Child.getValue()); System.out.println(Parent.getValue());
    </p>
    <p>
    </p>
    <p>Результатом будет:
    </p>
    <p>
    </p>
    <p>1 О
    </p>
    <p>То есть статические методы, подобно статическим полям, принадле­жат
        классу и появление наследников на них не сказывается.
    </p>
    <p>Статические методы не могут перекрывать обычные, и наоборот.
    </p>
    <p>
    </p>
    <p>Полиморфизм и объекты
    </p>
    <p>В заключение рассмотрим несколько особенностей,
        вытекающих из свойств полиморфизма.
    </p>
    <p>Во-первых, теперь можно точно сформулировать, что является элемен. тами
        ссылочного типа. Ссылочный тип обладает следующими элементами:
    </p>
    <p>•
        непосредственно
        объявленными в его теле;
    </p>
    <p>•
        объявленными в его
        родительском классе и реализуемых интер. фейсах, кроме:
    </p>
    <p>
    </p>
    <p>-
        private-элементов;
    </p>
    <p>-
        "скрытых" элементов
        (полей и статических методов, скрытых одноименными элементами);
    </p>
    <p>-
        переопределенных
        (динамических) методов.
    </p>
    <p>Во-вторых, продолжим рассматривать взаимосвязь типа переменной и типов
        ее возможных значений. К случаям, описанным в предыдущей лекции, добавляются
        еще два. Переменная типа абстрактный класс может ссылаться на объекты,
        порожденные неабстрактным наследником этого класса. Переменная типа интерфейс
        может ссылаться на объекты, по­рожденные от класса, реализующего данный
        интерфейс.
    </p>
    <p>Сведем эти данные в таблицу.
    </p>
    <p></p>
    <center><img height="267" src="http://kufas.ru/java.files/image015.png" width="430"></center>
    Таким образом, Java предоставляет гибкую и мощную модель объек­тов, позволяющую
    проектировать самые сложные системы. Необходимо хорошо разбираться в ее
    основных свойствах и механизмах — наследова­ние, статические элементы,
    абстрактные элементы, интерфейсы, поли­морфизм, разграничения доступа и другие.
    Все они позволяют избегать дублирующего кода, облегчают
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>развитие системы,
        добавление новых воз­можностей и изменение старых, помогают обеспечивать
        минимальную связность между частями системы, то есть повышают модульность.
        Также
    </p>
    <p>ia4Hbie технические решения можно многократно использовать в раз­личных
        системах, сокращая и упрощая процесс их создания.
    </p>
    <p>Для достижения таких важных целей требуется не только знание java, но и владение
        объектно-ориентированным подходом, основными способами проектирования систем и
        проверки качества архитектурных решений. Платформа Java является основой и весьма удобным
        инстру­ментом для применения всех этих
        технологий.
    </p>
    <p>Заключение
    </p>
    <p>В этой лекции были рассмотрены особенности объектной модели java. Это, во-первых,
        статические элементы, позволяющие использовать интерфейс класса без создания
        объектов. Нужно помнить, что, хотя дтя об­ращения к статическим элементам можно
        задействовать ссылочную пере­менную, на самом деле ее значение не используется,
        компилятор основыва­ется только на ее типе.
    </p>
    <p>Для правильной работы со статическими элементами вводятся по­нятия
        статического и динамического контекста.
    </p>
    <p>Далее рассматривалось использование ключевых слов this и super. Выражение this предоставляет
        ссылку,
        указывающую на объект, в контек­сте которого оно встречается. Эта конструкция
        помогает избегать кон­фликтов имен, а также применяется в конструкторах.
    </p>
    <p>Слово super позволяет задействовать свойства родительского клас­са, что необходимо
        для реализации переопределенных методов, а также в конструкторах.
    </p>
    <p>Затем было введено понятие абстрактного метода и класса. Абст­рактный
        метод не имеет тела, он лишь указывает, что метод с такой сигнатурой должен
        быть реализован в классе-наследнике. Поскольку °Я не имеет собственной реализации, классы с
        абстрактными метода-Ми также должны быть объявлены с модификатором abstract, который
        Указывает, что от них нельзя порождать объекты. Основная цель абст­рактных
        методов — описать в родительском классе как можно больше °бщих свойств
        наследников, пусть даже и в виде заголовков методов без реализации.
    </p>
    <p>Следующее важное
        понятие — особый тип в Java, интерфейс. Его еЩе называют полностью абстрактным классом,
        так как все его методы °бязательно абстрактные, а поля final static. Соответственно,
        на основе "^ерфейсов невозможно создавать объекты.
    </p>
    <p>Интерфейсы являются
        альтернативой множественному наследова-Классы не могут иметь более одного
        родителя, но они могут реали-&#9632;^Вывать сколько угодно интерфейсов. Таким
        образом, интерфейсы опи­
    </p>
    <p>сывают общие свойства
        классов, не находящихся на одной ветви дерев-
        наследования.                                                                                                                        
        '
    </p>
    <p>Наконец, важным свойством объектной модели является полимор. физм. Было
        подробно изучено поведение полей и методов, как статичес ких, так и
        динамических, при переопределении. Что позволило перейти к вопросу
        соответствия типов переменной и ее значения.
    </p>
    <p>Вариант
        1
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>^   
        Предположим, вы моделируете автомобиль, описывая его свойства в формате Java-класса. Какие
        из следующих
        полей нужно объявить динамическими?
    </p>
    <p>Г*1   количество колес автомобиля
    </p>
    <p>Г*1   необходимое количество колес,
        полагающееся по проектной документации
    </p>
    <p>Q   максимально
        допустимая масса для этого класса автомобилей
    </p>
    <p>f*l   максимально большое количество
        пассажиров, когда-либо одновременно перевозимых автомобилем
    </p>
    <p>&#9633; дата
        начала выпуска автомобилей
    </p>
    <p>&#9633; дата
        выпуска автомобиля
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.      Можно
        ли при переопределении некоторого абстрактного
        метода perforino использовать
        выражение
    </p>
    <p>super, perforino?
    </p>
    <p>&#9633;      да
        П    нет
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.      Для
        каких элементов класса работает полиморфизм?
    </p>
    <p>Г~1  динамические
        поля
    </p>
    <p>П    статические
        поля
    </p>
    <p>П    динамические
        методы
    </p>
    <p>П    статические
        методы
    </p>
    <p>Вариант 2
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>1.       Предположим,
        вы моделируете автомобиль, описывая его
        свойства в формате Java-класса. Какие из следующих
        полей нужно объявить статическими?
    </p>
    <p>П   количество
        колес автомобиля
    </p>
    <p>П   необходимое
        количество колес, полагающееся по проектной документации
    </p>
    <p>П   максимально
        допустимая масса для этого класса автомобилей
    </p>
    <p>П   максимально
        большое количество пассажиров, когда-либо одновременно перевозимых автомобилем
    </p>
    <p>П   дата
        начала выпуска автомобилей
    </p>
    <p>П   дата
        выпуска автомобиля
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.       Можно
        ли при наследовании не реализовывать
        абстрактный метод родительского класса?
    </p>
    <p>П   можно
    </p>
    <p>П   можно, если наследник также abstract П   нельзя
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.       Может
        ли переменная иметь тип абстрактный класс?
        Интерфейс?
    </p>
    <p>&#9633;
        да, да
    </p>
    <p>&#9633;
        да, нет
    </p>
    <p>&#9633;
        нет, да
    </p>
    <p>&#9633;
        нет, нет
    </p>
    <p>Вариант 3
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>1    Корректно ли следующее
        обращение к переменной X? public class Test {
    </p>
    <p>static void performO
        {
    </p>
    <p>
    </p>
    <p>}
    </p>
    <p>private Test x;
    </p>
    <p>public static void ma in (String s[]) {
    </p>
    <p>x.perform();
        // корректно ли это выражение?
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>&#9633; да
    </p>
    <p>&#9633; нет
    </p>
    <p>
    </p>
    <p>2.   Если имеется переменная типа абстрактный
        класс, можно ли с ее помощью обращаться к
        абстрактным методам этого класса?
    </p>
    <p>П   можно
    </p>
    <p>Г"|  
        можно, но если ее значение будет равно null, то возникнет
    </p>
    <p>ошибка времени исполнения О   нельзя
    </p>
    <p>Какое значение появится на
        консоли после выполнения следующей программы? public class Parent { int x =
        2;
    </p>
    <p>public void print() {
    </p>
    <p>System. out.
        println(x) ;
    </p>
    <p>}
    </p>
    <p>public class Child
        extends Parent { intx = 3;
    </p>
    <p>public static void main(String s[]) {
        ^              new Child().print();
    </p>
    <p>}
    </p>
    <p>&#9633;
        0
    </p>
    <p>&#9633;
        2
    </p>
    <p>&#9633;
        3
    </p>
    <p>
    </p>
    <center>
    </center>
</div>

</body>
</html>
