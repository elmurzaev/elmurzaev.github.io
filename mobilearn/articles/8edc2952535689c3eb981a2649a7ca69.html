<!DOCTYPE html>
<html>
<head>

    <title> Лекция 4. Ввод/вывод</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<section id="l4_1">
    <h1> 1. «Классический» ввод/вывод </h1>
    <p>
        В языке С определены три стандартных потока ввода/вывода:
    </p>
    <ol>
        <li>
            <span class="sint">stdin</span>      – стандартное устройство ввода (клавиатура);
        </li>
        <li>
            <span class="sint">stdout</span>   – стандартное устройство вывода (экран);
        </li>
        <li>
            <span class="sint">stderr</span>    – стандартное устройство вывода сообщения об ошибках
            (также экран).
        </li>
    </ol>
    <p>
        Простейший ввод/вывод:
    </p>
    <ul>
        <li><span class="sint">getch()</span> – ввод одного символа без отображения его на экране;
        </li>
        <li><span class="sint">getche()</span> – ввод одного символа с отображением его на экране;
        </li>
        <li><span class="sint">putchar(<i>int</i> c)</span> – вывод одного символа на экран.
        </li>
    </ul>
    <p>
        Все эти функции требуют включения заголовочного файла <span
            class="sint">&lt;conio.h&gt;</span>.
    </p>
    <p>
        Все остальные функции ввода/вывода определены в заголовочном файле <span class="sint">&lt;stdio.h&gt;</span>.
    </p>
    <h2 id="l4_1_1">1.1. Ввод/вывод с экрана</h2>
    <p>
        Для ввода и вывода на экран используются функции <i>scanf</i> и <i>printf</i>
        соответственно, прототипы которых имеют следующий вид:
        <span class="sint">
<span class="type">int</span> <span class="fun">scanf</span> (<span class="type">char</span> *<var>format</var>, ...);
<span class="type">int</span> <span class="fun">printf</span>(<span class="type">char</span> *<var>format</var>, ...);
</span>
    </p>
    <p>
        Вывод осуществляется функцией <i>printf</i>, которая имеет следующий синтаксис:
        <span class="sint">
<b>printf</b>(<i>&lt;строка описания форматов&gt;</i> [, <i>&lt;список вывода&gt;</i>]);</span>
    </p>
    <p>
        <i>Строка описания форматов</i> состоит из обычных символов, специальных <i></i> символов и
        <i></i>.
    </p>
    <p>
        Обычные символы и управляющие последовательности просто копируются в стандартный выходной
        поток в порядке их появления.
    </p>
    <p>
        Спецификации формата начинаются с символа <b>%</b> и заканчиваются символом, определяющим
        тип выводимого значения. Кроме того, спецификации формата могут содержать символы и цифры
        для управления видом выводимого значения (подробно см. ). <i>Список вывода</i> состоит из
        переменных и/или констант, значения которых должны быть выведены. <b>Количество спецификаций
        формата должно быть равно количеству выводимых значений, которые указываются в <i>списке
            вывода</i>.</b> Если это условие не будет соблюдаться, выполнение функции может привести
        к непредсказуемым результатам.
    </p>
    <p>
        Ввод осуществляется функцией <i>scanf</i>, которая имеет следующий синтаксис:
        <span class="sint">
<b>scanf</b>(<i>&lt;строка описания форматов&gt;</i> [, <i>&lt;список ввода&gt;</i>]);</span>
    </p>
    <p>
        <i>Строка описания форматов</i> состоит из набора спецификаций формата, таких же, как для
        функции <i>printf</i>. <i>Список ввода</i> состоит из <b>адресов</b> переменных, куда будут
        заноситься вводимые значения. Адрес переменной вычисляется с помощью . Количество
        спецификаций формата должно быть равно количеству вводимых значений, которые указываются в
        <i>списке ввода</i>.
    </p>
    <p>
        Функция <i>scanf</i> возвращает количество успешно введенных и преобразованных значений.
        Функция <i>printf</i> возвращает количество символов, записанных в выходной поток.
    </p>
    <p id="l4_escape">
        К управляющим последовательностям относятся следующие последовательности символов.
    </p>
    <table>
        <tr>
            <th>
                Последовательность
            </th>
            <th>
                Дейcтвие
            </th>

        </tr>
        <tr>
            <td>
                <b>\a</b>
            </td>
            <td>
                Звуковой сигнал
            </td>
        </tr>
        <tr>
            <td>
                <b>\b</b>
            </td>
            <td>
                Удаление предыдущего символа
            </td>
        </tr>
        <tr>
            <td>
                <b>\n</b>
            </td>
            <td>
                Новая строка
            </td>
        </tr>
        <tr>
            <td>
                <b>\r</b>
            </td>
            <td>
                Возврат каретки
            </td>
        </tr>
        <tr>
            <td>
                <b>\t</b>
            </td>
            <td>
                Табуляция
            </td>
        </tr>
        <tr>
            <td>
                <b>\'</b>
            </td>
            <td>
                Апостроф
            </td>
        </tr>
        <tr>
            <td>
                <b>\"</b>
            </td>
            <td>
                Кавычки
            </td>
        </tr>
        <tr>
            <td>
                <b>\\</b>
            </td>
            <td>
                Обратный слеш
            </td>
        </tr>
        <tr>
            <td>
                <b>\</b><i>ooo</i>
            </td>
            <td>
                ASCII символ в восьмеричной нотации
            </td>
        </tr>
        <tr>
            <td>
                <b>\x</b><i>ooo</i>
            </td>
            <td>
                ASCII символ в шестнадцатеричной нотации
            </td>
        </tr>
    </table>
    <p id="l4_format">
        <i>Спецификация формата</i>, которая состоит из обязательных и необязательных полей, имеет
        следующий вид:
        <span class="sint">
%[<i></i>]
 [<i></i>]
 [<i></i>]
 []
 <i></i>
</span>
    </p>
    <table id="l4_bandiere">
        <tr>
            <th>
                Флаги
            </th>
            <th>
                Значение
            </th>
            <th>
                По умолчанию
            </th>
        </tr>
        <tr>
            <td>
                –
            </td>
            <td>
                Выравнивание по левому краю.
            </td>
            <td>
                Выравнивание по правому краю.
            </td>
        </tr>
        <tr>
            <td>
                +
            </td>
            <td>
                Добавление знака + или – перед числами.
            </td>
            <td>
                Знак добавляется только перед отрицательными числами.
            </td>
        </tr>
        <tr>
            <td>
                0
            </td>
            <td>
                Добавление нулей перед выводимым значением. Если одновременно используются флаги – и
                0, 0 игнорируется.
            </td>
            <td>
                Добавление пробелов.
            </td>
        </tr>
        <tr>
            <td>
                пробел
            </td>
            <td>
                Добавление пробела перед положительным числом. Если одновременно используются флаги
                пробел и +, пробел игнорируется.
            </td>
            <td>
                Пробел не добавляется.
            </td>
        </tr>
        <tr>
            <td rowspan="4">
                #
            </td>
            <td>
                Добавление символов 0, 0х или 0Х перед ненулевым значением, если флаг # используется
                с форматами о, х или Х соответственно.
            </td>
            <td>
                Символы 0, 0х и 0Х не добавляются.
            </td>
        </tr>
        <tr>
            <td>
                При использовании с форматами e, E и f флага # выводимое число будет содержать
                десятичную точку в любом случае.
            </td>
            <td>
                Десятичная точка добавляется, только если за ней следуют цифры.
            </td>
        </tr>
        <tr>
            <td>
                При использовании с форматами g и G флага # выводимое число будет содержать
                десятичную точку и хвостовые нули в любом случае.
            </td>
            <td>
                Десятичная точка добавляется, только если за ней следуют цифры. Хвостовые нули не
                выводятся.
            </td>
        </tr>
        <tr>
            <td>
                Игнорируется при использовании с форматами c, d, i, u и s.
            </td>
            <td>
                 
            </td>
        </tr>
    </table>

    <p id="l4_larghezza">
        Поле <i>ширина</i> содержит минимальное количество выводимых символов – неотрицательное
        целое число. Если выводимое значение содержит меньше символов, то оно расширяется пробелами
        (если не задан флаг <b>0</b>). Если поле ширина содержит звездочку (*), то в качестве
        значения поля берётся целое число из списка аргументов, предшествующее выводимому значению.
    </p>
    <p id="l4_accuratezza">
        Поле <i>точность</i> также представляет собой неотрицательное целое число. Действие зависит
        от выводимого значения.
    </p>
    <table>
        <tr>
            <th>
                Тип
            </th>
            <th>
                Действие
            </th>
            <th>
                По умолчанию
            </th>
        </tr>
        <tr>
            <td>
                <b>c, C</b>
            </td>
            <td>
                Точность не имеет эффекта.
            </td>
            <td>
                Выводится символ.
            </td>
        </tr>
        <tr>
            <td>
                <b>d, i, u, o, x, X</b>
            </td>
            <td>
                Точность задаёт минимальное количество символов, которые будут напечатаны. Если
                число содержит меньше символов, оно расширяется нулями.
            </td>
            <td>
                Точность равна 1.
            </td>
        </tr>
        <tr>
            <td>
                <b>e, E, f</b>
            </td>
            <td>
                Точность задаёт количество символов после десятичной точки. Число округляется.
            </td>
            <td>
                Точность равна 6. Если точность равна 0 или опущена, десятичная точка не выводится.
            </td>
        </tr>
        <tr>
            <td>
                <b>g, G</b>
            </td>
            <td>
                Точность задаёт максимальное количество значащих цифр.
            </td>
            <td>
                Печатается 6 значащих цифр.
            </td>
        </tr>
        <tr>
            <td>
                <b>s, S</b>
            </td>
            <td>
                Точность задаёт максимальное количество выводимых символов.
            </td>
            <td>
                Выводятся все символы строки.
            </td>
        </tr>
    </table>
    <p>
        Если поле <i>точность</i> содержит звездочку (*), то в качестве значения поля берётся целое
        число из списка аргументов, предшествующее выводимому значению.
    </p>
    <p id="l4_hli64">
        Дополнительные префиксы <b>h</b>, <b>l</b>, <b>L</b> и <b>I64</b> задают «размер» аргумента
        – <i>long</i> или <i>short</i>, однобайтовый символ или расширенный символ, в зависимости от
        спецификации типа, которую они модифицируют.
    </p>
    <p id="l4_tipi">
        Обязательное поле <i>тип</i> задаёт тип выводимого значения.
    </p>
    <table>
        <tr>
            <th>
                Символ
            </th>
            <th>
                Тип
            </th>
            <th>
                Формат вывода
            </th>
        </tr>
        <tr>
            <td>
                <b>c</b>
            </td>
            <td>
                <b>int</b> или <b>wint_t</b>
            </td>
            <td>
                При использовании с функцией <b>printf</b> определяет однобайтовый символ, при
                использовании с функцией <b>wprintf</b> определяет расширенный символ.
            </td>
        </tr>
        <tr>
            <td>
                <b>C</b>
            </td>
            <td>
                <b>int</b> или <b>wint_t</b>
            </td>
            <td>
                При использовании с функцией <b>printf</b> определяет расширенный символ, при
                использовании с функцией <b>wprintf</b> определяет однобайтовый символ.
            </td>
        </tr>
        <tr>
            <td>
                <b>d</b>
            </td>
            <td>
                <b>int</b>
            </td>
            <td>
                Знаковое десятичное целое.
            </td>
        </tr>
        <tr>
            <td>
                <b>i</b>
            </td>
            <td>
                <b>int</b>
            </td>
            <td>
                Знаковое десятичное целое.
            </td>
        </tr>
        <tr>
            <td>
                <b>o</b>
            </td>
            <td>
                <b>int</b>
            </td>
            <td>
                Беззнаковое восьмеричное целое.
            </td>
        </tr>
        <tr>
            <td>
                <b>u</b>
            </td>
            <td>
                <b>int</b>
            </td>
            <td>
                Беззнаковое десятичное целое.
            </td>
        </tr>
        <tr>
            <td>
                <b>x</b>
            </td>
            <td>
                <b>int</b>
            </td>
            <td>
                Беззнаковое шестнадцатеричное целое с использованием символов «abcdef».
            </td>
        </tr>
        <tr>
            <td>
                <b>X</b>
            </td>
            <td>
                <b>int</b>
            </td>
            <td>
                Беззнаковое шестнадцатеричное целое с использованием символов «ABCDEF».
            </td>
        </tr>
        <tr>
            <td>
                <b>e</b>
            </td>
            <td>
                <b>double</b>
            </td>
            <td>
                Знаковое число в форме [ – ]d.dddd <b>e</b> [знак]ddd, где d есть одна десятичная
                цифра, dddd – одна или более десятичных цифр, ddd – три десятичные цифры and знак
                есть + или –.
            </td>
        </tr>
        <tr>
            <td>
                <b>E</b>
            </td>
            <td>
                <b>double</b>
            </td>
            <td>
                Идентичен формату <b>e</b>, за исключением того, что символ <b>E</b>, а не <b>e</b>
                вводит экспоненту.
            </td>
        </tr>
        <tr>
            <td>
                <b>f</b>
            </td>
            <td>
                <b>double</b>
            </td>
            <td>
                Знаковое число в форме [ – ]dddd.dddd, где dddd есть одна или более десятичных цифр.
                Количество цифр перед десятичной точкой зависит от величины числа, а количество цифр
                после десятичной точки – от требуемой точности.
            </td>
        </tr>
        <tr>
            <td>
                <b>g</b>
            </td>
            <td>
                <b>double</b>
            </td>
            <td>
                Знаковое число в формате <b>f</b> или <b>e</b>, в зависимости от того, какой формат
                более компактен для заданного значения и точности.
            </td>
        </tr>
        <tr>
            <td>
                <b>G</b>
            </td>
            <td>
                <b>double</b>
            </td>
            <td>
                Идентичен формату <b>g</b>, за исключением того, что символ <b>E</b>, а не <b>e</b>
                вводит экспоненту.
            </td>
        </tr>
        <tr>
            <td>
                <b>n</b>
            </td>
            <td>
                pointer to <b>integer</b>
            </td>
            <td>
                Количество символов успешно записанных к данному моменту в выходной поток. Это
                значение сохраняется в целочисленной переменной, чей адрес задан как аргумент.
            </td>
        </tr>
        <tr>
            <td>
                <b>p</b>
            </td>
            <td>
                pointer to <b>void</b>
            </td>
            <td>
                Печатает адрес, заданный аргументом.
            </td>
        </tr>
        <tr>
            <td>
                <b>s</b>
            </td>
            <td>
                string
            </td>
            <td>
                При использовании с функцией <b>printf</b> задаёт строку однобайтовых символов, при
                использовании с функцией <b>wprintf</b> задаёт строку расширенных символов. Символы
                печатаются до достижения признака конца строки.
            </td>
        </tr>
        <tr>
            <td>
                <b>S</b>
            </td>
            <td>
                string
            </td>
            <td>
                При использовании с функцией <b>printf </b>задаёт строку расширенных символов, при
                использовании с функцией <b>wprintf</b> задаёт строку однобайтовых символов. Символы
                печатаются до достижения признака конца строки.
            </td>
        </tr>
    </table>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> m, n, x;
                <span class="chiavi">double</span> y;
                <span class="chiavi">char</span> c = '&amp;';
                <span class="chiavi">char</span> str[] = "String";
            </td>
            <td class="commenti">
                 
            </td>
        </tr>
        <tr>
            <td class="esempi">scanf("%d%d", &amp;m, &amp;n);</td>

            <td class="commenti">// Ввод десятичных целых чисел в переменные <b>m</b> и <b>n</b>
            </td>
        </tr>
        <tr>
            <td class="esempi">printf("m = %5d\nn = %5d\n", m, n);</td>

            <td class="commenti">// Вывод переменных <b>m</b> и <b>n</b> в десятичном целом формате,
                используются как минимум 5 знаков
            </td>
        </tr>
        <tr>
            <td class="esempi">scanf("%d", &amp;x);</td>

            <td class="commenti">// Ввод десятичного целого числа в переменную <b>x</b></td>
        </tr>
        <tr>
            <td class="esempi">printf("%#010x\n", x);</td>

            <td class="commenti">// Вывод переменной <b>x</b> в шестнадцатеричной системе,
                используются 10 знаков,
                // впереди добавляются нули и символы <i>0х</i></td>
        </tr>
        <tr>
            <td class="esempi">scanf("%lf", &amp;y);</td>

            <td class="commenti">// Ввод вещественного числа в переменную <b>y</b></td>
        </tr>
        <tr>
            <td class="esempi">printf("y = %7.2lf\n", y);</td>

            <td class="commenti">// Вывод вещественной переменной, используются как минимум 7
                знаков, из них 2 – после точки
            </td>
        </tr>
        <tr>
            <td class="esempi">printf("c = %c\n", c);</td>

            <td class="commenti">// Вывод одного символа</td>
        </tr>
        <tr>
            <td class="esempi">printf("%.4s\n", str);</td>

            <td class="commenti">// Вывод строки (не более 4 символов)</td>
        </tr>
    </table>


    <h2 id="l4_1_2">1.2. Чтение из строки/запись в строку </h2>
    <p>
        Функции <i>sprintf</i> и <i>sscanf</i> позволяют произвести запись значений переменных в
        форматированную строку или чтение переменных из строки:
        <span class="sint">
<span class="type">int</span> <span class="fun">sscanf</span> (<span class="type">char</span> *<var>str</var>, <span
                class="type">char</span> *<var>format</var>, ...);
<span class="type">int</span> <span class="fun">sprintf</span>(<span class="type">char</span> *<var>str</var>, <span
                class="type">char</span> *<var>format</var>, ...);
</span>
    </p>
    <p>
        Эти функции во всём аналогичны функциям <i>printf</i> и <i>scanf</i>, только в качестве
        первого параметра указывается строка, куда записываются или откуда считываются данные.
    </p>
    <h2 id="l4_1_3">1.3. Работа с файлами </h2>
    <table>
        <tr>
            <td class="bnone">
                <ul>
                    <li> Объявление файловой переменной</li>
                </ul>
            </td>
            <td class="bnone">
                <span class="sint"> – <span class="type">FILE</span> *<var>file</var>;    </span>
            </td>

        </tr>
        <tr>
            <td class="bnone">
                <ul>
                    <li> Открытие файла</li>
                </ul>
            </td>
            <td class="bnone">
                <span class="sint"> – <span class="type">FILE</span> *<span class="fun">fopen</span>(<span
                        class="type">char</span> *<var>name</var>, <span
                        class="type">char</span> *<var>mode</var>); </span></td>
        </tr>
        <tr>
            <td class="bnone">
                <ul>
                    <li> Проверка достижения конца файла</li>
                </ul>
            </td>
            <td class="bnone">
                <span class="sint"> – <span class="type">int</span> <span
                        class="fun">feof</span>(<span
                        class="type">FILE</span> *<var>file</var>); </span></td>
        </tr>
        <tr>
            <td class="bnone">
                <ul>
                    <li> Закрытие файла</li>
                </ul>
            </td>
            <td class="bnone">
                <span class="sint"> – <span class="type">int</span> <span class="fun">fclose</span>(<span
                        class="type">FILE</span> *<var>file</var>); </span></td>
        </tr>
    </table>
    <p>
        <i>FILE</i> – специальная структура, объявленная в файле <span
            class="sint">&lt;stdio.h&gt;</span>, которая используется при работе с файлами. Для
        работы с файлом нужно объявить переменную <span class="sint">FILE *&lt;имя&gt;</span>.
    </p>
    <p>
        Функция <i>fopen</i> используется для открытия файла. Первый параметр задаёт имя файла.
        Второй параметр <i>mode</i> задаёт требуемый тип доступа к файлу.
    </p>
    <table>
        <tr>
            <th>
                Mode
            </th>
            <th>
                Действие
            </th>
        </tr>
        <tr>
            <td>
                <b>"r"</b>
            </td>
            <td>
                Открытие для чтения. Если файл не существует или не может быть найден, функция <i>fopen</i>
                возвращает признак
                ошибки.
            </td>
        </tr>
        <tr>
            <td>
                <b>"w"</b>
            </td>
            <td>
                Открытие для записи. Если файл существует, его содержимое уничтожается. Если файл не
                существует, он
                создаётся.
            </td>
        </tr>
        <tr>
            <td>
                <b>"a"</b>
            </td>
            <td>
                Открытие для добавления. Если файл не существует, он создаётся.
            </td>
        </tr>
        <tr>
            <td>
                <b>"r+"</b>
            </td>
            <td>
                Открытие для чтения и записи. Файл должен существовать.
            </td>
        </tr>
        <tr>
            <td>
                <b>"w+"</b>
            </td>
            <td>
                Открытие пустого файла для чтения и записи. Если файл существует, его содержимое
                уничтожается.
            </td>
        </tr>
        <tr>
            <td>
                <b>"a+"</b>
            </td>
            <td>
                Открытие для чтения и добавления. Если файл не существует, он создаётся.
            </td>
        </tr>
    </table>
    <p>
        Кроме того, к параметру <i>mode</i> могут быть добавлены символы <b>t</b> и <b>b</b> для
        задания текстового и двоичного режимов соответственно. По умолчанию используется текстовый
        режим.
    </p>
    <p>
        В случае ошибки функция <i>fopen</i> возвращает значение <b>NULL</b>.
    </p>
    <h3 id="l4_1_3_1">1.3.1. Текстовый режим</h3>
    <p>
        При вводе/выводе в текстовом режиме происходит преобразование между внешним представлением
        значения и внутренним (машинным) представлением этого значения.
    </p>
    <table>
        <tr>
            <td class="bnone">
                <ul>
                    <li> Ввод одного символа</li>
                </ul>
            </td>
            <td class="bnone">
                <span class="sint"> – <span class="type">int</span>     <span
                        class="fun">getc</span>    (<span class="type">FILE</span> *<var>file</var>); </span>
            </td>
        </tr>
        <tr>
            <td class="bnone">
                <ul>
                    <li> Вывод одного символа</li>
                </ul>
            </td>
            <td class="bnone">
                <span class="sint"> – <span class="type">int</span>     <span
                        class="fun">putc</span>    (<span
                        class="type">int</span> <var>c</var>, <span class="type">FILE</span> *<var>file</var>); </span>
            </td>
        </tr>
        <tr>
            <td class="bnone">
                <ul>
                    <li> Ввод</li>
                </ul>
            </td>
            <td class="bnone">
                <span class="sint"> – <span class="type">int</span>     <span
                        class="fun">fscanf</span> (<span class="type">FILE</span> *<var>file</var>, <span
                        class="type">char</span> *<var>format</var>, ...); </span></td>
        </tr>
        <tr>
            <td class="bnone">
                <ul>
                    <li> Вывод</li>
                </ul>
            </td>
            <td class="bnone">
                <span class="sint"> – <span class="type">int</span>     <span
                        class="fun">fprintf</span>(<span class="type">FILE</span> *<var>file</var>, <span
                        class="type">char</span> *<var>format</var>, ...); </span></td>
        </tr>
        <tr>
            <td class="bnone">
                <ul>
                    <li> Ввод строки</li>
                </ul>
            </td>
            <td class="bnone">
                <span class="sint"> – <span class="type">char</span>* <span class="fun">fgets</span>   (<span
                        class="type">char</span> *<var>line</var>, <span
                        class="type">int</span> <var>maxline</var>, <span class="type">FILE</span> *<var>file</var>); </span>
            </td>
        </tr>
        <tr>
            <td class="bnone">
                <ul>
                    <li> Вывод строки</li>
                </ul>
            </td>
            <td class="bnone">
                <span class="sint"> – <span class="type">int</span>     <span
                        class="fun">fputs</span>   (<span class="type">char</span> *<var>line</var>, <span
                        class="type">FILE</span> *<var>file</var>); </span></td>
        </tr>
    </table>
    <h3 id="l4_1_3_2">1.3.2. Двоичный режим</h3>
    <p>
        В двоичном режиме никаких преобразований не производится, внутреннее представление значения
        записывается в файл. Для открытия файла в двоичном режиме необходимо в параметр <i>mode</i>
        функции <i>fopen</i> добавить символ <b>b</b>.
    </p>
    <table>
        <tr>
            <td class="bnone">
                <ul>
                    <li> Ввод из двоичного файла</li>
                </ul>
            </td>
            <td class="bnone">
                <span class="sint"> – <span class="type">unsigned</span> <span
                        class="fun">fread</span>  (<span
                        class="type">void</span> *<var>buf</var>, <span
                        class="type">int</span> <var>bytes</var>, <span
                        class="type">int</span> <var>num</var>, <span
                        class="type">FILE</span> *<var>file</var>); </span></td>
        </tr>
        <tr>
            <td class="bnone">
                <ul>
                    <li> Вывод в двоичный файл</li>
                </ul>
            </td>
            <td class="bnone">
                <span class="sint"> – <span class="type">unsigned</span> <span
                        class="fun">fwrite</span> (<span
                        class="type">void</span> *<var>buf</var>, <span
                        class="type">int</span> <var>bytes</var>, <span
                        class="type">int</span> <var>num</var>, <span
                        class="type">FILE</span> *<var>file</var>); </span></td>
        </tr>
    </table>
    <p>
        Функция <i>fread </i> читает из файла <i>file</i> в переменную <i>buf num</i> элементов,
        каждый размером <i>bytes</i> байт. Функция <i>fwrite</i> записывает в файл <i>file</i> из
        переменной <i>buf num</i> элементов, каждый размером <i>bytes</i> байт. Функции возвращают
        количество прочитанных/записанных элементов.
    </p>
    <p>
        В двоичном режиме возможен прямой доступ к файлу:
        <span class="sint">
<i>int</i> <b>fseek</b>(<i>FILE</i> *file, <i>long</i> nbytes, <i>int</i> origin)
</span>
    </p>
    <p>
        Данная функция смещает указатель в файле <i>file</i> на <i>nbytes</i> байт с позиции,
        определяемой параметром <i>origin</i>. При этом параметр <i>origin</i> может принимать
        следующие значения:
    </p>
    <ul>
        <li><span class="sint">SEEK_SET     0     </span>– начало файла;
        </li>
        <li><span class="sint">SEEK_CUR     1     </span>– текущая позиция указателя;
        </li>
        <li><span class="sint">SEEK_END     2     </span>– конец файла.
        </li>
    </ul>
    <p>
        Функция <span class="sint"><i>long</i> <b>ftell</b>(<i>FILE</i> *file)</span> возвращает
        текущую позицию указателя в файле <i>file</i>.
    </p>
    <table>
        <tr>
            <td class="esempi">fseek(file, 0, SEEK_END);
                n = ftell(file);
            </td>
            <td class="commenti">// Определение размера файла</td>
        </tr>
    </table>
</section>
<section id="l4_2">
    <h1>2. Потоковый ввод/вывод </h1>
    <p>
        В языке С++ был разработан другой способ ввода/вывода с использованием так называемых <i>потоков</i>
        ввода и вывода.
    </p>
    <h2 id="l4_2_1">2.1. Использование стандартных потоков <i>cin</i> и <i>cout</i></h2>
    <p>
        Для того чтобы использовать стандартные потоки для ввода и вывода, необходимо включить
        заголовочный файл <span class="sint">&lt;iostream&gt;</span>. Для ввода используется
        операция <b>&gt;&gt;</b>, для вывода – операция <b>&lt;&lt;</b>. Компилятор определяет тип
        вводимой/выводимой переменной и соответствующим образом форматирует её.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">#include</span> &lt;iostream&gt;
                <span class="chiavi">using namespace</span> std;
            </td>

            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">cin &gt;&gt; x;</td>

            <td class="commenti">// Ввод значения в переменную <b>x</b> из стандартного потока <i>cin</i>
            </td>
        </tr>
        <tr>
            <td class="esempi">cout &lt;&lt; x;</td>

            <td class="commenti">// Вывод значения переменной <b>x</b> в стандартный поток
                <i>cout</i></td>
        </tr>
        <tr>
            <td class="esempi">cin &gt;&gt; x &gt;&gt; y;</td>

            <td class="commenti">// Ввод двух переменных</td>
        </tr>
        <tr>
            <td class="esempi">cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; "\ny = " &lt;&lt; y &lt;&lt;
                endl;
            </td>

            <td class="commenti">// Функция <i>endl</i> осуществляет перевод строки</td>
        </tr>
    </table>
    <p>
        Если при вводе или выводе произошла ошибка, в переменной состояния потока устанавливается
        соответствующий флаг. Проверить его значение можно с помощью функции <i>fail</i>.
    </p>
    <table>
        <tr>
            <td class="esempi">cin &gt;&gt; x;
                <span class="chiavi">if</span> (cin.fail())
                cout &lt;&lt; "Произошла ошибка при вводе\n";
            </td>
        </tr>
    </table>
    <h2 id="l4_2_2">2.2. Форматирование </h2>
    <p>
        Для управления форматом вводимого/выводимого значения используются так называемые <i>манипуляторы</i>.
        Это функции, которые вставляются между вводимыми/выводимыми значениями и изменяют состояние
        потока.
    </p>
    <p>
        Для использования манипуляторов необходимо включить заголовочный файл <span class="sint">&lt;iomanip&gt;</span>.
    </p>
    <p>
        Несколько манипуляторов имеют параметр, который может быть задан литералом или переменной.
        Изменения, сделанные всеми манипуляторами, кроме <i>setw</i>, остаются в силе до отмены.
        Действие манипулятор <i>setw</i> распространяется только на одно вводимое/выводимое
        значение.
    </p>
    <table>
        <tr>
            <th>
                Манипулятор
            </th>
            <th>
                Описание
            </th>
            <th>
                Примечание
            </th>
        </tr>
        <tr>
            <td>
                <b>boolalpha</b>
            </td>
            <td>
                Значения переменных типа <i>bool</i> выводятся как <i>true</i> и <i>false</i>.
            </td>
            <td>
                 
            </td>
        </tr>
        <tr>
            <td>
                <b>dec</b>
            </td>
            <td>
                Целые значения выводятся в десятичной системе счисления.
            </td>
            <td>
                 Используется по умолчанию
            </td>
        </tr>
        <tr>
            <td>
                <b>fixed</b>
            </td>
            <td>
                Для вещественных чисел используется фиксированный формат.
            </td>
            <td>
                 
            </td>
        </tr>
        <tr>
            <td>
                <b>hex</b>
            </td>
            <td>
                Целые значения выводятся в шестнадцатеричной системе счисления.
            </td>
            <td>
                 
            </td>
        </tr>
        <tr>
            <td>
                <b>internal</b>
            </td>
            <td>
                Знак выравнивается по левому краю, а само число – по правому краю.
            </td>
            <td>
                 
            </td>
        </tr>
        <tr>
            <td>
                <b>left</b>
            </td>
            <td>
                Выравнивание по левому краю.
            </td>
            <td>
                 
            </td>
        </tr>
        <tr>
            <td>
                <b>noboolalpha</b>
            </td>
            <td>
                Значения переменных типа <i>bool</i> выводятся как <i>1</i> и <i>0</i>.
            </td>
            <td>
                 Используется по умолчанию
            </td>
        </tr>
        <tr>
            <td>
                <b>noshowbase</b>
            </td>
            <td>
                Префиксы <i>0</i> и <i>0х</i>, обозначающие систему счисления, не выводятся.
            </td>
            <td>
                 Используется по умолчанию
            </td>
        </tr>
        <tr>
            <td>
                <b>noshowpoint</b>
            </td>
            <td>
                Вывод только целой части вещественного числа (без точки), если дробная часть равна
                0.
            </td>
            <td>
                 Используется по умолчанию
            </td>
        </tr>
        <tr>
            <td>
                <b>noshowpos</b>
            </td>
            <td>
                Знак перед положительными числами не выводится.
            </td>
            <td>
                 Используется по умолчанию
            </td>
        </tr>
        <tr>
            <td>
                <b>noskipws</b>
            </td>
            <td>
                Пробел рассматривается как признак завершения ввода.
            </td>
            <td>
                 
            </td>
        </tr>
        <tr>
            <td>
                <b>nouppercase</b>
            </td>
            <td>
                Шестнадцатеричные цифры и символ экспоненты в научном формате вещественного числа
                выводятся строчными буквами.
            </td>
            <td>
                 Используется по умолчанию
            </td>
        </tr>
        <tr>
            <td>
                <b>oct</b>
            </td>
            <td>
                Целые значения выводятся в восьмеричной системе счисления.
            </td>
            <td>
                 
            </td>
        </tr>
        <tr>
            <td>
                <b>right</b>
            </td>
            <td>
                Выравнивание по правому краю.
            </td>
            <td>
                 Используется по умолчанию
            </td>
        </tr>
        <tr>
            <td>
                <b>scientific</b>
            </td>
            <td>
                Для вещественных чисел используется научный формат.
            </td>
            <td>
                 
            </td>
        </tr>
        <tr>
            <td>
                <b>setfill(<i>c</i>)</b>
            </td>
            <td>
                Задаёт символ для заполнения. По умолчанию используется пробел.
            </td>
            <td>
                 
            </td>
        </tr>
        <tr>
            <td>
                <b>setprecision(<i>n</i>)</b>
            </td>
            <td>
                Задаёт точность для вещественных чисел. По умолчанию точность равна 6. Если не
                установлен ни фиксированный, ни научный формат вещественного числа, то точность
                задаёт количество выводимых цифр (всего, до точки и после точки). Если число слишком
                велико, оно автоматически отображается в научном формате, и тогда точность задаёт
                количество цифр в мантиссе. Если установлен фиксированный формат вещественного
                числа, точность задаёт количество цифр после точки. Если установлен научный формат
                вещественного числа, точность задаёт количество цифр в мантиссе.
            </td>
            <td>
                 
            </td>
        </tr>
        <tr>
            <td>
                <b>setw(<i>n</i>)</b>
            </td>
            <td>
                Устанавливает минимальное количество символов, используемых для вывода значения.
                Если значение представляется меньшим количеством символов, остальные позиции
                заполняются символом, установленным с помощью манипулятора <i>setfill</i>.
                Выравнивание задаётся манипуляторами <i>left</i>, <i>right</i> и <i>internal</i>.
                Чтобы установить поведение по умолчанию (столько символов, сколько необходимо),
                нужно использовать манипулятор <i>setw</i> с параметром <i>0</i>.
            </td>
            <td>
                <b>Влияет только на одно вводимое/выводимое значение!</b>
            </td>
        </tr>
        <tr>
            <td>
                <b>showbase</b>
            </td>
            <td>
                Вывод префиксов <i>0</i> и <i>0х</i> для обозначения системы счисления.
            </td>
            <td>
                 
            </td>
        </tr>
        <tr>
            <td>
                <b>showpoint</b>
            </td>
            <td>
                Вывод и целой, и дробной частей вещественного числа, даже если дробная часть равна
                0.
            </td>
            <td>
                 
            </td>
        </tr>
        <tr>
            <td>
                <b>showpos</b>
            </td>
            <td>
                Вывод знака перед положительным числом.
            </td>
            <td>
                 
            </td>
        </tr>
        <tr>
            <td>
                <b>skipws</b>
            </td>
            <td>
                Пробелы рассматриваются как разделители между значениями.
            </td>
            <td>
                 Используется по умолчанию
            </td>
        </tr>
        <tr>
            <td>
                <b>uppercase</b>
            </td>
            <td>
                Шестнадцатеричные цифры и символ экспоненты в научном формате вещественного числа
                выводятся прописными буквами.
            </td>
            <td>
                 
            </td>
        </tr>
    </table>
    <p>
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> m, n, x;
                <span class="chiavi">double</span> y;
                cin &gt;&gt; m &gt;&gt; n;
                cout &lt;&lt; "m = " &lt;&lt; setw(5) &lt;&lt; m &lt;&lt; "\nn = " &lt;&lt; setw(5)
                &lt;&lt; n &lt;&lt; endl;
                cin &gt;&gt; x;
                cout &lt;&lt; setfill('0') &lt;&lt; showbase &lt;&lt; hex &lt;&lt; setw(10) &lt;&lt;
                internal &lt;&lt; x &lt;&lt; endl;
                cin &gt;&gt; y;
                cout &lt;&lt; setfill(' ') &lt;&lt; fixed &lt;&lt; setw(7) &lt;&lt; setprecision(2)
                &lt;&lt; y &lt;&lt; endl;
            </td>
        </tr>
    </table>
    <h2 id="l4_2_3">2.3. Связываение потоков </h2>
    <p>
        Рассмотрим пример.
        <code>
            <span class="chiavi">char</span> c;
            cout &lt;&lt; "Введите символ: ";
            cin &gt;&gt; c;
        </code>
    </p>
    <p>
        Как нам гарантировать, что слова <b><i>Введите символ</i></b> появятся на экране прежде, чем
        будет выполнена операция считывания? Вывод в стандартный поток буферизуется, так что если
        потоки <i>cin</i> и <i>cout</i> не зависимы, то выводимый текст не появится на экране, пока
        не заполнится буфер вывода. Решение этой задачи заключается в том, что потоки связываются с
        помощью функции <i>tie</i>. Эта функция используется для того, чтобы устанавливать и
        разрывать связи между потоками ввода и вывода.
        <code>
            <span class="chiavi">char</span> c;
            cin.tie(&amp;cout);
            cout &lt;&lt; "Введите символ: ";
            cin &gt;&gt; c;
        </code>
    </p>
    <p>
        В каждый момент времени поток ввода может быть связан только с одним потоком вывода.
        Обращение <span class="sint">s.tie(0)</span> разрывает связь между потоком <var>s</var> и
        потоком, с которым он был связан. Как и большинство функций с потоками, устанавливающих
        значение, функция <i>tie</i> возвращает прежнее значение, т.е. она возвращает предыдущий
        связанный поток или 0. При вызове без аргументов функция <span class="sint">tie()</span>
        возвращает текущий связанный поток, не изменяя его.
    </p>
    <h2 id="l4_2_4">2.4. Файловые потоки </h2>
    <p>
        Для ввода/вывода из файла/в файл существуют потоки, которые могут быть связаны с файлом на
        диске. Для использования файловых потоков необходимо включить заголовочный файл <span
            class="sint">&lt;fstream&gt;</span>. Существует три разновидности файловых потоков: <i>fstream</i>,
        <i>ifstream</i> и <i>ofstream</i>. Разница между ними состоит в том, что поток
        <i>fstream</i> по умолчанию открывается для ввода и вывода, поток <i>ifstream</i> по
        умолчанию открывается для ввода, а поток <i>ofstream</i> по умолчанию открывается для
        вывода. Изменить поведение по умолчанию, а также задать другие режимы открытия файла можно с
        помощью следующих констант:
    </p>
    <ul>
        <li><span class="sint">ios_base::app     </span> – открытие файла для добавления;
        </li>
        <li><span class="sint">ios_base::binary </span> – открытие двоичного, а не текстового файла;
        </li>
        <li><span class="sint">ios_base::in       </span> – открытие файла для чтения;
        </li>
        <li><span class="sint">ios_base::out     </span> – открытие файла для записи;
        </li>
        <li><span class="sint">ios_base::trunc  </span> – удаление содержимого файла при открытии.
        </li>
    </ul>
    <p>
        Режимы открытия файла комбинируются с помощью операции поразрядного ИЛИ (<b>|</b>).
    </p>
    <p>
        Для открытия файла можно задать имя файла непосредственно в конструкторе потока или
        воспользоваться функцией <i>open</i>.
    </p>
    <table>
        <tr>
            <td class="esempi">fstream fs("f1.txt");</td>
            <td class="commenti">// Открытие файла для чтения и записи</td>
        </tr>
        <tr>
            <td class="esempi">ifstream ifs("f2.txt");</td>
            <td class="commenti">// Открытие файла для чтения</td>
        </tr>
        <tr>
            <td class="esempi">ofstream ofs("f3.txt");</td>
            <td class="commenti">// Открытие файла для записи</td>
        </tr>
        <tr>
            <td class="esempi">fstream fs("f1.txt", ios_base::in | ios_base::out |
                ios_base::trunk);
            </td>
            <td class="commenti">// Открытие файла для чтения и записи с удалением содержимого
                файла
            </td>
        </tr>
        <tr>
            <td class="esempi">ifstream ifs("f2.txt", ios_base::in | ios_base::binary);</td>
            <td class="commenti">// Открытие двоичного файла для чтения</td>
        </tr>
        <tr>
            <td class="esempi">ofstream ofs;</td>
            <td class="commenti">// Создаём поток, не связанный с файлом</td>
        </tr>
        <tr>
            <td class="esempi">ofs.open("f3.txt");</td>
            <td class="commenti">// Открываем файл для записи</td>
        </tr>
    </table>
    <p>
        Если вы планируете использовать файл только для чтения или только для записи безопаснее
        воспользоваться соответствующим файловым потоком.
    </p>
    <p>
        Для проверки открытия файла служит функция <i>is_open</i>.
    </p>
    <p>
        Потоки автоматически закрываются при завершении программы. Однако при необходимости можно
        закрыть поток функцией <i>close</i> и затем снова открыть его, связав с другим файлом.
    </p>
    <p>
        Для работы с текстовыми потоками используются операции <b>&lt;&lt;</b> и <b>&gt;&gt;</b>.
        Также возможно использование манипуляторов для форматирования вводимых/выводимых значений.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> x;
                fstream f;
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">f.open("in.txt", ios_base::in);</td>
            <td class="commenti">// Открываем файл для чтения</td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">if</span> (!f.is_open())
            </td>
            <td class="commenti">// Проверяем открытие файла</td>
        </tr>
        <tr>
            <td class="esempi"> { cout &lt;&lt; "Невозможно открыть файл 'in.txt'\n"; <span
                    class="chiavi">return</span>; }
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">f &gt;&gt; x;</td>
            <td class="commenti">// Чтение переменной <b>x</b> из файла</td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">if</span> (f.fail())
            </td>
            <td class="commenti">// Проверка ошибок чтения</td>
        </tr>
        <tr>
            <td class="esempi"> { cout &lt;&lt; "Ошибка чтения из файла 'in.txt'\n";  <span
                    class="chiavi">return</span>; }
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">f.close();</td>
            <td class="commenti">// Закрываем файл</td>
        </tr>
        <tr>
            <td class="esempi">f.open("out.txt", ios_base::out);</td>
            <td class="commenti">// Снова открываем файл, теперь для записи</td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">if</span> (!f.is_open())
            </td>
            <td class="commenti">// Проверяем открытие файла</td>
        </tr>
        <tr>
            <td class="esempi"> { cout &lt;&lt; "Невозможно открыть файл 'out.txt'\n"; <span
                    class="chiavi">return</span>; }
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">f &lt;&lt; hex &lt;&lt; x &lt;&lt; endl;</td>
            <td class="commenti">// Выводим значение переменной <b>x</b> в 16-ричной системе</td>
        </tr>
        <tr>
            <td class="esempi">f.close();</td>
            <td class="commenti">// Закрываем файл</td>
        </tr>
    </table>
    <p>
        Для того чтобы проверить, достигнут ли конец файла, используется функция <i>eof</i>.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> n;
                ifstream f("in.txt");
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">if</span> (!f.is_open())
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"> { cout &lt;&lt; "Невозможно открыть файл 'in.txt'\n"; <span
                    class="chiavi">return</span>; }
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">while</span> (!f.eof())
            </td>
            <td class="commenti">// Пока не достигнут конец файла</td>
        </tr>
        <tr>
            <td class="esempi"> { f &gt;&gt; n; cout &lt;&lt; n &lt;&lt; endl; }</td>
            <td class="commenti"></td>
        </tr>
    </table>
    <p>
        Для организации прямого доступа к файлу используются функции <i>seekg/seekp</i> и <i>tellg/tellp</i>.
        Различие между функциями состоит в том, что функции, с именем, оканчивающимся символом ‘g’,
        используются для работы с потоками ввода, а функции, с именем, оканчивающимся символом ‘p’,
        – для работы с потоками вывода.
    </p>
    <p>
        Функции <i>seekg/seekp</i> перемещают внутренний указатель файла на заданную позицию.
        Позиции соответствуют байтам, нумерация начинается с 0. Существует две разновидности функций
        – с одним параметром и с двумя параметрами. Один целочисленный параметр задаёт абсолютную
        позицию в файле. Два параметра задают смещение (целое число) и точку отсчёта. Этот параметр
        может принимать следующие значения:
    </p>
    <ul>
        <li><span class="sint">ios_base::beg</span> – начало файла;
        </li>
        <li><span class="sint">ios_base::cur</span> – текущая позиция указателя;
        </li>
        <li><span class="sint">ios_base::end</span> – конец файла.
        </li>
    </ul>
    <p>
        Функции <i>tellg/tellp</i> не имеют параметров. Они возвращают текущую позицию указателя в
        файле.
    </p>
    <p>
        Функции <i>seekg/seekp</i> и <i>tellg/tellp</i> работают как с текстовыми, так и с двоичными
        потоками. В любом случае желательно либо знать структуру файла, либо работать с файлами, все
        записи в которых имеют одинаковую длину. В противном случае возможно перемещение указателя
        на позицию, не являющуюся началом записи.
    </p>
    <p>
        Для работы с двоичными файлами используются функции <i>read</i> и <i>write</i>. В качестве
        параметров функции получают указатель (типа <span class="sint">char*</span> для функции <i>read</i>
        и типа <span class="sint">const char*</span> для функции <i>write</i>), который задаёт адрес
        начала массива для ввода/вывода, и целое число, задающее количество байт для ввода/вывода.
    </p>
    <p>
        Пример использования потокового ввода из двоичного файла см. .
    </p></section>
<section id="l4_3">
    <h2>3. Примеры </h2>
    <h3 id="l4_3_1"> Пример 1. Ввод массива из текстового файла</h3>
    <table>
        <tr>
            <td class="commenti">// Функция ввода одномерного массива.
                // Если ввод был осуществлен без ошибок, возвращается 1, в противном случае - 0.
                // <b>x</b> - вводимый массив,
                // <b>n</b> - указатель на переменную, содержащую количество элементов массива,
                // <b>fname</b> - имя файла для ввода.
            </td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> ArrayInput(<span class="chiavi">double</span> x[],
                <span class="chiavi"> int</span> *n, <span class="chiavi"> char</span> *fname)
                { <span class="chiavi">int</span> i;
                FILE *file;
                <span class="chiavi">if</span> ((file = fopen(fname, "r")) == NULL)
                { printf("Невозможно открыть файл '%s'\n", fname);
                <span class="chiavi">return</span> 0;
                }
                <span class="chiavi">if</span> (fscanf(file, "%d", n) &lt; 1)
                { printf ("Ошибка чтения из файла '%s'\n", fname);
                fclose(file);
                <span class="chiavi">return</span> 0;
                }
                <span class="chiavi">if</span> (*n &lt; 0 || *n &gt; NMAX)
                { printf("Кол-во эл-тов масс. должно быть от 1 до %d! (файл '%s')\n", NMAX, fname);
                fclose(file);
                <span class="chiavi">return</span> 0;
                }
                <span class="chiavi">for</span> (i = 0; i &lt; *n; i++)
                <span class="chiavi">if</span> (fscanf(file, "%lf", &amp;x[i]) &lt; 1)
                { printf ("Ошибка чтения из файла '%s'\n", fname);
                fclose(file);
                <span class="chiavi">return</span> 0;
                }
                fclose(file);
                <span class="chiavi">return</span> 1;
                }
            </td>
        </tr>
    </table>
    <h3 id="l4_3_2"> Пример 2. Вывод массива в двоичный файл</h3>
    <table>
        <tr>
            <td class="commenti">// Вывод массива в двоичный файл.
                // Если вывод был осуществлен без ошибок, возвращается 1, в противном случае - 0.
                // <b>x</b> - выводимый массив,
                // <b>n</b> - переменная, содержащая количество элементов массива,
                // <b>fname</b> - имя файла для вывода.
            </td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> BinOutput(<span class="chiavi">double</span> x[],
                <span class="chiavi"> int</span> n, <span class="chiavi"> char</span> *fname)
                { FILE *file;
                <span class="chiavi">if</span> ((file = fopen(fname, "wb")) == NULL)
                { printf("Невозможно открыть файл '%s'\n", fname);
                <span class="chiavi">return</span> 0;
                }
                <span class="chiavi">if</span> (fwrite(x, n * <span
                    class="chiavi">sizeof</span>(<span class="chiavi">double</span>), 1, file) &lt;
                1)
                { printf ("Ошибка записи в файл '%s'\n", fname);
                fclose(file);
                <span class="chiavi">return</span> 0;
                }
                fclose(file);
                <span class="chiavi">return</span> 1;
                }
            </td>
        </tr>
    </table>
    <h3 id="l4_3_3"> Пример 3. Ввод массива из двоичного файла</h3>
    <table>
        <tr>
            <td class="commenti">// Ввод массива из двоичного файла.
                // Если ввод был осуществлен без ошибок, возвращается 1, в противном случае - 0.
                // <b>x</b> - вводимый массив,
                // <b>n</b> - указатель на переменную, содержащую количество элементов массива,
                // <b>fname</b> - имя файла для ввода.
            </td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> BinInput(<span class="chiavi">double</span> x[],
                <span class="chiavi"> int</span> *n, <span class="chiavi"> char</span> *fname)
                { FILE *file;
                <span class="chiavi">if</span> ((file = fopen(fname, "rb")) == NULL)
                { printf("Невозможно открыть файл '%s'\n", fname);
                <span class="chiavi">return</span> 0;
                }
                <span class="chiavi">for </span>(*n = 0; ; (*n)++)
                <span class="chiavi">if</span> (fread(x + (*n), <span
                    class="chiavi">sizeof</span>(<span class="chiavi">double</span>), 1, file) &lt;
                1)
                <span class="chiavi">if</span> (feof(file))
                <span class="chiavi">break</span>;
                <span class="chiavi">else</span>
                { printf ("Ошибка чтения из файла '%s'\n", fname);
                fclose(file);
                <span class="chiavi">return</span> 0;
                }
                fclose(file);
                <span class="chiavi">return</span> 1;
                }
            </td>
        </tr>
    </table>
    <table>
        <tr>
            <td class="commenti">

                // Другой способ
            </td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> BinInput(<span class="chiavi">double</span> x[],
                <span class="chiavi"> int</span> *n, <span class="chiavi"> char</span> *fname)
                { FILE *file;
                <span class="chiavi">if</span> ((file = fopen(fname, "rb")) == NULL)
                { printf("Невозможно открыть файл '%s'\n", fname);
                <span class="chiavi">return</span> 0;
                }
                fseek(file, 0, SEEK_END);
                *n = ftell(file) / <span class="chiavi">sizeof</span>(<span
                    class="chiavi">double</span>);
                fseek(file, 0, SEEK_SET);
                <span class="chiavi">if</span> (fread(x, <span class="chiavi">sizeof</span>(<span
                    class="chiavi">double</span>), *n, file) &lt; *n)
                { printf ("Ошибка чтения из файла '%s'\n", fname);
                fclose(file);
                <span class="chiavi">return</span> 0;
                }
                fclose(file);
                <span class="chiavi">return</span> 1;
                }
            </td>
        </tr>
    </table>
    <h3 id="l4_3_4"> Пример 4. Потоковый ввод массива из двоичного файла</h3>
    <table>
        <tr>
            <td class="commenti">// Ввод массива из двоичного файла.
                // Если ввод был осуществлен без ошибок, возвращается 1, в противном случае - 0.
                // <b>x</b> - вводимый массив,
                // <b>n</b> - указатель на переменную, содержащую количество элементов массива,
                // <b>fname</b> - имя файла для ввода.
            </td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> BinInput(<span class="chiavi">double</span> x[],
                <span class="chiavi"> int</span> *n, <span class="chiavi"> char</span> *fname)
                { ifstream f(fname, ios_base::in | ios_base::binary);
                <span class="chiavi">if</span> (!f.is_open())
                { cout &lt;&lt; "Невозможно открыть файл '" &lt;&lt; fname &lt;&lt; "'\n";
                <span class="chiavi">return</span> 0;
                }
                f.seekg(0, ios_base::end);
                *n = f.tellg() / <span class="chiavi">sizeof</span>(<span
                    class="chiavi">double</span>);
                f.seekg(0, ios_base::beg);
                f.read(<span class="chiavi">reinterpret_cast</span>&lt;<span
                    class="chiavi">char</span> *&gt;(x), *n * <span
                    class="chiavi">sizeof</span>(<span class="chiavi">double</span>));
                <span class="chiavi">if</span> (f.fail())
                { cout &lt;&lt; "Ошибка чтения из файла '" &lt;&lt; fname &lt;&lt; "'\n";
                <span class="chiavi">return</span> 0;
                }
                <span class="chiavi">return</span> 1;
                }
            </td>
        </tr>
    </table>
</section>

</body>
</html>
