<!DOCTYPE html>
<html>
<head>

    <title>Лекция 11. Пакет java.awt</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<div class="left">
    <p></p>
    <p></p>
    <center><h2>Лекция 11.
        Пакет java.awt</h2></center>
    <p>
    </p>
    <p>
    </p>
    <p>Эта лекция начинает рассмотрение базовых библиотек Java, которые являются
        неотъемлимой частью языка и входят в его спецификацию, а имен­но описывается
        пакет java.awt, предоставляющий технологию AWT для со­здания графического (оконного)
        интерфейса
        пользователя - GUI. Ни одна современная программа, предназначенная для
        пользователя, не обходится без удобного, понятного, в идеале — красивого
        пользовательского интерфей­са, С самой первой версии в Java существует специальная
        технология для со­здания GUI. Она называется AWT, Abstract Window Toolkit. Именно о ней
        пойдет речь в этой лекции. Пакет java.awt претерпел, пожалуй, больше всего изменений с
        развитием
        версий Java. Мы рассмотрим дерево компонентов, до­ступных
        программисту, специальную модель сообщений, позволяющую гиб­ко обрабатывать
        пользовательские действия, и другие особенности AWT — работа с цветами, шрифтами, отрисовка
        графических
        примитивов, менедже­ры компоновки и т.д. Хотя технология AWT включает в себя гораздо больше,
        чем можно изложить в
        рамках одной лекции, здесь собраны все необходимые сведения для создания
        полноценного оконного интерфейса.
    </p>
    <p>
    </p>
    <p>Ключевые слова: стиль ключевого слова, foreground, background, controls, layout managers.
    </p>
    <p>
    </p>
    <p>Введение
    </p>
    <p>Поскольку Java-приложения
        предназначены для работы на разнооб­разных платформах, реализация графического
        пользовательского интер­фейса (GUI) должна быть либо одинаковой для любой платформы, либо,
        напротив,
        программа должна иметь вид, типичный для данной операцион­ной системы. В силу
        ряда причин, для основной библиотеки по созданию GUI был выбран второй подход. Во-первых,
        это лишний раз показывало гибкость Java - действительно, пользователи разных платформ могли
        ра­ботать
        с один и тем же Java-приложением, не
        меняя своих привычек. Во-вторых, такая реализация обеспечивала большую
        производительность, Поскольку была основана на возможностях операционной системы. В
        Частности,
        это означало и более
        компактный, простой, а значит, и более надежный код.
    </p>
    <p>Библиотеку назвали AWT — Abstract
        Window Toolkit. Слово abstract в \ Названии указывает, что все стандартные компоненты не
        являются само­стоятельными,
        а работают в связке с соответствующими элементами опе­рационной системы.
    </p>
    <p>Дерево
        компонентов Component
    </p>
    <p>Абстрактный класс Component является базовым
        для всех компонент AWT и описывает их
        основные свойства
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Визуальный компонент в AVVT имеет прямоугольную форму, может быть отображен на экране и
        может
        взаимодействовать с пользователем.
    </p>
    <p>Рассмотрим основные свойства
        этого класса.
    </p>
    <p>
    </p>
    <p>Положение
    </p>
    <p>Положение компонента описывается двумя целыми числами (тип int) х и у. В Java (как и во
        многих языках программирования) ось х проходит традиционно —
        горизонтально, направлена вправо, а ось у — вертикально, но направлена вниз, а
        не вверх, как принято в математике.
    </p>
    <p>Для описания положения компонента предназначен специальный класс - Point (точка). В этом
        классе определено два public int поля х и у, а также
        множество конструкторов и вспомогательных методов для работы с ними. Класс Point применяется
        во
        многих типах AWT, где надо задать точку на плоскости.
    </p>
    <p>Для компонента эта точка
        задает положение левого верхнего угла.
    </p>
    <p>Установить положение компонента можно с помощью метода setLocation, который может принимать в
        качестве аргументов пару целых чисел, либо Point. Узнать текущее
        положение можно с помощью метода getl_ocation(), возвращающего Point, либо с помощью методов
        getX() и getY(), которые появились с версии Java 1.2.
    </p>
    <p>
    </p>
    <p>Размер
    </p>
    <p>Как было сказано, компонент AWT имеет прямоугольную форму, а потому его размер описывается
        также двумя
        целочисленными параметра­ми — width (ширина) и height (высота). Для описания размера
        существует специальный класс Dimension (размер), в котором
        определено два public int поля width и height, а также
        вспомогательные методы.
    </p>
    <p>Установить размер компонента можно с помощью метода setSize, ко­торый может
        принимать в качестве аргументов пару целых чисел, либо Dimension. Узнать текущее положение
        можно с помощью метода getSize(). возвращающего Dimension, либо с помощью методов getWidthO
        и getHeight(), которые появились с версии Java 1.2.
    </p>
    <p>Совместно положение и размер компонента задают его границы-Область,
        занимаемую компонентом, можно описать либо четырьмя числа-
    </p>
    <p>
    </p>
    <p>(х, у, width, height), либо экземплярами классов Point и Dimension, либо специальным классом
        Rectangle (прямоугольник).
        Как легко догадаться, в этом классе определено четыре public int поля, с которыми
        можно работать и в виде пары объектов Point и Dimension.
    </p>
    <p>Задать границу объекта можно с помощью метода setBounds, кото­рый может принимать четыре
        числа, либо Rectangle. Узнать текущее зна­чение можно с помощью метода getBoundsQ,
        возвращающего Rectangle.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Видимость
    </p>
    <p>Существующий компонент может быть как виден пользователю, так ||быть
        скрытым. Это свойство описывается булевским параметром visible. Методы для
        управления — setVisible, принимающий булевский параметр, ц isVisible, возвращающий текущее
        значение.
    </p>
    <p>Разумеется, невидимый компонент не может взаимодействовать с
        пользователем.
    </p>
    <p>
    </p>
    <p>Доступность
    </p>
    <p>Даже если компонент отображается на экране и виден пользовате­лю, он может не
        взаимодействовать с ним. В результате события от клави­атуры, или мыши не будут получаться и
        обрабатываться компонентом. |ккой
        компонент называется disabled. Если же компонент активен, его Называют enabled. Как правило,
        компонент некоторым образом меняет свой внешний вид, когда становится
        недоступным (например, становит­ся серым, менее заметным), но, вообще говоря,
        это необязательно (хотя очень удобно для пользователя).
    </p>
    <p>Для изменения этого свойства применяется метод setEnabled, прини­мающий булевский параметр
        (true соответствует enabled, false — disabled), • для получения
        текущего значения - isEnabled.
    </p>
    <p>
    </p>
    <p>Цвета
    </p>
    <p>Разумеется, для построения современного графического интерфейса
        Пользователя необходима работа с цветами.
    </p>
    <p>Компонент обладает двумя свойствами, описывающими цвета, — foreground и background цвета.
        Первое свойство задает, каким цветом вы­водить надписи, рисовать
        линии и т.д. Второе - задает цвет фона, кото­рым
        закрашивается вся область,
        занимаемая компонентом, перед тем, как прорисовывается внешний вид.
    </p>
    <p>Для задания цвета в AWT используется специальный класс Color, ^тот класс обладает
        довольно обширной функциональностью, поэтому Рассмотрим основные
        характеристики.
    </p>
    <p>Цвет задается 3 целочисленными характеристиками, соответствую, шими
        модели RGB, - красный, синий, зеленый. Каждая из них может иметь значение от 0 до
        255 (тем не менее, их тип определен как int). В ре-зультате (0,
        0, 0) соответствует черному, а (255, 255, 255) — белому.
    </p>
    <p>Класс Color является
        неизменяемым, то есть, создав экземпляр, соот­ветствующий какому-либо цвету,
        изменить параметры RGB уже невозможно. Это
        позволяет объявить в классе Color ряд констант,
        описывающих базовые цвета: белый, черный, красный, желтый и так далее.
        Например, вместо того, чтобы задавать синий цвет числовыми параметрами (0, 0,
        255), можно воспользоваться константами Color.blue или Color.BLUE (второй вариант
        появился в более поздних версиях).
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Для работы со свойством компонента foreground применяют методы setForeground и getForeground,
        а для background -setBackground и getBackground.
    </p>
    <p>
    </p>
    <p>Шрифт
    </p>
    <p>Раз изображение компонента может включать в себя надписи, необходимо
        свойство, описывающее шрифт для их прорисовки.
    </p>
    <p>Для задания шрифта в AWT существует
        специальный класс Font, который включает в себя три параметра - имя шрифта, размер и стиль.
    </p>
    <p>Имя шрифта задает внешний стиль отображения символов. Имена претерпели
        ряд изменений с развитием Java. В версии 1.0 требовалось, что­бы JVM поддерживала следующие
        шрифты: TimesRoman, Helvetica, Courier. Могут поддерживаться и другие семейства, это зависит
        от деталей
        реализации конкретной виртуальной машины. Чтобы узнать полный спи­сок во время
        исполнения программы, можно воспользоваться методом ути-литного класса Toolk't. Экземпляры
        этого
        класса нельзя создать вручную, поэтому полностью такой запрос будет выглядеть
        следующим образом:
    </p>
    <p>Toolkit.getDefaultToolkit().getFontьst()
    </p>
    <p>В результате будет возвращен массив строк-имен семейств поддерживаемых
        шрифтов.
    </p>
    <p>В Java 1.1 три
        обязательных имени были объявлены deprecated. Вместо них был введен новый список, который
        содержал более
        универсальные названия, не зависящие от конкретной операционной системы: Serif, SansSerif,
        Monospaced.
    </p>
    <p>В Java 2 библиотека AWT была существенно пересмотрена 11 дополнена. Чтобы устранить
        неоднозначности с разной поддержкой шрифтов на разных платформах, было
        произведено разделение на логические и физические шрифты.  Вторая  группа
        определяется
    </p>
    <p>^ожностями операционной
        системы, это те же шрифты, которые ^гут использовать другие программы,
        запущенные на этой платформе.
    </p>
    <p>Первая группа состоит из 5 обязательных семейств (добавились n'alog и Dialoglnput). JVM
        устанавливает
        соответствие между ними и
    </p>
    <p>иболее подходящими из доступных физических шрифтов. 1   
        Метод getFontList класса Toolkit был объявлен deprecated. Теперь цоЛУчитЬ список всех
        доступных
        физических шрифтов можно следую-образом:
    </p>
    <p>GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailable FontFamilyNames()
    </p>
    <p>Класс Font является
        неизменяемым. После создания можно узнать заданное логическое имя (метод getName) и
        соответствующее
        ему физи­ческое имя семейства (метод getFamily).
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Вернемся к остальным параметрам, необходимым для создания экземпляра Font. Размер шрифта
        определяет, очевидно, величину символов. Однако конкретные значения измеряются
        не в пикселах, а в условных единицах (как и во многих текстовых редакторах).
        Для разных семейств шрифтов символы одинакового размера могут иметь различную
        ширину и высоту, измеренную в пикселах.
    </p>
    <p>Как и в случае
        имени шрифта, программист может указать любое значение размера, a JVM поставит ему в
        соответствие максимально близ­кий из доступных.
    </p>
    <p>Наконец, последний параметр - стиль. Этот параметр определяет, будет ли
        шрифт жирным, наклонным и т.д. Если никакие из этих свойств не требуются,
        указывается Font.PLAIN (параметр имеет тип
        int и в классе Font определен набор
        констант для удобства работы с ним). Значение Font.BOLD задает жирный шрифт, a Font.ITALIC —
        наклонный. Для
        соче­тания этих свойств (жирный наклонный шрифт) необходимо произвести
        логическое сложение: Font.BOLD | Font.ITALIC.
    </p>
    <p>Для работы с этим свойством класса Component предназначены ме­тоды
        setFont и getFont.
    </p>
    <p>Итак, мы
        рассмотрели основные свойства класса Component. Как ЛеПсо видеть, все они предназначены для
        описания
        графического пред-^вления компонента, то есть отображения на экране.
    </p>
    <table cellpadding="0" cellspacing="0" height="16" hspace="0" vspace="0">
        <tr>
            <td align="left" height="16" valign="top">
                <p>COnt;
                </p>
            </td>
        </tr>
    </table>
    <p>Существует еще одно
        важное свойство другого характера. Очевидно, "То Практически всегда
        пользовательский интерфейс состоит из более ^м одного компонента. В
        больших приложениях их обычно гораздо ЛьШе. Для удобства организации
        работы с ними компоненты объединя­йся в контейнеры. В AWT существует класс, который так и
        называется —
    </p>
    <p>ainer. Его рассмотрение
        - наша следующая тема. Важно отметить,
    </p>
    <p>
    </p>
    <p>что компонент может находиться лишь в одном контейнере — при ПОПЬГк ке добавить его в другой
        он удаляется из первого. Рассматриваемое свои, ство как раз и отвечает за связь
        компонента с контейнером. Свойство на­зывается parent. Благодаря нему
        компонент всегда "знает", в каком кон­тейнере он
        находится.
    </p>
    <p>
    </p>
    <p>Container
    </p>
    <p>Контейнер описывается классом Container, который является на­следником Component, а значит,
        обладает всеми свойствами графического компонента. Однако
        основная его задача — группировать другие компо­ненты. Для этого в нем объявлен
        целый ряд методов. Для добавления слу­жит метод add, для удаления - remove и removeAII
        (последний удаляет
        все компоненты).
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Добавляемые компоненты хранятся в упорядоченном списке, поэто­му для
        удаления можно указать либо ссылку на компонент, который и бу­дет удален, либо
        его порядковый номер в контейнере. Также определены методы для получения
        компонент, присутствующих в контейнере, — все они довольно очевидны, поэтому
        перечислим их с краткими пояснениями:
    </p>
    <p>•
        getComponent(int п) - возвращает
        компонент с указанным поряд­ковым номером;
    </p>
    <p>•
        getComponentsO - возвращает все компоненты
        в виде массива;
    </p>
    <p>•
        getComponentCountQ
        — возвращает количество
        компонент;
    </p>
    <p>•
        getComponentAt(int
        х, int у) или (Point р) - возвращает компо­нент, который включает в
        себя указанную точку;
    </p>
    <p>•
        findComponentAt(int
        х, int у) или (Point р) - возвращает
        видимый компонент, включающий в себя указанную точку.
    </p>
    <p>Мы уже знаем, что положение компонента (location) задается ко­ординатами
        левого верхнего угла. Важно, что эти значения отсчитыва-ются от левого верхнего
        угла контейнера, который таким образом явля­ется центром системы координат для
        каждого находящегося в нем ком­понента. Если важно расположение компонента на
        экране безотноси­тельно его контейнера, можно воспользоваться методом getLocationOnScreent.
    </p>
    <p>Благодаря наследованию контейнер также имеет свойство size. Этот размер
        задается независимо от размера и положения вложенных компонент Таким образом,
        компоненты могут располагаться частично или полностью за пределами своего
        контейнера (что это означает, будет рассмотрено ния^-но принципиально это
        допустимо).
    </p>
    <p>Раз контейнер наследуется от Component, он сам является коМ' понентом, а значит, может быть
        добавлен в другой, вышестоящий кон тейнер. В то же время
        компонент может находиться лишь в одном к°н
    </p>
    <p>
        ^^22                                                                                                                   
        Пакет
        jva.awt
    </p>
    <p>еЙнере-
        Это означает, что все элементы сложного пользовательского цтерФеиса
        объединяются в иерархическое дерево. Такая организация ц6 только
        облегчает операции над ними, но и задает основные свойст-ва реей
        работы AWT. Одним из них является принцип отрисовки ком­понентов.
    </p>
    <p>
    </p>
    <p>Алгоритм
        отрисовки
    </p>
    <p>Начнем с отрисовки отдельного компонента — что определяет его внешний
        вид?
    </p>
    <p>Для этой задачи предназначен метод paint. Этот метод
        вызывается каждый раз, когда необходимо отобразить компонент на экране
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> У него
        есть один аргумент, тип которого - абстрактный класс Graphics. В этом классе
        определено множество методов для отрисовки простейших графи­ческих элементов —
        линий, прямоугольников и многоугольников, окруж­ностей и овалов, текста,
        картинок и т.д.
    </p>
    <p>Наследники класса Component переопределяют
        метод paint и, пользу­ясь
        методами Graphics, задают алгоритм прорисовки своего внешнего вида:
    </p>
    <p>
    </p>
    <p>public void
        paint(Graphics g) {
    </p>
    <p>g.drawLine(0, 0, getWidth(), getHeight());
        g.drawLine(0, getHeight(), getWidth(), 0);
    </p>
    <p>}
    </p>
    <p>В этом примере
        компонент будет отображаться двумя линиями, проходящими по его диагоналям:
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>Методы класса Graphics для отрисовки
    </p>
    <p>Рассмотрим обзорно методы класса Graphics, предназначенные
        для Рисовки.
    </p>
    <p>
    </p>
    <p>drawLine(x1, у1, х2,
        у2)
    </p>
    <p>^,   Этот метод отображает линию толщиной в 1 пиксел,
        проходящую из (*1 &gt; у1) в (х2, у2). Именно он использовался в предыдущем
        примере.
    </p>
    <p>
        Курс                                                                                            
        Программирование
        на jav.
    </p>
    <p>drawRectfint х, int у, int width, int height)
    </p>
    <p>Этот метод отображает прямоугольник, чей левый верхний угол на.\0 дится
        в точке (х, у), а ширина и высота равняются width и height соответ.
        ственно. Правая сторона пройдет по линии x+width, а нижняя - y+height
    </p>
    <p>Предположим, мы хотим дополнить предыдущий пример рисовани­ем рамки
        вокруг компонента (периметр). Понятно, что левый верхнцц угол находится в точке
        (0, 0). Если ширина компонента равна, например 100 пикселам, то координата х пробегает
        значения от 0 до 99. Это означа­ет, что ширина и высота рисуемого прямоугольника должны быть
        умень­шены на единицу. На самом деле по той же причине в предыдущем при­мере
        такое уменьшение на единицу должно присутствовать и в остальных методах:
    </p>
    <p>
    </p>
    <p>public void
        paint(Graphics g) {
    </p>
    <p>g.drawLine(0, 0, getWidth()-1, getHeight()-1); g.drawLine(0,
        getHeight()-1, getWidth()-1, 0); g.drawRect(0, 0, getWidht()-1, getHeight()-1);
    </p>
    <p>}
    </p>
    <p>В результате компонент
        примет следующий вид:
    </p>
    <p></p>
    <center><img border="0" height="80" src="http://kufas.ru/java.files/image020.jpg" width="200">
    </center>
    <p>
    </p>
    <p>fillRect(int х, int у, int width, int height)
    </p>
    <p>Этот метод закрашивает прямоугольник. Левая и правая стороны пр*
        моугольника проходят по линиям х и x+width-1 соответственно,
        а верхняя нижняя - у и y+height-1 соответственно. Таким образом, чтобы зарисовш все пикселы
        компонента,
        необходимо передать следующие аргументы:
    </p>
    <p>
    </p>
    <p>g.fillRect(0, 0, getWidthO, getHeight());
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>drawOvalfint х, int у, int width, int height)
    </p>
    <p>Этот метод рисует овал, вписанный в прямоугольник, задаваемы указанными
        параметрами. Очевидно, что если прямоугольник имеет ра' ные стороны
        (т.е. является квадратом), овал становится окружностью-
    </p>
    <p>Снова для того, чтобы вписать овал в границы компонента, необхо-&gt;
        вычесть по единице из ширины и высоты:
    </p>
    <p>g.drawRect(0, 0, детМ/кЩН, детШд1т1()-1); д^га\л/Оуа1(0, 0, дет.\Шт()-1,
        деШе1д^()-1);
    </p>
    <p>
    </p>
    <p>Результат:
    </p>
    <p></p>
    <center><img border="0" height="90" src="http://kufas.ru/java.files/image021.jpg" width="200">
    </center>
    <p>fillOvalfint х, int у, int width, int height)
    </p>
    <p>Этот метод закрашивает
        указанный овал.
    </p>
    <p>
    </p>
    <p>drawArcfint
        х, int у, int width, int height, int startAngle, int
    </p>
    <p>arcAngle)
    </p>
    <p>Этот метод рисует дугу - часть овала, задаваемого первыми четырьмя
        параметрами. Дуга начинается с угла startAngle и имеет угловой размер arcAngle. Начальный
        угол соответствует направлению часовой стрелки, указывающей на
        3 часа. Угловой
        размер отсчитывается против часовой стрелки. Таким образом, размер в 90 градусов
        соответствует дуге 1 Четверть овала
        (верхнюю правую). Углы "растянуты" в соответствии с Номером
        прямоугольника. В результате, например, угловой размер в 45 ЩЩусов всегда задает границу
        дуги по линии, проходящей из центра
        Шямоугольника в его правый верхний угол.
    </p>
    <p>
    </p>
    <p>Krc(intx, int у, int width, int height, int startAngle, int arcAngle)
    </p>
    <p>Этот метод закрашивает сектор, ограниченный дугой,
        задаваемой аметрами.
    </p>
    <p>
    </p>
    <p>drawStringfString text, intx, int у)
    </p>
    <p>Этот метод выводит на экран текст, задаваемый первым параметром, (х, у)
        задает позицию самого левого символа. Для наглядности Ведем пример:
    </p>
    <p>g.drawStringfabcdefgh",
        15, 15); g.drawLine(15, 15, 115, 15);
    </p>
    <p></p>
    <center><img alt="Подпись: 348" height="15" src="http://kufas.ru/java.files/image022.png"
                 width="23"></center>
    <p>349
    </p>
    <p></p>
    <center><img height="95" src="http://kufas.ru/java.files/image023.png" width="444"></center>
    Состояние Graphics
    <p>Экземпляр класса Graphics хранит параметры,
        необходимые для от. рисовки. Рассмотрим их по порядку.
    </p>
    <p>
    </p>
    <p>Цвет
    </p>
    <p>Очевидно, что для отрисовки линий, овалов, текста и т.д необходимо использовать тот или иной
        цвет. По умолчанию он задается
        свойством foreground компонента. В любой
        момент его можно изменить с помощью метода setColor.
    </p>
    <p>Рассмотрим пример:
    </p>
    <p>public void paint(Graphics g) { for (int i=0; i&lt;4; i++) { for (int j=0;
        j&lt;4; j++) {
    </p>
    <p>intc =
        (int)((i+j)/6.*255); g.setColor(new Color(c, с, c));
    </p>
    <p>g.fillRect(i*getWidth()/4, j*getHeight()/4,
        getWidth()/4, getHeight()/4);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <table cellpadding="0" cellspacing="0" height="125" hspace="0" vspace="0">
        <tr>
            <td align="left" height="125" valign="top">
                <p></p>
                <center><img border="0" height="125" src="http://kufas.ru/java.files/image024.jpg"
                             width="155"></center>
            </td>
        </tr>
    </table>
    <p>
    </p>
    <p>В результате компонент
        будет иметь следующий вид:
    </p>
    <p>Шрифт
    </p>
    <p>Метод drawString не имеет аргумента,
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>задающего шрифт для вывода теКСта на экРан- Этот параметр также является частью состояния
        graph'cs- ^го значение
        по умолчанию задается соответствующим свойст­вом
        компонента, однако может
        быть изменено с помощью метода getFont. Для получения текущего значения служит метод
        getFont.
    </p>
    <p>Clip (ограничитель)
    </p>
    <p>Хотя методы класса Graphics могут принимать любые значения аргу­ментов, задающих значения
        координат
        (в пределах типа int), существует дополнительный ограничитель - clip. Любые изменения вне
        этого ограни­чителя на экране появляться не будут. Например, если вызвать метод
        drawLine(-l00, -100, 1000, 1000), то на компоненте отобразится лишь часть линии,
        которая помещается в его границы.
    </p>
    <p>Размеры ограничителя можно изменять. Метод clipRect(int х, int у, intwidth, int
        height) вычисляет пересечение
        указанного прямоугольника и текущей области clip. Результат станет
        новым ограничителем. Таким об­разом, этот метод может только сужать область clip. Метод
        setClip(int х, int у, intwidth, int
        height) устанавливает ограничитель
        произвольно в фор­ме прямоугольника. Метод getClipBounds возвращает текущее значение в виде
        объекта Rectangle.
    </p>
    <p>При появлении приложения на экране каждый видимый компонент должен быть
        отрисован полностью. Поэтому при первом вызове метода paint, как правило,
        область clip совпадает с границами компонента. Од­нако при дальнейшей работе это не
        всегда так.
    </p>
    <p>Рассмотрим следующий
        пример:
    </p>
    <p>
    </p>
    <p>public void
        paint(Graphics g) {
    </p>
    <p>Color с = new
        Color((int)(Math.random()*255),
    </p>
    <p>(int)(Math.random()*255),
        (int)(Math.random()*255)); g.setColor(c); //g.setClip(null);
    </p>
    <p>g.fillRect(0, 0, getWidth(),
        getHeight());
    </p>
    <p>}
    </p>
    <p>Как видно из кода, при каждом вызове метода paint генерируется но-^
        значение цвета, после чего этим цветом закрашивается весь компонент.
    </p>
    <p>Днако поскольку в Graphics есть ограничитель, закрашена будет только °°Ласть clip, что
        позволит ее
        увидеть.
    </p>
    <p>После запуска программы компонент будет полностью окрашен °*Ним цветом.
        Если теперь с помощью мыши "взять" окно какого-нибудь
    </p>
    <p></p>
    <center><img
            alt='Подпись: другого приложения и медленно "провести" им поверх компонента, ТО окрасится примерно таким образом (левая картинка):'
            height="43" src="http://kufas.ru/java.files/image025.png" width="434"></center>
    <center><img border="0" height="78" src="http://kufas.ru/java.files/image026.jpg" width="189">
    </center>
    <p>
    </p>
    <p>Если же провести быстро, то получится картинка, подобная правой в примере выше. Хорошо
        видно, что компонент перерисовывается Не полностью, а частями.
        Ограничитель выставляется в соответствии с тон областью, которая оказалась
        "повреждена" и нуждается в перерисовке Для сложных компонентов
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>можно
        ввести логику, которая, используя clip будет отрисовывать не все элементы, а только
        некоторые из них, для уве­личения
        производительности.
    </p>
    <p>В примере закомментирована одна строка, в которой передается значение null в метод setClip.
        Такой вызов снимает все ограничения, по­этому компонента каждый
        раз будет перекрашиваться полностью, меняя при этом цвет. Однако никаким
        образом нельзя изменить состояние пик­селов вне компонента -
        ограничитель не может быть шире, чем границы компонента.
    </p>
    <p>
    </p>
    <p>Методы repaint и update
    </p>
    <p>Кроме paint в классе Component объявлены еще два
        метода, отвеча­ющие за прорисовку компонента. Как было рассмотрено, вызов paint
        ини­циируется операционной системой, если возникает необходимость пере­рисовать
        окно приложения, или часть его. Однако может потребоваться обновить внешний
        вид, руководствуясь программной логикой. Например, отобразить результат
        операции вычисления, или работы с сетью. Можно изменить состояние компонента
        (значение его полей), но операционная система не отследит такое изменение и не
        инициирует перерисовку.
    </p>
    <p>Для программной инициализации перерисовки компонента служит метод repaint. Конечно, у него
        нет аргумента типа Graphics, поскольку программист не должен создавать экземпляры этого
        класса
        (точнее, его наследников, ведь Graphics - абстрактный
        класс). Метод repaint можно вызывать без
        аргументов. В этом случае компонент будет перерисован максимально быстро. Можно
        указать аргумент типа long - количеств'1 миллисекунд.
        Система инициализирует перерисовку спустя указанно1-время. Можно
        указать четыре числа типа int (х, у, width, height), задаваЯ прямоугольную область
        компонента, которая
        нуждается в перерисовка раконец, можно указать все 5 параметров - и задержку по времени, и
        об­дасть перерисовки.
    </p>
    <p>Если перерисовка инициируется приложением, то система вызывает де метод paint, а метод
        update. У него уже есть
        аргумент типа Graphics и по ^олчанию он
        лишь закрашивает всю область компонента фоновым цветом (свойство background), а затем
        вызывает метод paint. Зачем же было
        вводить ріст дополнительный метод, если можно было сразу вызвать paint? Дело в фМ, что
        поскольку перерисовка инициируется приложением, для сложных компонентов
        становится возможной некоторая оптимизация обновления
    </p>
    <table cellpadding="0" cellspacing="0" hspace="0" vspace="0">
        <tr>
            <td align="left" valign="top">
                <p>t
                </p>
            </td>
        </tr>
    </table>
    <p>euiHero вида. Например,
        если изменение заключается в появлении
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>ново-графического элемента, то можно
        избежать повторной перерисовки ос-Цдьных элементов - переопределить метод update и
        реализовать в нем ото-Емжение одного только нового элемента. Если же
        компонент имеет про-Жую структуру, можно оставить метод update без изменений.
    </p>
    <p>
    </p>
    <p>Прорисовка контейнера
    </p>
    <p>Теперь, когда известно, как работает прорисовка компонента, пе­рейдем к рассмотрению
        контейнера. Для его корректного отображения необходимо
        выполнить два действия. Во-первых, нарисовать сам контей­нер, ведь он является
        наследником компоненты, а значит, имеет метод paint, который может быть
        переопределен для задания особенного внеш­него вида такого контейнера.
        Во-вторых, инициировать отрисовку всех компонентов, вложенных в него.
    </p>
    <p>Первый шаг ничем не отличается от прорисовки обычного компо­нента. Как
        правило, контейнер не содержит никаких особых элементов отображения, ведь
        основную его площадь занимают вложенные компо­ненты. Поэтому перейдет ко
        второму шагу.
    </p>
    <p>Если контейнер не пустой, значит, в нем есть одна или несколько
        компонент. Они будут отрисованы последовательно в том порядке, в ка­ком были
        добавлены. Однако недостаточно просто в цикле вызвать метод Paint для каждого
        компонента.
    </p>
    <p>Во-первых, если компонента невидима (свойство visible выставлено вfalse), то, очевидно, метод
        paint у нее вызываться не
        должен.
    </p>
    <p>Во-вторых, центр координат компонента находится в левом верхнем уг-ЛУ его
        контейнера, а у контейнера - в левом верхнем углу его контейнера. Та-Ким
        образом, при переходе от отрисовки контейнера к отрисовке лежащего в Ием
        компонента необходимо изменить (перенести) центр системы координат.
    </p>
    <p>Затем необходимо установить clip в соответствии с размером очеред­ного компонента. Необходимо
        выставить
        значения по умолчанию для Чвета и шрифта, тем более что предыдущий компонент
        мог изменить их ^предсказуемым образом.
    </p>
    <p>В итоге получается более удобным создать новый экземпляр Graphics для каждого компонента. Для
        этого существует метод create который порождает
        копию Graphics, причем ему можно передать аргу менты (int х, int у, int width, int height).
        В результате y нового Graphics бу­дет смещен центр координат в точку (х, у), а clip-область
        будет получена пересечением существующего ограничителя с
        прямоугольником (О, О width, height) (в новых координатах). Метод create создает копию без
        из­менения этих параметров.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Такие копии бывает удобно порождать и в рамках одного вызова ме­тода paint, если в нем описан
        слишком сложный алгоритм. После исполь­зования такого объекта Graphics его необходимо особым
        образом осво­бождать - вызовом метода dispose(). Если необходимо только сместить точку
        отсчета координат, можно
        использовать метод translate (int х, int у).
    </p>
    <p>Таким образом, контейнер своим методом paint отрисовывает себя и
        все вложенные в него компоненты. Если какие-то из них, в свою очередь, являются
        контейнерами, то процесс иерархически продолжается вглубь. В итоге весь AWT интерфейс, каким
        бы
        сложным он ни был, состоит m дерева контейнеров и компонент, отрисовка которых начинается с
        самого
        верхнего контейнера и по ветвям развивается вглубь до каждого видимого
        компонента.
    </p>
    <p>Отдельный интерес представляет этот самый верхний контейнер. Как
        правило, это окно операционной системы, одновременно являюще­еся контейнером
        для Java-компонент. Именно операционная система инициализирует процесс
        отрисовки, отвечает за сворачивание и развора­чивание окна, изменение его
        размера и так далее. Со стороны Java для работы с окном используется класс Window, который
        является
        наследни­ком Container и рассматривается ниже.
    </p>
    <p>
    </p>
    <p>Наследники класса Comportent
    </p>
    <p>Теперь, когда рассмотрены основные принципы работы классов Component и Container, рассмотрим
        их наследников, с помощью которых и строится функциональный
        пользовательский интерфейс.
    </p>
    <p>Начнем с наследников
        класса Component.
    </p>
    <p>
    </p>
    <p>Класс
        Canvas
    </p>
    <p>Класс Canvas является простейшим наследником Component. Он не добавляет
        никакой новой функциональности, но именно его нужно использовать в качестве
        суперкласса для создания пользовательского компонента с некоторым нестандартным
        внешним видом.
    </p>
    <p>Ниже приведен пример определения компонента, который отображает график
        функции sin(x): public class SinCanvas extends Canvas {
    </p>
    <p>public void
        paint(Graphics g) {
    </p>
    <p>int height = getHeight(), width = getWidth();
    </p>
    <p>//
        Вычисляем масштаб таким образом, чтобы
    </p>
    <p>// на
        компоненте всегда умещалось 5 периодов
    </p>
    <p>double
        k=2*Math.PI*5/width;
    </p>
    <p>int sy =
        calcY(0, width, height, k);
    </p>
    <p>for (int
        i=1; Kwidth; i++) {
    </p>
    <p>int nsy = calcY(i, width, height, k);
    </p>
    <p>g.drawLine(i-1, sy, i, nsy);
    </p>
    <p>sy=nsy;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>// метод, вычисляющий значение
        функции
    </p>
    <p>// для отображения на экране
    </p>
    <p>private int
        calcY(int х, int width, int height, double k) {
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>double dx = (x-width/2.)*k;
    </p>
    <p>return (int)(height/2.*(1-Math.sin(dx)));
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Как видно из примера, достаточно лишь переопределить метод paint. Вот как выглядит
        такой компонент:
    </p>
    <p></p>
    <center><img border="0" height="83" src="http://kufas.ru/java.files/image027.jpg" width="193">
    </center>
    <p>
    </p>
    <p>Класс Label
    </p>
    <p>Как понятно из названия, этот компонент отображает надпись. Со­ответственно,
        и его основной конструктор принимает один аргумент ти­па String - текст надписи. С помощью
        стандартных свойств класса Component — шрифт, цвет,
        фоновый цвет — можно менять вид надписи. Текст можно сменить и после создания Label с
        помощью метода setText.
    </p>
    <p>Обратите внимание, что при этом компонент сам обновляет свой вид На
        экране. Такой особенностью обладают все стандартные компоненты AWT.
    </p>
    <p>Класс Button
    </p>
    <p>Этот компонент позволяет добавить в интерфейс стандартные кнопки.
        Основной конструктор принимает в качестве аргумента String — надпись на кнопке. Как
        обрабатывать нажатие на кнопку и другие
        пользовательские события, рассматривается ниже.
    </p>
    <p>Классы Checkbox и CheckboxGroup
    </p>
    <p>Компонент Checkbox имеет два способа применения.
    </p>
    <p>Когда он используется сам по себе, он представляет checkbox — эле­мент, который может быть
        выделен или нет (например, нужна доставка
        для оформляемой покупки или нет). В этом случае в конструктор передается лишь
        текст — подпись к checkbox.
    </p>
    <p>Рассмотрим пример, в котором в теле контейнера добавляется два checkbox:
    </p>
    <p>
    </p>
    <p>Checkbox
        payment = new Checkbox("Оплата в кредит");
    </p>
    <p>payment.setBounds(lO,
        10, 120, 20);
    </p>
    <p>add(payment);
    </p>
    <p>Checkbox
        delivery = new С1пескЬох("Доставка"); delivery.setBounds(lO, 30, 120, 20); add(delivery);
    </p>
    <p>
    </p>
    <p>Ниже приведен внешний вид
        такого контейнера:
    </p>
    <p></p>
    <center><img border="0" height="56" src="http://kufas.ru/java.files/image028.jpg" width="152">
    </center>
    <p>
    </p>
    <p>
    </p>
    <p>Обратите внимание, что размер Checkbox должен быть достаточным для размещения не только поля
        для
        "галочки", но и для подписи.
    </p>
    <p>Второй способ применения компонент Checkbox предназначен для организации "переключателей"
        (radio buttons). В этом случае
        несколько экземпляров объединяются в группу, причем лишь один их переключате­лей
        может быть выбран. В роли такой группы выступает класс CheckboxGroup. Он не является
        визуальным, то есть никак не отобража­ется на экране.
        Его задача — логически объединить несколько Checkbox. Группу, к которой
        принадлежит переключатель, можно указывать в кон­структоре:
    </p>
    <p>CheckboxGroup delivery = new CheckboxGroupO; Checkbox
        fast = new Checkbox("Cp04Han (1 день)",
    </p>
    <p>delivery, false); fast.setBounds(10, 10,
        150, 20); add(fast);
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Checkbox normal = new Checkbox("06bi4Hap (1 неделя)", delivery,
        true);
    </p>
    <p>normal.setBounds(l0,
        30, 150, 20);
    </p>
    <p>add(normal);
    </p>
    <p>Checkbox postal
        = new CheckboxfTlo почте (до 1 месяца)",
    </p>
    <p>delivery, false); postal.setBounds(10, 50,
        150, 20); add(postal);
    </p>
    <p>Ниже приведен внешний вид
        такого контейнера:
    </p>
    <p></p>
    <center><img border="0" height="79" src="http://kufas.ru/java.files/image029.jpg" width="123">
    </center>
    <p>В примере при вызове конструктора класса Checkbox помимо текс­та подписи и группы,
        указывается состояние переключателя
        (булевский параметр). Обратите внимание на изменение внешнего вида компонента
        (форма поля сменилась с квадратной на круглую, как и принято в тради­ционных GUI).
    </p>
    <p>Классы Choice и List
    </p>
    <p>Компонент Choice служит для выбора
        пользователем одного из нескольких возможных вариантов (выпадающий список).
        Рассмотрим пример:
    </p>
    <p>Choice color = new Choice(); color.addf'Benbin"); color.add("Зeлeный");
        color.add("CHHMu"); color.addf'MepHbiui"); add(color);
    </p>
    <p>Курс
    </p>
    <p>Программирование на .Ь^
    </p>
    <p>оиантВВпппН°М СОС™ЯНИИ компонент отображает только выбранный ва
        риант. В процессе выбора отображается весь набор вашгат™ ня п
        представлен выпадающий список в обоих
        состояниях                                                      *
    </p>
    <p></p>
    <center><img border="0" height="87" src="http://kufas.ru/java.files/image030.jpg" width="98">
    </center>
    <p>Обратите внимание,
        что для компонента Choice всегда есть выбран­ный
        элемент.
    </p>
    <p>Компонент List, подобно Choice, предоставляет пользователю воз­можность выбирать варианты из
        списка
        предложенных. Отличие заклю­чается в том, что List отображает сразу несколько вариантов.
        Количество задается в
        конструкторе:
    </p>
    <p>
    </p>
    <p>List accessories = new List(3); accessories. add("4exon"); accessories.add("HaymHHKH");
        accessories. асУСАккумулятор"); accessories. add("BnoK питания"); add(accessories);
    </p>
    <p>
    </p>
    <p>Вот как выглядит такой
        компонент (верхняя часть рисунка):
    </p>
    <p></p>
    <center><img border="0" height="98" src="http://kufas.ru/java.files/image031.jpg" width="148">
    </center>
    <p>В списке находится 4 варианта. Однако в конструктор был передан параметр
        3, поэтому только 3 из них видны на экране. С помощью полосы прокрутки можно
        выбрать остальные варианты.
    </p>
    <p>Рисунок иллюстрирует еще одно свойство List - возможность вы­брать сразу несколько из
        предложенных вариантов. Для
        этого надо либо в конструкторе вторым параметром передать булевское значение true (false
        соответствует выбору только одного элемента), либо воспользоваться мето­дом
        setMultipleMode.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>Классы TextComponent, TextField, TextArea
    </p>
    <p>Класс TextComponent является
        наследником Component и базовым классом
        для компонент, работающих с текстом,— TextField и TextArea.
    </p>
    <p>TextField позволяет вводить и
        редактировать одну строку текста. Раз­личные методы позволяют управлять
        содержимым этого поля ввода:
    </p>
    <p>TextField tf = new TextField(); tf.setText("Enter
        your name"); tf.selectAIIO; add(tf);
    </p>
    <p>
    </p>
    <p>Вот как будет выглядеть этот компонент:
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>В коде вторая строка устанавливает значение текста в поле ввода (метод getText позволяет
        получить текущее значение). Затем весь текст выделяется (есть
        методы, позволяющие выделить часть текста).
    </p>
    <p>Для любой текстовой компоненты можно задать особый режим. В базовом
        классе Component определено свойство
        enabled, которое, если выставлено в false, блокирует все
        пользовательские события. Для текстовой компоненты вводится новое свойство — editable (можно
        редактировать), методы для работы с ним — isEditable и setEditable. Если текст нельзя
        ре­дактировать, но компонент доступен, то
        пользователь может выделить часть, или весь текст, и, например, скопировать его
        в буфер.
    </p>
    <p>TextField обладает еще одним
        свойством. Все хорошо знакомы с полем ввода для пароля - вводимые символы не
        отображаются, вместо них появ­ляется один и тот же символ. Для TextField его можно
        установить с помо­щью метода setEchoChar (например, setEchoChar('*')).
    </p>
    <p>TextArea позволяет вводить и просматривать многострочный текст. В конструктор
        передается количество строк и столбцов, которые определя­ют размер компонента
        (вычисляется на основе средней ширины символа). Эти параметры не ограничивают
        длину вводимого текста - при необходи­мости появляются полосы прокрутки:
    </p>
    <p></p>
    <center><img border="0" height="91" src="http://kufas.ru/java.files/image032.jpg" width="210">
    </center>
    <p>
    </p>
    <table align="left" cellpadding="0" cellspacing="0">
        <tr>
            <td height="0" width="482"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <center><img alt="Подпись:  " height="26"
                             src="http://kufas.ru/java.files/image033.png" width="52"></center>
            </td>
        </tr>
    </table>
    <p>Класс Scrollbar
    </p>
    <p>Класс Scrollbar позволяет работать
        с полосами прокрутки, которые используются для перемещения внутренней области
        от начальной до ко нечной позиции. Полоса может быть расположена горизонтально
        или вертикально. Стрелки на каждом из ее концов служат для перемещения "на
        один шаг" в соответствующем направлении. "Взявшись" курсором
        мыши за бегунок, можно переместить его в любую позицию. С помощью кликов мыши по полосе
        прокрутки, но вне
        положения бегунка, МОЖНО делать перемещение "на страницу" вверх или вниз. Все эти
        действия хоро­шо знакомы по многим пользовательским интерфейсам, например, Windows. Они
        полностью
        поддерживаются компонентом Scrollbar.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Конструктор позволяет задавать ориентацию полосы прокрутки --для этого
        предусмотрены константы VERTICAL и HORIZONTAL. Кроме того, с помощью конструктора можно
        задать начальное положение
        бегун­ка, размер "страницы", а также минимальное и максимальное
        значения, в пределах которых линейка прокрутки может изменять параметр. Для по­лучения
        и установки текущего состояния полосы прокрутки используют­ся методы getValue и setValue.
        Ниже приведен пример, в котором созда­ется и вертикальный, и горизонтальный Scrollbar.
    </p>
    <p>
    </p>
    <p>int height =
        getHeight(), width = getWidth(); int thickness = 16; Scrollbar hs = new
        Scrollbar(Scrollbar.HORIZONTAL, 50, width/10, 0, 100); Scrollbar
        vs = new Scrollbar(Scrollbar.VERTICAL, 50, height/2, 0, 100); add(hs); add(vs);
    </p>
    <p>hs.setBounds(0, height - thickness, width - thickness,
        thickness); vs.setBounds(width - thickness, 0, thickness, height - thickness);
    </p>
    <p>В этом примере
        скроллируется, конечно, пустая область:
    </p>
    <p></p>
    <center><img border="0" height="89" src="http://kufas.ru/java.files/image034.jpg" width="161">
    </center>
    <p>Наследники
        Container
    </p>
    <p>Теперь перейдем к
        рассмотрению стандартных контейнеров AVVT.
    </p>
    <p>
    </p>
    <p>Класс Panel
    </p>
    <p>Подобно тому, как Canvas служит базовым
        классом для создани. своих компонент с особым внешним видом, класс Panel являете:
    </p>
    <p>улерклассом для новых контейнеров с особой работой с вложенными
        компонентами. Впрочем, поскольку Panel, в отличие от Container, класс не абстрактный, его
        можно использовать для
        иерархической организации сложного пользовательского интерфейса, группируя
        компоненты в такие Простейшие контейнеры.
    </p>
    <p>Класс ScrollPane
    </p>
    <p>Выше был рассмотрен компонент Scrollbar, предназначенный для полосы прокрутки. Если стоит
        задача, например,
        показать пользователю график некоторой функции с возможностью просмотра для
        изучения раз­личных областей, необходимо создать две полосы прокрутки,
        правильно их установить и в дальнейшем обрабатывать все действия пользователя,
        вы­числять новое положение видимой области, перерисовывать график и т.д.
    </p>
    <p>В большинстве случаев все эти задачи может взять на себя контейнер ScrollPane. Этот контейнер
        обладает рядом особенностей. Во-первых, в него можно
        поместить лишь одну компоненту — при добавлении новой старая удаляется.
        Во-вторых, отличается работа с вложенным компонен­том, чьи границы выходят за
        границы самого контейнера
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Как мы рассма­тривали раньше,
        "выступающие" области никогда не будут отображены на экране. В
        контейнере ScrollPane в этом случае
        появляются полосы про­крутки (горизонтальная или вертикальная), с помощью
        которых можно промотать видимую область и таким образом увидеть весь компонент
        полностью. При этом не нужно предпринимать никаких дополнительных действий —
        надо лишь добавить компонент в ScrollPane.
    </p>
    <p>Может вызвать удивление, почему разрешается добавление лишь од­ного
        компонента. А если нужно проматывать более сложную конструкцию? Здесь и
        проявляется польза класса Panel. Все элементы собираются в этот простейший контейнер,
        который, в свою
        очередь, добавляется в ScrollPane.
    </p>
    <p>Конструктор этого класса может принимать параметр, задающий ло­гику
        появления полос прокрутки — они могут быть видимы всегда, появ­ляться по мере
        необходимости, либо не появляться никогда.
    </p>
    <p>
    </p>
    <p>Класс Window
    </p>
    <p>Из опыта работы с оконными графическими интерфейсами современ­ных
        операционных систем мы привыкли к тому, что каждое приложение об­ладает одним
        или несколькими окнами. Класс Window служит базовым
        Классом для всех окон, порождаемых из Java. Разумеется, он
        также является Интерфейсом к соответствующему окну операционной системы,
        которая ^луживает окна всех приложений.
    </p>
    <p>Как правило, используется один из двух наследников Window -Классы Frame и Dialog, которые
        будут
        рассмотрены следующими. Одна-
    </p>
    <p>Курс
    </p>
    <p>*
        'рограммирование Haja,.
    </p>
    <p>11________________________________________________________________ Пакет
        jva.awt
    </p>
    <p>ко экземпляры Window не обладают ни
        рамкой, ни кнопками закрытия или минимизации окна, а потому зачастую
        используются как заставки (так называемые splash screen).
    </p>
    <p>Конструктор Window требует в качестве
        аргумента ссылку на Window или Frame. Другими словами,
        базовые окна не являются самостоятель­ными, они привязываются к другим окнам.
    </p>
    <p>
    </p>
    <p>Классы Frame и Dialog
    </p>
    <p>Класс Frame предназначен для
        создания полнофункциональных окон приложений - с полосой заголовка, рамкой,
        кнопками закрытия, минимизации и максимизации окна. Поскольку Frame, как правило, яв­ляется
        главным окном приложения, он создается невидимым, чтобы можно было настроить
        все его параметры, добавить все вложенные кон­тейнеры и компоненты и лишь затем
        отобразить его в подготовленном виде. Конструктор принимает текстовый параметр
        — заголовок фрейма.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Рассмотрим пример организации работы с фреймом, который отоб­ражает
        компонент из первого примера лекции ("Алгоритм отрисовки").
    </p>
    <p>public class TestCanvas extends Canvas { public
        void paint(Graphics g) {
    </p>
    <p>g.drawLine(0, 0, getWidth(), getHeight());
        g.drawl_ine(0, getHeight (),getWidth (), 0);
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>public static void main(String arg[]) { Frame
        f = new Frame("Test frame"); f.setSize(400, 300); f.addfnew
        TestCanvas()); f.setVisible(true);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Окно запушенной программы будет выглядеть следующим образом:
    </p>
    <p>
    </p>
    <p>Обратите внимание, что это окно не будет закрываться по нажатию правой
        верхней кнопки в заголовке. Причина будет разъяснена ниже.
    </p>
    <p>Если класс Frame предназначен для
        создания основного окна прило­жения, то экземпляры класса Dialog позволяют открывать
        дополнительные 01сна для взаимодействия с
        пользователем. Это может потребоваться, на­пример, для вывода критического
        сообщения, для ввода параметров и т.д.. Окно диалога обладает стандартным
        оформлением — полоса заголовка, рзцка. В правой части полосы заголовка
        присутствует лишь одна кнопка -закрытия окна.
    </p>
    <p>Поскольку Dialog является несамостоятельным
        окном, в конструктор необходимо передать ссылку на родительский фрейм или окно
        другого диалога. Также можно задать заголовок окна. Как и Frame, диалоговое окно
        создается изначально невидимым.
    </p>
    <p>Важным свойством диалогового окна является модальность. Если ди­алог
        модальный, то при его появлении на экране блокируются все пользо­вательские
        события, приходящие в родительское окно такого диалога.
    </p>
    <p>
    </p>
    <p>Класс FileDialog
    </p>
    <p>Класс FileDialog является модальным
        диалогом (наследником Dialog) и позволяет легко организовать работу с файлами. Этот класс
        предназначен и для открытия файла (open file), и для сохранения
        (save file). Окно диалога имеет внешний вид, принятый для текущей операци­онной
        системы.
    </p>
    <p>Конструктор принимает в качестве параметров ссылку на родитель­ский
        фрейм, заголовок окна и режим работы. Для задания режима в классе определены
        две константы — LOAD и SAVE.
    </p>
    <p>После создания диалога FileDialog его необходимо
        сделать види­мым. Затем пользователь делает свой выбор. После закрытия диалога
        ре­зультат можно узнать с помощью методов getDirectory (для получения
        Полного имени каталога) и getFile (для получения
        имени файла). Если Пользователь нажал кнопку "Отмена" ("Cancel"), то будут
        возвращены значения null.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p></p>
    <center><img alt="Подпись:  " height="120" src="http://kufas.ru/java.files/image035.png"
                 width="197"></center>
    Обработка пользовательских
    событий
    <p>Весь предыдущий раздел "Дерево компонентов"
        был посвящен зада­нию внешнего вида пользовательского интерфейса. Однако до сих
        пор он был статическим. Перейдем теперь к рассмотрению правил обработки
        Различных событий, которые могут возникать как результат действий пользователя,
        и не только.
    </p>
    <p>Модель обработки событий построена на основе стандартного шабло-113 Проектирования ООП
        ОЬэеп/ег/ОЬзеп/аЫе. В качестве наблюдаемого
    </p>
    <p>363
    </p>
    <p>Курс
    </p>
    <p>Пакет j va. awt
    </p>
    <p>
    </p>
    <p>объекта выступает
        тот или иной компонент AWT. Для него можно задать один или несколько классов-наблюдателей. В
        AWT они называются слуща_ телями (listener) и описываются
        специальными интерфейсами, название которых оканчивается на слово Listener. Когда с
        наблюдаемым объектом что-то происходит, создается объект "событие" (event), который
        "посылает­ся" всем слушателям. Так слушатель узнает, например, о
        действии пользо­вателя и может на него отреагировать.
    </p>
    <p>Каждое событие является подклассом класса java.util.EventObject События пакета AWT, которые и
        рассматриваются в данной лекции, явля­ются подклассами java.awt.AWTEvent. Для удобства
        классы различных событий и интерфейсы слушателей помешены в
        отдельный пакет java. awt. event.
    </p>
    <p>Прежде, чем углубляться в особенности событий, рассмотрим, как они
        применяются на практике, на примере простейшего события -ActionEvent.
    </p>
    <p>
    </p>
    <p>Событие
        ActionEvent
    </p>
    <p>Рассмотрим появление события ActionEvent на примере нажатия
        на кнопку.
    </p>
    <p>Предположим, в нашем приложении создается кнопка сохранения файла:
    </p>
    <p>
    </p>
    <p>Button save = new
        Buttonf'Save"); add(save);
    </p>
    <p>
    </p>
    <p>Теперь, когда окно приложения с этой кнопкой появится на экране,
        пользователь сможет нажать ее. В результате AWT сгенерирует ActionEvent. Чтобы получить и
        обработать его, необходимо зарегистрировать слушате­ля.
        Название нужного интерфейса прямо следует из названия события -ActionListener. В нем всего
        один метод (в некоторых слушателях их не­сколько), который
        имеет один аргумент — ActionEvent.
    </p>
    <p>Объявим класс, который
        реализует этот интерфейс:
    </p>
    <p>
    </p>
    <p>class SaveButtonListener implements ActionListener { private
        Frame parent;
    </p>
    <p>public SaveButtonListener(Frame parentFrame) { parent =
        parentFrame;
    </p>
    <p>}
    </p>
    <p>public void actionPerformed(ActionEvent e) {
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>FileDialog fd = new FileDialog(parent, "Save
        file", FileDialog.SAVE);
    </p>
    <p>fd.setVisible(true);
    </p>
    <p>System.out.println(fd.getDirectory()+"/"+fd.getFile());
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Конструктор класса требует в качестве параметра ссылку на оодительский
        фрейм, без которого не удастся создать FileDialog. В методе actionPerformed класса
        ActionListener описываются
        действия, которые необходимо предпринять по нажатию пользователем на кнопку. А
        именно, (открывается файловый диалог, с помощью которого определяется путь
        сохранения файла. Для нашего примера достаточно вывести этот путь на консоль.
    </p>
    <p>Следующий шаг - регистрация слушателя. Название соответствующе­го метода
        снова прямо следует из названия интерфейса - add Action Listener.
    </p>
    <p>save.addActionListener(new
        SaveButtonListener(frame));
    </p>
    <p>Все необходимое для обработки нажатия пользователем на кнопку сделано.
        Ниже приведен полный листинг программы:
    </p>
    <p>
    </p>
    <p>import Java.awt.*; import Java.awt.event.*;
    </p>
    <p>
    </p>
    <p>public class
        Test {
    </p>
    <p>public static void main(String args[]) { Frame frame = new
        Frame("Test Action"); frame.setSize(400, 300); Panel p = new Panel();
        frame.add(p);
    </p>
    <p>Button save = new Button("Save");
        save.addActionListener(new SaveButtonListener(frame)); p.add(save);
    </p>
    <p>
    </p>
    <p>frame.setVisible(true);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>class SaveButtonListener implements ActionListener { private
        Frame parent;
    </p>
    <p>public SaveButtonListener(Frame parentFrame) { parent =
        parentFrame;
    </p>
    <p>public void actionPerformed(ActionEvent e) {
    </p>
    <p>FileDialog fd = new FileDialog(parent, "Save
        file",
    </p>
    <p>FileDialog.SAVE);
        fd.setVisible(true);
    </p>
    <p>System.out.println(fd.getDirectory()+fd.getFile());
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>После запуска программы появится фрейм с одной кнопкой "Save" Если нажать
        на нее, откроется файловый диалог. После выбора файла на консоли отображается
        полный путь к нему.
    </p>
    <p>Наряду с методом addXXListener важную роль играет fernoveXXListener. Поскольку в Java
        ненужные объекты
        удаляются из памяти автоматическим сборщиком мусора, который подсчитывает
        ссылки на объек­та важно следить за
        тем, чтобы не оставалось ссылок на ненужные объекты, рели слушатель уже
        выполнил свою роль и более не нужен, то явно в про­грамме может не остаться
        ссылок на него, однако компонент будет хра­нить его в своем списке слушателей.
        Чтобы дать сработать garbage collector, необходимо воспользоваться методом removeXXListener.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Рассмотрим обзорно все события AWT и соответствующих им слушателей, определенных в Java
        начиная с версии 1.1.
    </p>
    <p>
    </p>
    <p>События
        AWT
    </p>
    <p>Итак, для каждого события AWT определен класс XXEvent, интер­фейс XXListener,
        а в компоненте-источнике
        событий — метод для регист­рации слушателя addXXListener.
    </p>
    <p>Совсем не обязательно, чтобы одно событие могло порождаться лишь одним
        компонентом как результат какого-то одного действия поль­зователя. Например,
        рассмотренный ActionEvent генерируется после
        нажа­тия на кнопку (Button), после нажатия клавиши Enter в поле ввода текста
        (TextField), при двойном щелчке мыши по элементу списка (List) и т.д. Уз­нать,
        какие события генерирует тот или иной компонент, можно по начи-чию методов addXXListener.
    </p>
    <p>Многие слушатели, в отличие от ActionListener, имеют более одного метода для различных видов
        событий. Например, MouseMotionListener на­блюдает за
        движением мыши и имеет два метода - mouseMoved (обычное движение)
        и mouseDragged (перемещение с
        нажатой кнопкой мыши). Ино­гда бывает необходимо работать лишь с одним методом,
        остальные прихо­дится объявлять и оставлять пустыми. Чтобы избежать этой
        бесполезной ра­боты, в пакете java.awt.event объявлены вспомогательные классы-адаптеры,
        например, MouseMotionAdapter (название прямо
        следует из названия слу­шателя). Эти классы наследуются от Object и реализуют
        соответствующий интерфейс. Адаптер — абстрактный класс, но
        абстрактных методов в нем нет, они все объявлены пустыми. От такого класса
        можно наследоваться и пере­определить только те методы, которые нужны для
        приложения.
    </p>
    <p>Классы сообщений (event) содержат вспомогательную информации для обработки события. Метод
        getSourceQ возвращает
        объект-источник события. Конкретные наследники AWTEvent могут иметь дополнитель­ные методы.
        Например, MouseEvent сообщает о нажатии
        кнопки мыши, а его методы getX и getY возвращают координаты точки, где это событие
        произошло.
    </p>
    <p>МоизеМоИопиз1епег и MouseEveпt
    </p>
    <p>Это событие рассматривалось выше в примере. Оно отвечает за перемещение
        курсора мыши. Соответствующий слушатель имеет два метода — mouseMoved для
        обычного перемещения и mouseDragged для перемещения с нажатой кнопкой мыши.
        Обратите внимание, что этот слушатель работает не с событием МоизеМо^'опЕуе^
        (такого класса нет), а с МоиэеЕуепт, как и МоизеУэт^пег.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>MouseListener и MouseEvent
    </p>
    <p>Этот слушатель имеет методы mouseEntered и mouseExited. Первый вызывается, когда курсор мыши
        появляется над компонентом, а
        второй -когда выходит из его границ.
    </p>
    <p>Для обработки нажатий кнопки мыши служат три метода: mousePressed, mouseReleased и
        mouseClicked. Если пользователь нажал, а затем отпустил кнопку, то слушатель получит
        все три события в указанном порядке. Если щелчков было несколько, то метод getClickCount
        класса MouseEvent вернет количество.
        Как уже указывалось, методы getX Щ getY возвращают координаты точки, где произошло событие.
        Чтобы определить,
        какая кнопка мыши была нажата, нужно воспользоваться Методом getModifiers и сравнить
        результат с константами:
    </p>
    <p>(event.
        getModifiers()&amp;MouseEvent.BUTTON1_MASK)!=0
    </p>
    <p>
    </p>
    <p>Как правило, первая кнопка
        соответствует левой кнопке мыши.
    </p>
    <p>
    </p>
    <p>Кеуиэгепег и КеуЕуеМ
    </p>
    <p>Этот слушатель отслеживает нажатие клавиш клавиатуры и имеет три Метода:
        keyTyped, keyPressed, keyReleased. Первый отвечает за ввод Очередного  
        Unicode-cимвoлa   с   клавиатуры.   Метод   keyPressed сигнализирует о нажатии,
        a keyReleased - об отпускании
        некотор01) клавиши. Взаимосвязь между этими событиями может быть
        нетривиальной Например, если пользователь нажмет и будет удерживать клавишу Shift и н это
        время нажмет клавишу "А", произойдет одно
        событие типа keyTyped и несколько keyPressed/Released. Если пользователь нажмет и буде,
        удерживать, например,
        пробел, то после первого keyPressed будС1 многократно
        вызван метод keyTyped, а после отпускания - keyReleased.
    </p>
    <p>В классе KeyEvent определено
        множество констант, которые nos-воляют точно идентифицировать, какая клавиша была нажата и в
        ка­ком
        состоянии находились служебные клавиши (Ctrl, Alt, Shift и так далее).
    </p>
    <p>
    </p>
    <p>FocusListener и FocusEvent
    </p>
    <p>В каждом приложении один из компонентов обладает фокусом и мо­жет получать события от
        клавиатуры. Фокус можно переместить, напри­мер, щелкнув мышкой по другому
        компоненту, либо нажав клавишу Tab.
    </p>
    <p>Интерфейс FocusListener
        содержит два метода - focusGained и focusLost (получен/потерян).
    </p>
    <p>
    </p>
    <p>TextListener и TextEvent
    </p>
    <p>Компоненты-наследники TextComponent отвечают за ввод
        текста и порождают TextEvent. Слушатель имеет один метод textValueChanged. С его помощью
        можно отслеживать каждое изменение текста, чтобы, на­пример,
        выдавать пользователю подсказку, основываясь на первых вве­денных символах.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>ItemListener и Item Event
    </p>
    <p>Это событие могут генерировать такие классы, как Checkbox, Choice, List. Слушатель имеет
        один метод itemStateChanged, который сигнати-зирует об изменении состояния элементов.
    </p>
    <p>
    </p>
    <p>AdjustmentListener и AdjustmentEvent
    </p>
    <p>Это событие генерируется компонентом ScrollBar. Слушатель имеет один метод
        adjustmentValueChanged, сигнализирующий об изменении состояния полосы прокрутки.
    </p>
    <p>
    </p>
    <p>Window/Listener и WindowEvent
    </p>
    <p>Это событие сигнализирует об изменении состояния окна (класс Window и его наследники).
    </p>
    <p>Рассмотрим особо один из методов слушателя - windowClosing. Этот метод вызывается, когда
        пользователь предпринимает попытку за­крыть
        окно, например, нажимая на соответствующую кнопку в заголовке окна. Мы видели
        из примеров ранее, что в Java окна при этом не
        закры­ваются. Дело в том, что AWT лишь посылает WindowEvent в ответ на такое
        действие, а инициировать закрытие окна должен программист:
    </p>
    <p>public class WindowClosingAdapter extends WindowAdapter
        { public void windowClosing(WindowEvent e) { ((Window)e.getSource()).dispose();
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Объявленный адаптер в методе windowClosing получает ссылку на
        окно, от которого пришло событие. Обычно мы пользовались методом setVisible(false), чтобы
        сделать компонент невидимым. Но поскольку Window автоматически порождает окно операционной
        системы, сущест­вует
        специальный метод dispose, который освобождает все системные ресурсы, связанные с этим
        окном.
    </p>
    <p>Когда окно будет закрыто, у слушателя вызывается еще один метод - windowClosed.
    </p>
    <p>
    </p>
    <p>ComponentListener и ComponentEvent
    </p>
    <p>Это событие отражает изменение основных параметров компонента -
        положение, размер, свойство visible.
    </p>
    <p>
    </p>
    <p>ContainerListener и ContainerEvent
    </p>
    <p>Это событие позволяет отслеживать изменение списка содержащихся в этом
        контейнере компонент.
    </p>
    <p>С развитием Java в AWT появляются и другие события, например, позволяющие поддерживать
        колесико
        мыши. Однако все они работают по точно такой же схеме, а потому их можно легко
        освоить самостоя­тельно.
    </p>
    <p>
    </p>
    <p>Обработка
        событий с помощью внутренних классов
    </p>
    <p>Еще в лекции, посвященной объявлению классов, было указано, что втеле
        класса можно объявлять внутренние классы. До сих пор такая возмож­ность не была
        востребована в наших примерах, однако обработка событий AWT - как раз удобный случай
        рассмотреть такие классы
        на примере ано­нимных классов.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Предположим, в приложение добавляется кнопка, которой следует добавить
        слушателя. Зачастую бывает удобно описать логику действий в отдельном
        методе того же класса. Если вводить слушателя, как делалось раньше - в
        отдельном классе, то это сразу порождает ряд неудобств: появ­ляется новый,
        малосодержательный класс, которому к тому же необходимо передать ссылку на
        исходный класс и так далее.
    </p>
    <p>Гораздо удобнее поступить
        следующим образом:
    </p>
    <p>
    </p>
    <p>Button b = new Button(); b.addActionl_istener(new ActionListener()
        { public void actionPerformed(ActionEvent e) { processButtonQ;
    </p>
    <p>}
    </p>
    <p>};
    </p>
    <p>Рассмотрим подробно, что происходит в этом примере. Сначала со­здается кнопка, у которой
        затем вызывается метод addActionListener. Об­ратим внимание на аргумент этого метода. Может
        сложится
        впечатление, что производится попытка создать экземпляр интерфейса (new ActionListener()),
        однако это невозможно. Дело меняет фигурная скобка, которая
        указывает, что порождается экземпляр нового класса, объявление которого
        последует за этой скобкой. Класс наследуется от Object и реали­зует интерфейс
        ActionListener. Ему необходимо реализовать метод actionPeroformed, что и делается. Обратите
        внимание на еще одну важ­ную деталь — в этом
        методе вызывается processButton. Это метод, кото­рый мы планировали разместить во внешнем
        классе. Таким образом, вну­тренний
        класс может напрямую обращаться к методам внешнего класса.
    </p>
    <p>Такой класс называется анонимным, он не имеет своего имени. Од­нако
        правило, согласно которому компилятор всегда создает .class-файл для каждого
        класса Java, действует и здесь. Если внешний класс называ­ется Test, то после
        компиляции появится файл Test$1 .class.
    </p>
    <p>
    </p>
    <p>Пример приложения,
        использующего модель событий
    </p>
    <p>В заключение темы, посвященной событиям, рассмотрим пример приложения, которое
        активно их использует.
    </p>
    <p>Попробуем написать примитивный графический редактор,
        который позволяет рисовать с помощью курсора - если перемещать его с
        нажато" кнопкой мыши, то будет появляться линия. Нажатие пробела очищает
        поле-import java.awt.*; import java.awt.event.*;
    </p>
    <p>public class DrawCanvas extends Canvas {
        private int lastX, lastY; private int ex, ey; private boolean clear=false;
    </p>
    <p>
    </p>
    <p>public DrawCanvas () { super();
    </p>
    <p>addMousel_istener(new MouseAdapterQ { public void
        mousePressed(MouseEvent e) { lastX = e.getX(); lastY=e.getY();
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>}
    </p>
    <p>});
    </p>
    <p>addMouseMotionListener(new MouseMotionAdapter() {
        public void mouseDragged(MouseEvent e) { ex=e.getX(); ey=e.getY(); repaintQ;
    </p>
    <p>}
    </p>
    <p>});
    </p>
    <p>addKeyListener(new KeyAdapter() { public
        void keyTyped(KeyEvent e) { if (e.getKeyChar()==") { clear = true;
        repaint();
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>});
    </p>
    <p>}
    </p>
    <p>public void update(Graphics g) {
    </p>
    <p>
    </p>
    <p>g.clearRect(0, 0, gerWidthQ, getHeight()); clear = false; } else {
    </p>
    <p>g.drawLine(lastX, lastY ex, ey);
    </p>
    <p>lastX=ex;
    </p>
    <p>lastY=ey;
    </p>
    <p>}
    </p>
    <p>public static void main(String s[]) { final
        Frame f = new Framef'Draw"); f.addWindowListener(new WindowAdapter() { public
        void windowClosing(WindowEvent e) { f.dispose();
    </p>
    <p>}
    </p>
    <p>});
    </p>
    <p>f.setSize(400, 300);
    </p>
    <p>
    </p>
    <p>final Canvas с = new
        DrawCanvas(); f.add(c);
    </p>
    <p>
    </p>
    <p>f.setVisible(true);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Класс DrawCanvas и является тем
        полем, на котором можно рисовать. В его конструкторе инициализируются все необходимые
        слушатели.
        В случае прихода события инициализируется перерисовка (метод repaint), логика которой
        описана в update. Запускаемый метод main инициализирует frame, не забывая про windowClosing.
    </p>
    <p>В результате можно
        что-нибудь нарисовать:
    </p>
    <p></p>
    <center><img border="0" height="148" src="http://kufas.ru/java.files/image036.jpg" width="214">
    </center>
    <p>
    </p>
    <p>
    </p>
    <p>Апплеты
    </p>
    <p>Перейдем к рассмотрению апплетов (applets) — Java-приложений,
        которые исполняются в браузере как часть HTML-страницы. Это
        означа­ет, что такие приложения всегда визуальные. Действительно, класс Applet является
        наследником AWT-компонента Panel. Сам класс находится в па­кете java.applet.
    </p>
    <p>Жизненный
        цикл апплета
    </p>
    <p>Важным вопросом для понимания работы апплетов является их жиз­ненный
        цикл. Он описывается четырьмя методами.
    </p>
    <p>
    </p>
    <p>init
    </p>
    <p>Этот метод вызывается браузером при конструировании апплета. За­частую
        все инициализирующие действия описываются здесь, а не в кон­структоре. Это
        может быть, например, создание AWT-компонент, запуск потоков исполнения, установление
        сетевых соединений и
        т.д.
    </p>
    <p>
    </p>
    <p>start
    </p>
    <p>Этот метод вызывается после инициализации апплета. Он нужен по следующей
        причине. Апплет может содержать какие-то динамические час­ти, например,
        анимацию или бегущую строку. Если пользователь восполь­зуется какой-нибудь
        ссылкой и уйдет со страницы с апплетом, бразуер не станет его уничтожать — ведь
        пользователь может вернуться (нажав в брау­зере кнопку Back), и он будет
        ожидать, что апплет сохранит свое состояние. Значит, апплет может оказаться в
        неактивном состоянии, когда лучше при­остановить динамические процессы для
        экономии системных ресурсов.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Метод start сигнализирует о переходе в активное состояние.
    </p>
    <p>
    </p>
    <p>stop
    </p>
    <p>Этот метод всегда вызывается после метода start и сигнализирует о переходе в пассивное
        состояние.
    </p>
    <p>
    </p>
    <p>destroy
    </p>
    <p>По завершении работы апплет необходимо корректно удалить, чтобы он имел
        возможность освободить занимаемые ресурсы. Для этого браузер вызывает метод destroy.
    </p>
    <p>В остальном апплет является полноценным AWT-компонентом и в
        Методе init может добавить
        другие компоненты для создания пользова­тельского интерфейса, или даже открыть
        новый фрейм. Единственное, но существенное ограничение - это условие
        безопасности. Ведь код апплета скачивается по сети, а значит, может содержать в
        себе опасные действия. Поэтому браузер запускает виртуальную машину с
        ограничениями - апп-летам запрещено обращаться к файловой структуре, запрещено
        устанав­ливать сетевые соединения с кем-либо, кроме сервера, откуда они были
        загружены, все вновь открываемые окна помечаются предупреждением. Более того,
        пользователь может так настроить свой браузер, что вовсе за-
    </p>
    <p>Курс
    </p>
    <p>дякция
        11                                                                                                             
        Пакет
        jva.awt
    </p>
    <p>претит исполнение Java. Можно, напротив, позволить апплетам то же что и локальным
        приложениям.
    </p>
    <p>Есть и еще одно ограничение - версия Java, поддерживаемая
        браузе­ром. Как говорилось в первой лекции, самый популярный на данный мо­мент
        браузер - MS Internet Explorer - остановился на
        поддержке лишь Java 1.1, и то не в полном объеме. В некоторый случаях можно воспользоваться
        дополнительным продуктом Sun - Java Plug-in, который позволяет уста­новить на браузер JVM
        любой версии.
    </p>
    <p>Продолжим рассмотрение
        апплетов.
    </p>
    <p>
    </p>
    <p>HTML-тег
    </p>
    <p>Раз апплет является частью HTML-страницы, значит,
        необходимо каким-то образом указать, где именно он располагается. Для этого
        служит специальный тег &lt;applet&gt;.
    </p>
    <p>Синтаксис тега &lt;APPLET&gt;
        в настоящее время таков:
    </p>
    <p>&lt;APPLET CODE = appletFile WIDTH = pixels HEIGHT = pixels [ARCHIVE = jarFiles]
        [CODEBASE = codebaseURL] [ALT = alternateText] [NAME = appletlnstanceName]
        [ALIGN = alignment] [VSPACE - pixels] [HSPACE = pixels]
    </p>
    <p>&gt;
    </p>
    <p>[HTML-текст,
        отображаемый при отсутствии поддержки Java] &lt;/APPLET&gt;
    </p>
    <p>
    </p>
    <p>•  CODE = appletClassFile
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>CODE - обязательный атрибут, задающий имя файла, в котором содержится
        описание класса апплета. Имя файла задается относи­тельно codebase, то есть либо от
        текущего каталога, либо от ката­лога, указанного в атрибуте CODEBASE.
    </p>
    <p>•
        WIDTH = pixels
    </p>
    <p>•
        HEIGHT = pixels
    </p>
    <p>WIDTH и HEIGHT - обязательные
        атрибуты, задающие размер об­ласти апплета на HTML-странице.
    </p>
    <p>•  ARCHIVE-jarFiles
    </p>
    <p>Этот необязательный атрибут задает список jar-файлов (разделя­ется
        запятыми), которые предварительно загружаются в Web-бра­узер. В них
        могут содержаться классы, изображения, звук и любые другие ресурсы, необходимые
        апплету. Архивирование наиболее необходимо именно апплетам, так как их код и
        ресурсы передают­ся через сеть.
    </p>
    <p>• CODEBASE = codebaseURL
    </p>
    <p>CODEBASE — необязательный атрибут, задающий базовый URL кода апплета;
        является каталогом, в котором будет выполняться поиск исполняемого файла
        апплета (задаваемого в признаке CODE). Если этот атрибут не задан, по умолчанию используется
        каталог данного HTML-документа.
    </p>
    <p>С помощью этого атрибута можно на странице одного сайта раз­местить
        апплет, находящийся на другом сайте.
    </p>
    <p>• ALT = alternateAppleiText
    </p>
    <p>Признак ALT — необязательный
        атрибут, задающий короткое тек­стовое сообщение, которое должно быть выведено
        (как правило, в виде всплывающей подсказки при нахождении курсора мыши над
        областью апплета) в том случае, если используемый браузер рас­познает синтаксис
        тега &lt;applet&gt; , но выполнять апплеты не умеет. Это не то же самое, что HTML-текст,
        который
        можно вставлять между &lt;applet&gt; и &lt;/applet&gt; для браузеров, вообще не
        поддержи­вающих апплетов.
    </p>
    <p>• NAME = appletlnstanceName
    </p>
    <p>NAME - необязательный атрибут, используемый для присвоения имени данному
        экземпляру апплета. Имена апплетам нужны для того, чтобы другие апплеты на этой
        же странице могли находить их и общаться с ними, а также для обращений из Java Script.
    </p>
    <p>• ALIGN = alignment
    </p>
    <p>• VSPACE = pixels
    </p>
    <p>• HSPACE = pixels
    </p>
    <p>Эти три необязательных атрибута предназначены для того же, что и в теге IMG. ALIGN задает
        стиль выравнивания апплета, возмож­ные значения: LEFT, RIGHT, TOP, TEXTTOP, MIDDLE,
        ABSMIDDLE, BASELINE, BOTTOM, ABSBOTTOM.
    </p>
    <p>Следующие два задают ширину свободного пространства в пикселах сверху и
        снизу апплета (VSPACE), а также слева и справа от него (HSPACE).
    </p>
    <p>Приведем пример простейшего апплета:
    </p>
    <p>
    </p>
    <p>import java.applet.*;
        import java.awt.*;
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>public class
        HelloApplet extends Applet {
    </p>
    <p>Il1
    </p>
    <p>public void init() {
    </p>
    <p>addfnew
        Label("Hello"));
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>HTML-тег для него:
    </p>
    <p>
    </p>
    <p>&lt;applet code=HelloApplet.class width=200 height =50&gt; &lt;/applet&gt;
    </p>
    <p>
    </p>
    <p>Передача параметров
    </p>
    <p>Существует очень полезная возможность передавать из HTML параметры в апплет. Таким образом,
        можно настроить программу без
        необходимости менять ее исходный код.
    </p>
    <p>В HTML параметры
        указываются следующим образом:
    </p>
    <p>&lt;applet code=HelloApplet.class width=200 height =50&gt;
    </p>
    <p>&lt;param name="text"
        value="Hello!!!"&gt;
    </p>
    <p>&lt;/applet&gt;
    </p>
    <p>
    </p>
    <p>В апплете значение параметров считывается таким образом:
    </p>
    <p>import java.applet.*; import java.awt.*;
    </p>
    <p>
    </p>
    <p>public class HelloApplet extends Applet { public
        void init() {
    </p>
    <p>String text = getParameterf'text"); add(new
        Label(text));
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Теперь выводимый текст можно настраивать из HTML.
    </p>
    <p>
    </p>
    <p>Интерфейс
        AppletContext
    </p>
    <p>Доступ к этому интерфейсу из апплета предоставляется методом getAppletConext. С его помощью
        апплет может взаимодействовать со страницей, откуда он
        был загружен, и с браузером. Так, именно в этом интерфейсе определен метод getApplet, с
        помощью которого можно обратиться по имени к другому апплету,
        находящемуся на той же стра­нице.
    </p>
    <p>Метод 51ю\л/5га^8 меняет текст поля статуса в окне браузера. Метод БПОУУОосите^ позволяет
        загрузить новую страницы в браузер
    </p>
    <p>Менеджеры компоновки
    </p>
    <p>При размещении компонент в контейнере поначалу всегда кажется удобным
        задавать их размер и положение явно с помощью метода setBounds.
    </p>
    <p>Однако дальше становятся очевидны недостатки такого подхода. На­пример,
        удобно предоставить пользователю возможность изменять размер фрейма, а это
        означает необходимость перестраивать компоненты. Развитие Приложения также
        может привести к добавлению или удалению компонен­та, после чего придется
        пересчитывать координаты оставшихся элементов.
    </p>
    <p>Есть проблемы и другого характера. Мы указывали, что JVM выбирает шрифты из имеющихся в
        системе. Поэтому под разными платформами
        они могут оказаться разного размера или наклона. В результате приложение,
        красиво смотрящееся на машине разработчика, может "поплыть" у
        клиента. Даже под одной платформой пользователь может сменить системные
        настройки, вследствие чего внешний вид приложения может измениться не в лучшую
        сторону.
    </p>
    <p>Все эти соображения наводят на мысль, что было бы полезно каким-то
        образом автоматизировать расположение компонентов
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Именно для этой цели служат
        менеджеры компоновки. Их задача — вычислить и установить размер и
        местоположение компонентов в контейнере. Вообще говоря, они могут использовать
        следующий набор параметров для своих вычислений:
    </p>
    <p>•
        размер контейнера;
    </p>
    <p>•
        начальное положение и
        размер компонента;
    </p>
    <p>•
        его порядковый номер в
        наборе компонентов;
    </p>
    <p>•
        специальный
        параметр-ограничитель (constraint), который может быть установлен при добавлении компонента.
    </p>
    <p>В AWT каждый контейнер
        обладает менеджером компоновки. Если он равен null, то используются
        явные параметры компонентов. Настоящие же классы менеджеров должны
        реализовывать интерфейс LayoutManager. Этот интерфейс принимает в качестве constraints
        строку (String). Со вре­менем это
        было признано недостаточно гибким (фирмы стали разрабаты-^ть и предлагать свои
        менеджеры, обладающие самой разной функцио­нальностью). Поэтому был добавлен
        новый интерфейс -^youtManager2, принимающий в качестве ограничителя constraints.
    </p>
    <p>Рассмотрим работу нескольких наиболее распространенных менед­жеров
        компоновки. Но перед этим отметим общий для них всех факт. Де­ло в том, что не
        всегда вся область контейнера подходит для размещения в Ней
        компонент. Например, фрейм имеет рамку и полосу заголовка. В ре­зультате его
        полезная площадь меньше. Поэтому все менеджеры компонов­
    </p>
    <p>ки начинают с обращения к методу getlnsets класса Container. Этот Mei0) возвращает значение
        типа Insets. Это класс, который имеет четыре откры. тых поля - top, right, bottom, left,
        значения которых
        описывают отступ^ со всех четырех сторон, которые необходимо сделать, чтобы
        получить об. ласть, доступную для расположения компонент.
    </p>
    <p>
    </p>
    <p>Класс
        FlowLayout
    </p>
    <p>Этот менеджер является стандартным для Panel. Он не меняет
        размер компонент, а только располагает их один за другим в линию, как буквы в
        строке. Когда заканчивается первая "строка", он переходит на
        следующую и так далее, пока либо не закончится область контейнера, либо не
        будут расположены все компоненты.
    </p>
    <p>В качестве параметров
        конструктору можно передать значение вырав­нивания по горизонтали (определены
        константы LEFT, RIGHT, CENTER -значение по
        умолчанию), а также величину необходимых отступов между компонентами по
        вертикали (vgap) и горизонтали (hgap). Их значение по умолчанию — 5 пикселов.
    </p>
    <p>Рассмотрим пример:
    </p>
    <p>
    </p>
    <p>final Frame f = new Framef'Flaw"); f.setSize(400, 300);
    </p>
    <p>f.setLayout(new FlowLayout(FlowLayout.LEFT)); f.add(new
        Label ("Test")); f.add(new Button("Long string"));
        f.addjnew TextArea(2, 20)); f.add(new Button("short"));
        f.add(newTextArea(4, 20)); f.add(new Label("Long-long text"));
        f.setVisible(true);
    </p>
    <p>
    </p>
    <p>Если теперь менять размер этого фрейма, то можно видеть, как
        перераспределяются компоненты:
    </p>
    <p>Класс BorderLayout
    </p>
    <p>Этот менеджер является стандартным для контейнера Window и его иаследников Frame и Dialog.
    </p>
    <p>BorderLayout использует
        ограничитель. При добавлении компонента необходимо указать одну из 5 констант,
        определенных в этом классе: NORTH, SOUTH, EAST, WEST, CENTER (используется по
        умолчанию), первыми располагаются
        северный и южный компонент. Их высота не из­меняется, а ширина становится
        равной ширине контейнера. Северный компонент помещается на самый верх
        контейнера, южный — вниз. Затем располагаются восточный и западный компоненты.
        Их ширина не меня­ется, а высота становится равной высоте контейнера за вычетом
        места, которое заняли первые две
        компоненты. Наконец, все оставшееся место занимает центральная
        компонента.
    </p>
    <p>Рассмотрим пример:
    </p>
    <p>final Frame f = new Frame("Border"); f.setSize(200, 150);
    </p>
    <p>f.add(new
        Button("North"), BorderLayout.NORTH); f.addjnew Button("South"),
        BorderLayout.SOUTH); f.addjnew Button("West"), BorderLayout.WEST);
        f.add(new Button ("East"), BorderLayout. EAST); f.add(new
        Button("Center"), BorderLayout.CENTER); f.setVisible(true);
    </p>
    <p>
    </p>
    <p>Вот как выглядит такой
        фрейм:
    </p>
    <p></p>
    <center><img border="0" height="102" src="http://kufas.ru/java.files/image037.jpg" width="134">
    </center>
    <p></p>
    <center><img alt="Подпись:  " height="148" src="http://kufas.ru/java.files/image038.png"
                 width="380"></center>
    И в этом менеджере есть параметры Іідар и удар (по
    умолчанию их значение равно нулю).
    <p>
    </p>
    <p>Класс
        СгМ1-ауои1
    </p>
    <p>Этот менеджер поступает следующим образом - он разделяет весь к°нтейнер
        на одинаковые прямоугольные сектора (отсюда и его название ^Решетка). Далее
        последовательно каждый компонент полностью занима­ет свой сектор (таким
        образом, они все становятся одинакового размера).
    </p>
    <p>Курс_______________________________________________________ Программирование
        на_Ла„.
    </p>
    <p>В конструкторе указывается количество строк и столбцов д1; разбиения:
    </p>
    <p>
    </p>
    <p>final Frame f = new Frame("Grid");
        f.setSize(200, 200); f.setl_ayout(new GridLayout(3, 3)); for (int i=0; i&lt;8;
        i++) {
    </p>
    <p>f.add(new Button("-"+(i+1)+"-"));
    </p>
    <p>}
    </p>
    <p>f.setVisible(true);
    </p>
    <p>
    </p>
    <p>Вот как выглядит такой
        фрейм:
    </p>
    <p></p>
    <center><img border="0" height="137" src="http://kufas.ru/java.files/image039.jpg" width="135">
    </center>
    <p>И в этом менеджере есть параметры hgap и vgap (по умолчанию и\
        значение равно нулю).
    </p>
    <p>
    </p>
    <p>Класс CardLayout
    </p>
    <p>Этот менеджер ведет себя подобно колоде карт. В один момент виден лишь
        один компонент, и он занимает всю область контейнера. Програм­мист может
        управлять тем, какой именно компонент показывается поль­зователю.
    </p>
    <p>
    </p>
    <p>Заключение
    </p>
    <p>Библиотека AWT имеет множество
        классов и внутренних механиз­мов. Новые версии Java добавляют новые возможности и
        пересматривают старые. Тем не менее,
        основные концепции были подробно рассмотрены в этой лекции и на их основе можно
        построить полнофункциональны!1 графический интерфейс пользователя (GUI).
    </p>
    <p>Стандартные компоненты AWT иерархически
        упорядочены в дерев0 наследования с классом Component в вершине. Важным
        его наследников является класс Container, который может хранить набор компонентов Прямые
        наследники Component составляют набор
        управляющих З'е
    </p>
    <p>380
    </p>
    <p>Пакет jva.awt
    </p>
    <p>
    </p>
    <p>gjfTOB ("контролов",
        от англ. controls), а наследники Container — набор контейнеров
        для группировки и расположения компонентов. Для упро­щения размещения отдельных
        элементов пользовательского интерфейса Применяются менеджеры компоновки (Layout managers).
    </p>
    <p>Особое место в AWT занимает процедура
        отрисовки компонентов, которая может инициироваться как операционной системой,
        так и про­граммой. Специальные классы служат для задания таких атрибутов, как
        цвет, шрифт и т.д.
    </p>
    <p>Один из наследников Container — класс Window, который представ­ляет
        собой самостоятельное окно в многооконной операционной системе. Два его
        наследника — Dialog и Frame. Для работы с
        файлами определен наследник Dialog - FileDialog.
    </p>
    <p>Наконец, излагаются принципы модели событий от пользователя, позволяющей
        обрабатывать все действия, которые производит клиент, работая с программой. 11 событий и
        соответствующих им интерфейсов предоставляют все необходимое для написания
        полноценной GUI-программы.
    </p>
    <p>Апплеты — небольшие программы, предназначенные для работы в браузерах
        как небольшие части HTML-страниц. Класс java.applet.Applet является наследником Panel, а
        потому обладает всеми свойствами AWT-компонент. Были
        представлены этапы жизненного цикла апплета, отлич­ного от цикла обычного приложения,
        которое запускается методом main. Для размещения апплета на HTML-странице
        необходимо использовать специальный тег &lt;applet&gt;. Кроме этого,
        можно указывать специальные параметры, чтобы апплет настраивался без
        перекомпиляции кода.
    </p>
    <p>
        КуРС                                                                                              
        Программирование
        ням^,
    </p>
    <p>Пакет jva.awt
    </p>
    <p>
    </p>
    <p>Вариант
        1
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>От какого класса наследуется
        класс Applet?
    </p>
    <p>Р   Object
    </p>
    <p>Q   Java. awt. Component Q   java.awt.Canvas Q   java.awt. Panel
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.      Какой
        метод нужно вызвать, чтобы инициировать
        перерисовку компонента?
    </p>
    <p>П     paint
    </p>
    <p>&#9633;
        update
    </p>
    <p>&#9633;
        repaint
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.      Какими
        параметрами в Java характеризуется шрифт?
    </p>
    <p>П     имя-семейство шрифта
    </p>
    <p>П     жирность
    </p>
    <p>&#9633; размер
        О стиль
    </p>
    <p>&#9633;       цвет
    </p>
    <p>Вариант
        2
    </p>
    <p>Вариант
        3
    </p>
    <p>
    </p>
    <p>Может ли быть дважды вызван
        метод init у апплета? Метод start?
    </p>
    <p>&#9633;
        да, да
    </p>
    <p>&#9633;
        да, нет
    </p>
    <p>&#9633;
        нет, да
    </p>
    <p>&#9633;
        нет, нет
    </p>
    <p>J,   Как получить объект класса Color, описывающий
        чистый синий цвет?
    </p>
    <p>Р      new
        Color("blue")
    </p>
    <p>Р      new Color(0, 0, 255)
    </p>
    <p>Р      Color.getBlue()
    </p>
    <p>Р      Color, blue
    </p>
    <p>
    </p>
    <p>Какой метод нужно
        переопределить, чтобы реализовать отрисовку внешнего вида компонента?
    </p>
    <p>&#9633;
        paint
    </p>
    <p>&#9633;
        update fj   repaint
    </p>
    <p>2.   Какие утверждения верны?
    </p>
    <p>   метод
        update вызывает метод paint
    </p>
    <p>метод
        repaint вызывает метод paint Г*|  
        метод update вызывает метод repaint
    </p>
    <p>метод
        repaint вызывает метод update
    </p>
    <p>
    </p>
    <p>Сколько вложенных компонентов
        может быть контейнера БсгоИРапе?
    </p>
    <p>&#9633;
        о
    </p>
    <p>&#9633;
        1
    </p>
    <p>П   произвольное
        количество
    </p>
    <p>
    </p>
    <p>3.   В чем разница между компонентами List и Choice?
    </p>
    <p>Г*|   List позволяет
        просмотреть весь список вариантов значения, a Choice - нет
    </p>
    <p>Г*|   List допускает выбор нескольких
        вариантов, a Choice - нет
    </p>
    <p>Г*|  
        List одновременно отображает
        несколько вариантов значения, a Choice - нет
    </p>
    <p>Г*|   List не позволяет ввести
        произвольное значение, a Choice - да
    </p>
    <p>
    </p>
    <center>
    </center>
</div>

</body>
</html>
