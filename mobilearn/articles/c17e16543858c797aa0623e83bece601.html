<!DOCTYPE html>
<html>
<head>

    <title>Лекция 9. Массивы</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<div class="left">
    <p></p>
    <p></p>
    <center><h2>Лекция 9.
        Массивы</h2></center>
    <p>
    </p>
    <p>Лекция посвящена описанию массивов в Java. Массивы издавна
        при­сутствуют в языках программирования, поскольку при выполнении многих задач
        приходится оперировать целым рядом однотипных значений.
    </p>
    <p>Массивы в Java — один из ссылочных типов, который, однако, имеет
        особенности при инициализации, создании и оперировании со своими значе­ниями.
        Наибольшие различия проявляются при преобразовании таких типов. Также
        объясняется, почему многомерные массивы в Java можно (и зачастую более правильно)
        рассматривать как
        одномерные. Завершается классификация типов переменных и типов значений,
        которые они могут хранить.
    </p>
    <p>В заключение рассматривается механизм клонирования Java, позволяю­щий в
        любом классе описать возможность создания точных копий объектов, порожденных от
        него.
    </p>
    <p>
    </p>
    <p>Массивы как тип данных в Java
    </p>
    <p>В отличие от обычных переменных, которые хранят только одно значение,
        массивы (arrays) используются для хранения целого набора зна­чений. Количество значений
        в массиве называется его длиной, сами значе­ния — элементами массива. Значений
        может не быть вовсе, в этом случае массив считается пустым, а его длина равной
        нулю.
    </p>
    <p>Элементы не имеют имен, доступ к ним осуществляется по номеру индекса.
        Если массив имеет длину п, отличную от нуля, то корректными значениями индекса
        являются числа от 0 до п-1. Все значения имеют одинаковый тип и говорится, что массив
        основан на
        этом базовом типе. Массивы могут быть основаны как на примитивных типах
        (например, для хранения числовых значений 100
        измерений), так и на
        ссылочных (на­пример, если нужно хранить описание 100
        автомобилей в гараже в
        виде экземпляров класса Саг).
    </p>
    <p>Сразу оговоримся, что в Java массив символов char[] и класс String яв­ляются различными
        типами. Их значения могут легко конвертироваться
        ДРУГ в друга с помощью специальных методов, но все же они не относятся к идентичным типам.
    </p>
    <p>Как уже говорилось, массивы в Java являются объектами (примитив­ных типов в Java всего восемь
        и их количество не меняется), их тип напря­мую наследуется от
        класса Object, поэтому все элементы данного класса Доступны у объектов-массивов.
    </p>
    <p>Базовый тип также может быть массивом. Таким образом конструи­руется
        массив массивов, или многомерный массив.
    </p>
    <p>
    </p>
    <p>-3440
    </p>
    <p>273
    </p>
    <p>Работа с любым массивом включает обычные операции, уже описан­ные для
        других типов, - объявление, инициализация и т.д. Начнем после­довательно
        изучать их в приложении к массивам.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>Объявление
        массивов
    </p>
    <p>В качестве примера рассмотрим объявление переменной типа "мас­сив,
        основанный на примитивном типе int":
    </p>
    <p>int а[];
    </p>
    <p>
    </p>
    <p>Как мы видим, сначала указывается базовый тип. Затем идет имя пе­ременной,
        а пара квадратных скобок указывает на то, что используемый тип является именно
        массивом. Также допустима запись:
    </p>
    <p>
    </p>
    <p>int[] а;
    </p>
    <p>
    </p>
    <p>Количество пар квадратных скобок указывает на размерность масси­ва. Для
        многомерных массивов допускается смешанная запись:
    </p>
    <p>
    </p>
    <p>int[] а[];
    </p>
    <p>
    </p>
    <p>Переменная а имеет тип "двумерный массив, основанный на int". Аналогично объявляются массивы
        с базовым объектным типом:
    </p>
    <p>
    </p>
    <p>Point р,р1[],р2[][];
    </p>
    <p>
    </p>
    <p>Создание переменной типа массив еще не создает экземпляры это­го
        массива. Такие переменные имеют объектный тип и хранят ссылки на объекты,
        однако изначально имеют значение null (если они являются
        по­лями класса; напомним, что локальные переменные необходимо явно
        инициализировать). Чтобы создать экземпляр массива, нужно воспользо­ваться
        ключевым словом new, после чего указывается тип массива и в квадратных скобках — длина
        массива.
    </p>
    <p>
    </p>
    <p>int a[]=new
        int[5]; Point[] p = new Point[10];
    </p>
    <p>Переменная инициализируется ссылкой, указывающей на только что созданный
        массив. После его создания можно обращаться к элемен­там, используя ссылку на
        массив, далее в квадратных скобках указывает­ся индекс элемента. Индекс
        меняется от нуля, пробегая всю длину массИ'
    </p>
    <p>до максимально допустимого значения, на единицу меньшего длины массива.
    </p>
    <p>int array[]=new
        int[5]; for (int i=0;
        i&lt;5; i++) { array[i]=i*i;
    </p>
    <p>}
    </p>
    <p>for (int j-0;
        j&lt;6; j++) {
    </p>
    <p>System.out.println(j+"*"+j+"="+array[j]);
    </p>
    <p>}
    </p>
    <p>Результатом выполнения
        программы будет:
    </p>
    <p>
    </p>
    <p>0*0=0 1*1-1 2*2=4 3*3=9 4*4=16
    </p>
    <p>И далее появится ошибка времени исполнения, так как индекс пре­высит
        максимально возможное для такого массива значение. Проверка, не выходит ли
        индекс за допустимые пределы, происходит только во вре­мя исполнения программы,
        т.е. компилятор не пытается выявить эту ошибку даже в таких явных случаях, как:
    </p>
    <p>
    </p>
    <p>int i[]=new
        int[5];
    </p>
    <p>i[-2]=0; // ошибка! индекс не может быть отрицательным
    </p>
    <p>Ошибка возникнет только на
        этапе выполнения программы.
    </p>
    <p>Хотя при создании массива необходимо указывать его длину, это значение
        не входит в определение типа массива, важна лишь размерность. Таким образом,
        одна переменная может ссылаться на массивы разной длины:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>inti[]=newint[5];
    </p>
    <p>
    </p>
    <p>i=new int[7]; // переменная та же, длина массива другая
    </p>
    <p>Однако для объекта массива длина обязательно должна указываться ПРИ
        создании и уже никак не может быть изменена. В последнем примере *^ Присвоения
        переменной ссылки на массив большей длины потребо-^ось создать новый экземпляр.
    </p>
    <p>Поскольку для экземпляра массива длина является постоянной ха­рактеристикой,
        для всех массивов существует специальное поле length позволяющее узнать ее значение.
        Например:
    </p>
    <p>Point p[]=new Point[5]; for (int i=0;
        i&lt;p.length; i++) { p[i]=new Point(i, i);
    </p>
    <p>}
    </p>
    <p>Значение индекса массива всегда имеет тип int. При обращении к
        элементу можно также использовать byte, short или char, поскольку эти типы автоматически
        расширяются до int. Попытка
        задействовать long приведет к ошибке
        компиляции.
    </p>
    <p>Соответственно, и поле length имеет тип int, а теоретическая
        макси­мально возможная длина массива равняется 23'-1, то есть
        немногим боль­ше 2 млрд.
    </p>
    <p>Продолжая рассматривать тип массива, подчеркнем, что в качестве базового
        типа может использоваться любой тип Java, в том числе:
    </p>
    <p>•
        интерфейсы. В таком случае
        элементы массива могут иметь значе­ние null или ссылаться на объекты любого класса,
        реализующего этот интерфейс;
    </p>
    <p>•
        абстрактные классы. В этом
        случае элементы массива могут иметь значение null или ссылаться на объекты любого
        неабстрактного класса-наследника.
    </p>
    <p>Поскольку массив является объектным типом данных, его значения могут
        быть приведены к типу Object или, что то же
        самое, присвоены пе­ременной типа Object. Например,
    </p>
    <p>
    </p>
    <p>Object о = new int[4];
    </p>
    <p>
    </p>
    <p>Это дает интересную возможность для массивов, основанных на ти­пе Object, хранить в
        качестве элемента ссылку на самого себя:
    </p>
    <p>Object arr[] = new Object[3]; arr[0]=new Objecto; arr[1]=null;
    </p>
    <p>arr[2]=arr; // Элемент ссылается на весь массив!
    </p>
    <p>Инициализация
        массивов
    </p>
    <p>Теперь, когда мы выяснили, как создавать экземпляры массива, рас-сМОтрим, какие значения
        принимают его элементы.
    </p>
    <p>Если создать массив на основе примитивного числового типа, то из­начально
        после создания все элементы массива имеют значение по умол­чанию, то есть 0.
        Если массив объявлен на основе примитивного типа boolean, то и в этом
        случае все элементы будут иметь значение по умол­чанию false. Выше
        рассматривался пример инициализации элементов с помощью цикла for.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Рассмотрим создание массива на основе ссылочного типа. Предпо­ложим, это будет класс Point.
        При создании экземпляра массива с приме­нением ключевого слова new не создается ни
        один объект класса Point, создается лишь один объект массива. Каждый элемент массива будет
        иметь
        пустое значение null. В этом можно убедиться на простом примере:
    </p>
    <p>
    </p>
    <p>Point p[]=new Point[5]; for (int i=0;
        Kp.length; i++) { System.out.pritnln(p[i]);
    </p>
    <p>}
    </p>
    <p>Результатом будут лишь
        слова null.
    </p>
    <p>Далее нужно инициализировать элементы массива по отдельности, например, в цикле. Вообще,
        создание массива длиной п можно рассмат­ривать как
        заведение п переменных и работать с элементами массива (в последнем примере p[i]) по
        правилам
        обычных переменных.
    </p>
    <p>Кроме того, существует и другой способ создания массивов — ини­циализаторы.
        В этом случае ключевое слово new не используется, а
        ста­вятся фигурные скобки, и в них через запятую перечисляются значения всех
        элементов массива. Например, для числового массива явная иници­ализация записывается
        следующим образом:
    </p>
    <p>
    </p>
    <p>inti[]={1,3, 5};
    </p>
    <p>int j[]={}; // эквивалентно new int[0]
    </p>
    <p>Длина массива вычисляется автоматически, исходя из количества Введенных
        значений. Далее создается массив такой длины и каждому его Цементу
        присваивается указанное значение.
    </p>
    <p>Аналогично можно порождать массивы на основе объектных типов, Например:
    </p>
    <p>
    </p>
    <p>Point p=new
        Point(1,3);
    </p>
    <p>Point arr[]={p,
        new Point(2,2), null, p};
    </p>
    <p>277
    </p>
    <p>// или
    </p>
    <p>String
        sarr[]={"aaa", "bbb", "cde"+"xyz"};
    </p>
    <p>
    </p>
    <p>Однако инициализатор нельзя использовать для анонимного созда­ния
        экземпляров массива, то есть не для инициализации переменной, а например,
        для передачи параметров метода или конструктора.
    </p>
    <p>Например:
    </p>
    <p>
    </p>
    <p>public
        class Parent { private String[] values;
    </p>
    <p>
    </p>
    <p>protected Parent(String[] s) { values=s;
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>public class
        Child extends Parent {
    </p>
    <p>
    </p>
    <p>public Child(String firstName, String lastName) {
    </p>
    <p>super(???); //требуется
        анонимное создание массива
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>В конструкторе класса Child необходимо
        осуществить обращение к конструктору родителя и передать в качестве параметра
        ссылку на массив. Теоретически можно передать null, но это приведет в
        большинстве случаев к некорректной работе классов. Можно вставить выражение new String[2],
        но тогда
        вместо значений firstName и lastName будут переданы пустые строки. Попытка записать
        {firstName, lastName} приведет к ошибке компиляции, так можно только инициализировать
        переменные.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Корректное выражение
        выглядит так:
    </p>
    <p>
    </p>
    <p>new String[]{firstName, lastName}
    </p>
    <p>
    </p>
    <p>Что является некоторой смесью выражения, создающего массивы с помо­щью new, и инициализатора.
        Длина массива определяется количеством указанных значений.
    </p>
    <p>Многомерные
        массивы
    </p>
    <p>Теперь перейдем к рассмотрению многомерных массивов. Так, в сле­дующем
        примере
    </p>
    <p>inti[][]=newint[3][5];
    </p>
    <p>переменная i ссылается на
        двумерный массив, который можно предста­вить себе в виде таблицы 3x5. Суммарно
        в таком массиве содержится 15 элементов, к которым можно обращаться через
        комбинацию индексов от (О, 0) до (2, 4). Пример заполнения двумерного массива через цикл:
    </p>
    <p>int
        pithagor_table[][]=new int[5][5]; for (int i=0; i&lt;5; i++) { for (int j=0; j&lt;5; j++) {
    </p>
    <p>pithagor_table[i][j]=i*j;
    </p>
    <p>System.out.print(pithagor_table[i][j]+ "\П;
    </p>
    <p>}
    </p>
    <p>System.out.println();
    </p>
    <p>}
    </p>
    <p>Результатом выполнения
        программы будет:
    </p>
    <p>
    </p>
    <p>0 0 0 0 0 0  12 3
        4 0 2 4 6 8 О 3 6 9  12 0 4 8  12 16
    </p>
    <p>Однако такой взгляд на двумерные и многомерные массивы является неполным.
        Более точный подход заключается в том, что в Java нет двумер­ных, и вообще многомерных
        массивов, а есть массивы, базовыми типами которых
        являются также массивы. Например, тип int[] означает
        "массив чисел", a int[][] означает
        "массив массивов чисел". Поясним такую точку зрения.
    </p>
    <p>Если создать двумерный массив и определить переменную х, которая На него ссылается, то,
        используя х и два числа в паре квадратных скобок Каждое (например, х[0][0]), можно
        обратиться к любому элементу дву­мерного
        массива. Но в то же время, используя х и одно число в паре ква-ДРатных скобок, можно
        обратиться к одномерному массиву,
        который яв­ляется элементом двумерного массива. Его можно проинициализировать н°вым
        массивом с некоторой другой длиной и таблица перестанет быть прямоугольной -
        она примет произвольную форму. В частности, можно одному из одномерных массивов
        присвоить даже значение null.
    </p>
    <p>int x[][]=new int[3][5]; // прямоугольная таблица x[0]=new int[7];
        x[1]=new int[0]; x[2]=null;
    </p>
    <p>
    </p>
    <p>После таких операций массив, на который ссылается переменная х, назвать
        прямоугольным никак нельзя. Зато хорошо видно, что это просто набор одномерных
        массивов или значений null.
    </p>
    <p>Полезно подсчитать, сколько объектов порождается выражением new int[3][5]
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Правильный
        подсчет таков: создается один массив массивов (один объект) и три массива
        чисел, каждый длиной 5 (три объекта). Итого, четыре объекта.
    </p>
    <p>В рассмотренном примере три из них (массивы чисел) были тут же
        переопределены новыми значениями. Для таких случаев полезно исполь­зовать
        упрощенную форму выражения создания массивов:
    </p>
    <p>
    </p>
    <p>intx[][]=newint[3][];
    </p>
    <p>
    </p>
    <p>Такая запись порождает один объект - массив массивов - и заполня­ет его
        значениями null. Теперь понятно, что и в этом, и в предыдущем ва­рианте выражение х.length
        возвращает значение 3 - длину массива мас­сивов. Далее можно с помощью
        выражений x[i].length узнать длину каж­дого
        вложенного массива чисел, при условии, что i неотрицательно и меньше x.length, а также x[i]
        не равно null. Иначе будут возникать ошибки во время выполнения программы.
    </p>
    <p>Вообще, при создании многомерных массивов с помощью new необ­ходимо указывать все пары
        квадратных скобок, соответственно
        количест­ву измерений. Но заполненной обязательно должна быть лишь крайняя
        левая пара, это значение задаст длину верхнего массива массивов. Если за­полнить
        следующую пару, то этот массив заполнится не значениями по умолчанию null, а новыми
        созданными массивами с меньшей на единицу размерностью. Если заполнена вторая
        пара скобок, то можно заполнить третью, и так далее.
    </p>
    <p>Аналогично, для создания многомерных массивов можно использо­вать
        инициализаторы. В этом случае применяется столько вложенных фигурных скобок,
        сколько требуется:
    </p>
    <p>
    </p>
    <p>int i[][] = {{1,2}, null, {3}, {}};
    </p>
    <p>В этом примере порождается четыре объекта. Это, во-первых, мас­сив
        массивов длиной 4, а во-вторых, три массива чисел с длинами 2, 1,0,
        соответственно.
    </p>
    <p>Все рассмотренные примеры и утверждения одинаково верны для многомерных
        массивов, основанных как на примитивных, так и на ссы­лочных типах.
    </p>
    <p>
    </p>
    <p>Класс
        массива
    </p>
    <p>Поскольку массив является объектным типом данных, можно попы-таться
        представить себе, как выглядело бы объявление класса такого типа. На самом деле
        эти объявления не хранятся в файлах, или еще каком-ни­будь формате. Учитывая,
        что массив может быть объявлен на основе любо­го типа и иметь произвольную
        размерность, это физически невыполнимо, дай не требуется. Вместо этого во время
        выполнения приложения вирту­альная машина генерирует эти объявления динамически
        на основе базо­вого типа и размерности, а затем они хранятся в памяти в виде
        таких же экземпляров класса Class, как и для любых других типов.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Рассмотрим гипотетическое объявление класса для массива, осно­ванного на
        неком объектном типе Element.
    </p>
    <p>Объявление класса начинается с перечисления модификаторов, среди которых
        особую роль играют модификаторы доступа. Класс массива будет иметь такой же
        уровень доступа, как и базовый тип. То есть если Element объявлен как public-класс, то и
        массив будет иметь уровень доступа pub­lic» Для любого примитивного типа класс массива будет
        public. Можно также указать
        модификатор final, поскольку никакой класс не может на­следоваться от класса массива.
    </p>
    <p>Затем следует имя класса, на котором можно подробно не останав­ливаться,
        т.к. к типу массив обращение идет не по его имени, а по имени базового типа и
        набору квадратных скобок.
    </p>
    <p>Затем нужно указать родительский класс. Все массивы наследуются Напрямую
        от класса Object. Далее перечисляются интерфейсы, которые Реализует класс. Для массива
        это будут интерфейсы Cloneable и ^Tializable. Первый из них подробно рассматривается в конце
        этой лек­ции, а второй будет
        описан в следующих лекциях.
    </p>
    <p>Тело класса
        содержит объявление одного public final поля length типа Кроме того, переопределен метод
        с1опе() для поддержки интерфейса C|oneable.
    </p>
    <p>Сведем все вышесказанное в
        формальную запись класса:
    </p>
    <p>
    </p>
    <p>[public] class A implements Cloneable,
        java.io.Serializable { public final int length; // инициализируется при создании
    </p>
    <p>public
        Object clone() { try{
    </p>
    <p>return
        super.clone(); } catch (CloneNotSupportedException e) { throw new
        lnternalError(e.getMessage());
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Таким образом, экземпляр типа массив является полноценным объ­ектом,
        который, в частности, наследует все методы, определенные в классе Object, например,
        toString(), hashCodeQ и остальные.
    </p>
    <p>Например:
    </p>
    <p>
    </p>
    <p>// результат работы метода toString() System.out.println(new int[3]);
        System.out.println(new int[3][5]); System.out.println(new String[2]);
    </p>
    <p>
    </p>
    <p>// результат работы метода hashCode() System.out.println(newfloat[2].hashCode()); Результатом
        выполнения программы будет:
    </p>
    <p>[I@26b249 [[I@82f0db
    </p>
    <p>[Ljava.lang.String;@92d342 7051261
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>Преобразование типов для
        массивов
    </p>
    <p>Теперь, когда массив введен как полноценный тип данных в Java, рассмотрим, какое
        влияние он окажет на преобразование типов.
    </p>
    <p>Ранее подробно рассматривались переходы между примитивными11 обычными
        (не являющимися массивами) ссылочными типами
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Хотя мас­сивы являются объектными
        типами, их также будет полезно разделить п° базовому типу на две группы -
        основанные на примитивном или ссылоч­ном типе.
    </p>
    <p>Имейте в виду, что переходы между массивами и примитивными т11'
        пами являются запрещенными. Преобразования между массивами и ДР&gt;" гими
        объектными типами возможны только для класса Object и интеР' фейсов Cloneable и
        Serializable.. Массив всегда можно привести к эти&gt;'
    </p>
    <p>М типам, обратный же переход является сужением и должен произво-1*1-ся
        явным образом по усмотрению разработчика. Таким образом, ин-пес представляют
        только переходы между разными типами массивов. ^евИдно, что массив,
        основанный на примитивном типе, принципиально цельзя преобразовать к типу
        массива, основанному на ссылочном типе, и наоборот.
    </p>
    <p>Пока не будем останавливаться на этом подробно, однако заметим, уф преобразования
        между типами массивов, основанных на различных примитивных типах, невозможны ни
        при каких условиях.
    </p>
    <p>.;, Для ссылочных же типов такого строгого правила нет.
        Например, ес-дЯ/СОЗДать экземпляр массива, основанного на типе Child, то ссылку на него
        можно привести к типу массива, основанного на типе Parent.
    </p>
    <p>Child с[] = newChild[3];
        Parent р[] = с;
    </p>
    <p>Вообще, существует универсальное правило: массив, основанный на типе А, можно привести к
        массиву, основанному на типе В, если сам тип А Приводится к типу В.
    </p>
    <p>4 // если допустимо
        такое приведение: Bb = (B)newA();
    </p>
    <p>//то допустимо и
        приведение массивов: Bb[]=(B[]) newA[3];
    </p>
    <p>; Применяя это правило рекурсивно, можно преобразовывать много­мерные
        массивы. Например, массив Child[][] можно привести к Parent[][], так как их базовые типы
        приводимы (Child[] к Parent[]) также на основе
        этого правила (поскольку базовые типы Child и Parent приво­димы в силу правил наследования).
    </p>
    <p>Как обычно, расширения можно проводить неявно (как в предыду­щем
        примере), а сужения - только явным приведением.
    </p>
    <p>* Вернемся к массивам, основанным на примитивном типе. Невозмож­ность их
        участия в преобразованиях типов связана, конечно, с различиями м*Аду
        простыми и ссылочными типами данных. Поскольку элементами °®Ьектных массивов
        являются ссылки, они легко могут участвовать в при-^ении. Напротив, элементы
        простых типов действительно хранят число-Вь,еили булевские значения.
        Предположим, такое преобразование осуще-Ст»Имо:
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>// пример вызовет ошибку компиляции byte Ь[]={1, 2,3}; int i[]=b;
    </p>
    <p>В таком случае, элементы Ь[0] и &#161;[0] хранили бы значения разцц типов. Стало быть,
        преобразование потребовало бы копирования с одн0 временным
        преобразованием типа всех элементов исходного массива. ЎЎ результате был бы
        создан новый массив, элементы которого равнялись б( по значению
        элементам исходного массива.
    </p>
    <p>Но преобразование типа не может порождать новые объекты. Такие операции
        должны выполняться только явным образом с применение^ ключевого слова new. По этой причине
        преобразования типов массивов основанных на примитивных типах, запрещены.
    </p>
    <p>Если же копирование элементов действительно требуется, то нужно сначала
        создать новый массив, а затем воспользоваться стандартной функцией System.аггауСору(),
        которая эффективно выполняет копиро-вание элементов одного массива в другой.
    </p>
    <p>
    </p>
    <p>Ошибка
        ArrayStoreException
    </p>
    <p>Преобразование между
        типами массивов, основанных на ссылочных типах, может стать причиной одной
        довольно неочевидной ошибки. Рассмотрим пример:
    </p>
    <p>
    </p>
    <p>Child с[] = new Child[5]; Parent р[]=с; p[0]=new Parent();
    </p>
    <p>
    </p>
    <p>С точки зрения компилятора код совершенно корректен. Преобра­зование во
        второй строке допустимо. В третьей строке элементу массива типа Parent присваивается
        значение того же типа.
    </p>
    <p>Однако при выполнении такой программы возникнет ошибка. Нельзя забывать,
        что преобразование не меняет объект, изменяется лишь способ доступа к нему. В
        свою очередь, объект всегда "помнит", от какого типа он был порожден. С
        учетом этих замечаний становится ясно, что в третьей строке делается
        попытка добавить в массив Child значение типа Parent, что некорректно.
    </p>
    <p>Действительно, ведь переменная с продолжает ссылаться на этот массив, а
        значит, следующей строкой может быть такое обращение:
    </p>
    <p>
    </p>
    <p>c[0].onlyChildMethod();
    </p>
    <p>
    </p>
    <p>где метод onlyChildMethodO определен только в
        классе Child. Данное об­ращение совершенно корректно, а значит, недопустима
        ситуация, коь*1 элемент с[0] ссылается на объект, несовместимый с Child.
    </p>
    <p>Таким образом,
        несмотря на отсутствие ошибок компиляции, вирту-наЯ машина при
        выполнении программы всегда осуществляет допол-\ггельную проверку перед
        присвоением значения элементу массива. Не-бхоДиМО Удостовериться,
        что реальный массив, существующий на мо-°ент
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>исполнения, действительно может
        хранить присваиваемое значение, рели это условие нарушается, то
        возникает ошибка, которая называется ArrayStoreException.
    </p>
    <p>Может сложиться впечатление, что разобранная ситуация является надуманной,-
        зачем преобразовывать массив и тут же задавать для него неверное значение?
        Однако преобразование при присвоении значений является лишь примером.
        Рассмотрим объявление метода:
    </p>
    <p>public void process(Parent[] р) { if (p!=null
        &amp;&amp; p.length&gt;0) { p[0]=new Parent();
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Метод выглядит абсолютно корректным, все потенциально ошибоч­ные
        ситуации проверяются if-выражением. Однако следующий вызов этого метода все равно приводит к
        ошибке:
    </p>
    <p>
    </p>
    <p>process(new Chмld[3] ));
    </p>
    <p>
    </p>
    <p>И это будет как раз ошибка ArrayStoreException.
    </p>
    <p>
    </p>
    <p>Переменные
        типа массив и их значения
    </p>
    <p>Завершим описание взаимосвязи типа переменной и типа значений, которые
        она может хранить.
    </p>
    <p>Как обычно,
        массивы, основанные на простых и ссылочных типах, мы описываем раздельно.
    </p>
    <p>Переменная типа
        массив примитивных величин может хранить зна­чения только точно такого же типа,
        либо null.
    </p>
    <p>Переменная типа
        "массив ссылочных величин" может хранить сле­дующие значения:
    </p>
    <p>1- null;
    </p>
    <p>2. значения точно такого же типа, что и тип переменной;
    </p>
    <p>3. все значения типа массив, основанный на типе, приводимом к ба­зовому
        типу исходного массива.
    </p>
    <p>Все эти утверждения непосредственно следуют из рассмотренных вЫЩе
        особенностей приведения типов массивов.
    </p>
    <p>Еще раз напомним про исключительный класс Object. Перемени такого
        типа могут ссылаться на любые объекты, порожденные как классов, так и от
        массивов.
    </p>
    <p>Сведем все эти утверждения в таблицу.
    </p>
    <p>
    </p>
    <table border="0" cellpadding="0" cellspacing="0" class="MsoNormalTable">
        <tr>
            <td valign="top" width="9">
                <p>
                </p>
            </td>
            <td valign="top" width="105">
                <p>Тип переменной
                </p>
            </td>
            <td valign="top" width="318">
                <p>Допустимые типы ее значения
                </p>
            </td>
            <td valign="top" width="11">
                <p>
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="9">
                <p>
                </p>
            </td>
            <td valign="top" width="105">
                <p>Массив
                </p>
            </td>
            <td valign="top" width="318">
                <p>•null
                </p>
            </td>
            <td rowspan="2" valign="top" width="11">
                <p>І
                </p>
                <p>1
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="9">
                <p>
                </p>
            </td>
            <td valign="top" width="105">
                <p>простых чисел
                </p>
            </td>
            <td valign="top" width="318">
                <p>• в точности совпадающий
                    с типом переменной
                </p>
            </td>
            <p>
            </p>
        </tr>
        <tr>
            <td valign="top" width="9">
                <p>
                </p>
            </td>
            <td valign="top" width="105">
                <p>Массив
                </p>
            </td>
            <td valign="top" width="318">
                <p>•null
                </p>
            </td>
            <td valign="top" width="11">
                <p>
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="9">
                <p>
                </p>
            </td>
            <td valign="top" width="105">
                <p>ссылочных
                </p>
            </td>
            <td valign="top" width="318">
                <p>• совпадающий с типом
                    переменной
                </p>
            </td>
            <td valign="top" width="11">
                <p>ї
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="9">
                <p>
                </p>
            </td>
            <td valign="top" width="105">
                <p>значений
                </p>
            </td>
            <td valign="top" width="318">
                <p>• массивы
                    ссылочных значений, удовлетворяющих следующему условию: если тип переменной
                    -массив на основе типа А, то значение типа массив на основе типа В допустимо
                    тогда и только тогда, когда В приводимо к А
                </p>
            </td>
            <td valign="top" width="11">
                <p>І
                </p>
                <p>!
                </p>
                <p>si
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="9">
                <p>
                </p>
            </td>
            <td valign="top" width="105">
                <p>Object
                </p>
            </td>
            <td valign="top" width="318">
                <p>•null
                </p>
                <p>•любой ссылочный,
                    включая массивы
                </p>
            </td>
            <td valign="top" width="11">
                <p>
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="9">
                <p>
                </p>
            </td>
            <td valign="top" width="105">
                <p>
                </p>
            </td>
            <td valign="top" width="318">
                <p>
                </p>
            </td>
            <td valign="top" width="11">
                <p>
                </p>
            </td>
        </tr>
    </table>
    <p>Табл. 7.1. Тип переменной и тип ее значения.
    </p>
    <p>
    </p>
    <p>Клонирование
    </p>
    <p>Механизм клонирования, как следует из названия, позволяет по­рождать
        новые объекты на основе существующего, которые обладали бы точно таким же
        состоянием, что и исходный. То есть ожидается, что для исходного объекта,
        представленного ссылкой х, и результата клонирова­ния, возвращаемого методом
        х.с1опе(), выражение
    </p>
    <p>х != х.с1опе()
    </p>
    <p>должно быть истинным, как и выражение
    </p>
    <p>х.с1опе().деЮ1аз5() ==
        х.деЮ1аз5()
    </p>
    <p>Наконец, выражение
    </p>
    <p>х.едиа1з(х.с1опе())
    </p>
    <p>
    </p>
    <p>также верно. Реализация такого метода с1опе() осложняется целым ряд0&gt;|
        потенциальных проблем, например:
    </p>
    <p>• класс, от которого порожден объект, может иметь разнообразные
        конструкторы, которые к тому же могут быть недоступны (напри­мер, модификатор
        доступа private);
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>• цепочка наследования, которой принадлежит исходный класс, может быть
        довольно длинной, и каждый родительский класс мо­жет иметь свои поля -
        недоступные, но важные для воссоздания состояния исходного объекта;
    </p>
    <p>• в зависимости от логики реализации возможна ситуация, когда не все поля
        должны копироваться для корректного клонирования; одни могут оказаться лишними,
        другие потребуют дополнитель­ных вычислений или преобразований;
    </p>
    <p>• возможна ситуация, когда объект нельзя клонировать, дабы не на­рушить
        целостность системы.
    </p>
    <p>Поэтому было реализовано
        следующее решение.
    </p>
    <p>Класс Object содержит метод clone(). Рассмотрим его объявление:
    </p>
    <p>protected native Object clone() throws CloneNotSupportedException; Именно он используется для
        клонирования. Далее возможны два ва-пЮнта.
    </p>
    <p>Первый вариант: разработчик может в своем классе переопределить эЦг метод
        и реализовать его по своему усмотрению, решая перечисленные ЩЮблемы так, как
        того требует логика разрабатываемой системы. Упомя­нутые условия, которые должны
        быть истинными для клонированного овЫжта, не являются обязательными и
        программист может им не следо­вать, если это требуется для его класса.
    </p>
    <p>Второй вариант предполагает использование реализации метода clone()
        в самом классе Object. То, что он
        объявлен как native, говорит о ЮМ, что его реализация предоставляется виртуальной машиной.
        Естест­венно, перечисленные трудности легко могут быть преодолены самой WM, ведь она хранит
        в памяти все свойства объектов.
    </p>
    <p>„.-; При выполнении
        метода clone() сначала проверяется, можно ли ^Тонировать исходный объект. Если
        разработчик хочет сделать объек-IW своего класса доступными для клонирования через
        Object.clone(), ^ он должен реализовать в своем классе интерфейс Cloneable. В этом
        интерфейсе нет ни одного элемента, он служит лишь признаком для
        вИртуальной машины, что объекты могут быть клонированы. Если
        ^Роверка не выполняется успешно, метод порождает ошибку C|°neNotSupportedException.
    </p>
    <p>Если интерфейс Cloneable реализован, то
        порождается новый объ-е*тоттого же класса, от которого был создан исходный объект. При этом
        ^Пирование
        выполняется на уровне виртуальной машины, никакие кон-^УКторы не вызываются.
        Затем значения всех полей, объявленных, унаследованных либо объявленных в
        родительских классах, копируют^ Полученный объект возвращается в качестве
        клона.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Обратите внимание, что сам класс Object не реализует интерфС1] Cloneable, а потому попытка
        вызова new Object().clone() будет приводи, к ошибке времени исполнения. Метод с1опе()
        предназначен скорее ;щ использования в наследниках, которые могут обращаться к нему с пом0.
        шью выражения super.clone(). При этом могут быть сделаны следующ^ изменения:
    </p>
    <p>•
        модификатор доступа
        расширен до public;
    </p>
    <p>•
        удалено предупреждение об
        ошибке CloneNotSupportedException
    </p>
    <p>•
        результирующий объект
        может быть модифицирован любым спо­собом, на усмотрение разработчика.
    </p>
    <p>Напомним, что все массивы реализуют интерфейс Cloneable и, та­ким образом,
        доступны для клонирования.
    </p>
    <p>Важно помнить, что все поля клонированного объекта приравнива­ются, их
        значения никогда не клонируются. Рассмотрим пример:
    </p>
    <p>public class Test implements Cloneable { Point
        p; int height;
    </p>
    <p>
    </p>
    <p>public Test(int x, int y,
        int z) { p=new Point(x, y); height=z;
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>public static void main(String s[]) { Test
        t1=new Test(1, 2, 3), t2; try{
    </p>
    <p>t2=(Test)t1.clone();
        } catch (CloneNotSupportedException e) {} t1.p.x=-1; t1.height=-1;
    </p>
    <p>System. out.println("t2. p. x=" + t2.p.x +
        ", t2.height=" +12.height);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>Результатом работы программы будет: t2.p.x=-1, t2.height=3
    </p>
    <p>Из примера видно, что примитивное поле было скопировано и далее
        существует независимо в исходном и клонированном объектах. Изменение одного не
        сказывается на другом.
    </p>
    <p>А вот ссылочное поле было скопировано по ссылке, оба объекта ссы­лаются
        на один и тот же экземпляр класса Point. Поэтому
        изменения, происходящие с исходным объектом, сказываются на клонированном.
    </p>
    <p>Этого можно избежать, если
        переопределить метод clone() в классе Test.
    </p>
    <p>
    </p>
    <p>public Object clone() { Test clone=null;
        try{
    </p>
    <p>clone=(Test) super.clone(); } catch
        (CloneNotSupportedException e) { throw new InternalError(e.getMessageO);
    </p>
    <p>}
    </p>
    <p>clone.p=(Point)clone.p.clone();
        return clone;
    </p>
    <p>}
    </p>
    <p>Обратите внимание, что результат метода Object.clone() приходится явно
        приводить к типу Test, хотя его реализация гарантирует, что клониро­ванный объект будет
        порожден именно от этого класса. Однако тип возвра­щаемого значения в данном
        методе для универсальности объявлен как Object, поэтому явное
        сужение необходимо.
    </p>
    <p>Теперь метод main можно упростить:
    </p>
    <p>public static void main(String s[]) { Testt1=newTest(1,
        2, 3); Test t2=(Test)t1.clone(); t1.p.x=-1; t1.height=-1;
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>System.out.println("t2.p.x="
        + t2.p.x + ", t2.height=" +12.height);
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Результатом будет:
    </p>
    <p>
    </p>
    <p>І2.р.х=1, і2.ІтеідІтг=3
    </p>
    <p>То есть теперь все поля исходного и клонированного объектов стали Независимыми.
    </p>
    <p>Реализация такого "неглубокого" клонирования в методе °^есісІопе() необходима, так как в
        противном случае клонирование вто­ростепенного
        объекта могло бы привести к огромным затратам ресурсов ведь этот объект может
        содержать ссылки на более значимые объекты, а те при клонировании также
        начали бы копировать свои поля, и так далее Кроме того, типом поля клонируемого
        объекта может быть класс, не реа­лизующий Cloneable, что приводило бы к дополнительным
        проблемам. Как показано в примере,
        при необходимости дополнительное копирова­ние можно добавить самостоятельно.
    </p>
    <p>
    </p>
    <p>Клонирование массивов
    </p>
    <p>Итак, любой массив может быть клонирован. В этом разделе хоте­лось бы
        рассмотреть особенности, возникающие из-за того, что Object.с1опе() копирует только один
        объект.
    </p>
    <p>Рассмотрим пример:
    </p>
    <p>
    </p>
    <p>int а[]={1, 2, 3};
    </p>
    <p>intb[]=(int[])a.clone();
    </p>
    <p>а[0]=0;
    </p>
    <p>System.out.println(b[0]);
    </p>
    <p>Результатом будет ноль, что вполне очевидно, так как весь массив
        представлен одним объектом, который не будет зависеть от своей копии. Усложняем
        пример:
    </p>
    <p>
    </p>
    <p>inta[][]={{1,2},{3}};
    </p>
    <p>int
        b[][]=(int[][])a.clone();
    </p>
    <p>
    </p>
    <p>if (-И
    </p>
    <p>// первый вариант:
    </p>
    <p>a[0]=newint[]{0};
    </p>
    <p>System.out.println(b[0][0]); } else {
    </p>
    <p>// второй вариант:
    </p>
    <p>a[0][0]=0;
    </p>
    <p>System.
        out.println(b[0][0]);
    </p>
    <p>}
    </p>
    <p>Разберем, что будет происходить в этих двух случаях. Начнем с того, что в первой строке
        создается двухмерный массив, состоящий из двух од­номерных. Итого три объекта.
        Затем, на следующей строке при клониро­вании будет создан новый двухмерный
        массив, содержащий ссылки на те же самые одномерные массивы.
    </p>
    <p>Теперь несложно предсказать результат обоих вариантов. В перв0&gt;| случае
        в исходном массиве меняется ссылка, хранящаяся в первом эДе' менте, что не
        принесет никаких изменений для клонированного объекта. jja консоли появится 1.
    </p>
    <p>Во втором случае модифицируется существующий массив, что ска­жется на
        обоих двухмерных массивах. На консоли появится 0.
    </p>
    <p>Обратите внимание, что если из примера убрать условие if-else, так, что­бы
        отрабатывал первый вариант, а затем
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>второй, то результатом будет опять 1,
        поскольку в части второго варианта модифицироваться будет уже новый массив,
        порожденный в части первого варианта.
    </p>
    <p>Таким образом, в Java предоставляется
        мощный, эффективный и гибкий механизм клонирования, который легко применять и
        модифицировать под конкретные нужды. Особенное внимание должно уделяться
        копированию объектных полей, которые по умолчанию копируются только по ссылке.
    </p>
    <p>
    </p>
    <p>Заключение
    </p>
    <p>В этой лекции было рассмотрено устройство массивов в Java. Подоб­но массивам
        в других языках, они представляют собой набор значений од­ного типа. Основным
        свойством массива является длина, которая в Java может равняться нулю. В противном случае,
        массив обладает элементами в
        количестве, равном длине, к которым можно обратиться, используя ин­декс, изменяющийся от 0
        до величины длины без единицы. Длина задает­ся при создании массива и у
        созданного массива не может быть изменена. Однако она не входит в определение
        типа, а потому одна переменная мо­жет ссылаться на массивы одного типа с
        различной длиной.
    </p>
    <p>Создать массив можно с помощью ключевого слова new, поскольку все
        массивы, включая определенные на основе примитивных значений, Имеют объектный
        тип. Другой способ - воспользоваться инициализато­ром и перечислить значения
        всех элементов. В первом случае элементы принимают значения по умолчанию (0, false, null).
    </p>
    <p>Особым образом в Java устроены многомерные массивы. Они, по сути, *Мяются одномерными,
        основанными на массивах меньшей размерности. Такой подход
        позволяет единообразно работать с многомерными масси­вами. Также он дает
        возможность создавать не только "прямоугольные" Массивы, но и массивы любой конфигурации.
    </p>
    <p>Хотя массив и является ссылочным типом, работа с ним зачастую Имеет
        некоторые особенности. Рассматриваются правила приведения ти-ца массива. Как для любого
        объектного типа, приведение к Object явля-
    </p>
    <p>расширяющим. Приведение массивов, основанных на ссылочных ^ах, во многом подчиняется
        обычным правилам. А вот примитивные ^ссивы преобразовывать нельзя. С преобразованиями
        связано и возник­новение
        ошибки ArrayStoreException, причина которой - невозможность *°ЧНого отслеживания типов в
        преобразованном массиве для компилятора.
    </p>
    <p>В заключение рассматриваются последние случаи взаимосвязи типа переменной
        и ее значения.
    </p>
    <p>Наконец, изучается механизм клонирования, существующий с са­мых первых
        версий Java и позволяющий
        создавать точные копии объек-тов, если их классы позволяют это делать, реализуя
        интерфейс Cloneable Поскольку стандартное клонирование порождает только один новый объект,
        это приводит к особым эффектам при работе с объектными поля­ми классов и
        массивами.
    </p>
    <p>Вариант 1
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>Сколько
        различных ошибок (компиляции, времени выполнения, логических) в следующем
        примере? intb[]=newint[5]; for (int i=1; i&lt;=b.length();       { b[i]=Math.sqrt(i);
    </p>
    <p>}
    </p>
    <p>&#9633; 3
    </p>
    <p>&#9633; 4
    </p>
    <p>&#9633;
        5
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.      Сколько
        объектов порождается при инициализации
        массива new int[3][4]? new int[3][][]?
    </p>
    <p>&#9633;
        1,1
    </p>
    <p>&#9633;
        3,3
    </p>
    <p>&#9633;
        4, 1
    </p>
    <p>&#9633;
        4,3
    </p>
    <p>&#9633;
        12, 3
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.      Хотя
        примитивные массивы не могут участвовать в
        преобразованиях, однако массивы int[][] и byte[][] могут
        рассматриваться как одномерные объектные массивы,
        основанные на ссылочном типе «одномерный примитивный
        массив». Могут ли такие типы быть преобразованы из
        одного в другой?
    </p>
    <p>&#9633; да П   нет
    </p>
    <p>
    </p>
    <p>
    </p>
    <table align="left" cellpadding="0" cellspacing="0">
        <tr>
            <td height="0" width="472"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <center><img alt="Подпись:  " height="25"
                             src="http://kufas.ru/java.files/image016.png" width="49"></center>
            </td>
        </tr>
    </table>
    <p>Вариант 2
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>1.   Может ли массив
        основываться на абстрактных классах? Интерфейсах?
    </p>
    <p>&#9633;
        да, да
    </p>
    <p>&#9633;
        да, нет
    </p>
    <p>&#9633;
        нет, да
    </p>
    <p>&#9633;
        нет, нет
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.   От какого класса
        наследуются классы массивов?
    </p>
    <p>П   особый класс для массивов
        &#9633;   object
    </p>
    <p>П   одномерные массивы - от Object, двумерные
        - от одномерных и т.д.
    </p>
    <p>П   ни
        от какого
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.   Может ли возникнуть ошибка ArrayStoreException при работе следующих методов? public void
        setCars(Car с[])
        { c[0]=newCar();
    </p>
    <p>}
    </p>
    <p>public void setCars2(Car c[]) { if (c[0] instanceof
        Car) { c[0]=newCar();
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>public void setNumbers(int x[]) { x[0]=0;
    </p>
    <p>}
    </p>
    <p>П   ошибка
        возможна в первом методе П   ошибка
        возможна во втором методе П   ошибка
        возможна в третьем методе
    </p>
    <p>Вариант 3
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>1.      Как
        создать массив, эквивалентный объявляемому ниже,
        но без заведения переменной?
        intx[][]=newint[2][3];
    </p>
    <p>&#9633;
        newint[2][3]
    </p>
    <p>&#9633;
        {{0, 0}, {0, 0}, {0, 0}}
    </p>
    <p>&#9633;
        {{0, 0, 0}, {0, 0, 0}}
    </p>
    <p>&#9633;
        newint[][]{{0, 0},
        {0, 0}, {0, 0}}
    </p>
    <p>&#9633;
        newint[][]{{0, 0,
        0}, {0, 0, 0}}
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.      Как
        определить, можно ли преобразовать один
        тип массива к другому?
    </p>
    <p>[~|  
        любые массивы приводимы, поскольку являются объектами
    </p>
    <p>&#9633;        А[]
        можно привести к В[], если А приводится к В
    </p>
    <p>&#9633;       А[]
        можно привести к В[], если А приводится к В, и А, В - ссылочные типы
    </p>
    <p>Г~|  
        массивы не преобразовываются
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.     Можно
        ли клонировать объекты следующего класса?
        public class Point {
    </p>
    <p>private int x, у;
    </p>
    <p>public Point(int nx, int ny) {
    </p>
    <p>x=nx;
    </p>
    <p>y=ny;
    </p>
    <p>}
    </p>
    <p>public Object clone() { return new Point(x, y);
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>&#9633;       да
        Ц   нет
    </p>
    <p>
    </p>
    <center>
    </center>
</div>

</body>
</html>
