<!DOCTYPE html>
<html>
<head>

    <title>12. Лекция: Создание приложений с графическим интерфейсом пользователя.</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<p>В этой лекции рассматривается создание простейшего приложения с графическим интерфейсом
    пользователя. Для построения интерфейса не применяются визуальные средства («построители
    интерфейса»), а используются возможности графической библиотеки виджетов (Tk).</p>
<p>Обзор графических библиотек</p>
<p>Строить графический интерфейс пользователя (GUI, Graphical User Interface) для программ на языке
    Python можно при помощи соответствующих библиотек компонентов графического интерфейса или,
    используя кальку с английского, библиотек виджетов.</p>
<p>Следующий список далеко не полон, но отражает многообразие существующих решений:</p>
<p>Tkinter Многоплатформенный пакет имеет хорошее управление расположением компонентов. Интерфейс
    выглядит одинаково на различных платформах (Unix, Windows, Macintosh). Входит в стандартную
    поставку Python. В качестве документации можно использовать руководство «An Introduction to
    Tkinter» («Введение в Tkinter»), написанное Фредриком Лундом:
    http://www.pythonware.com/library/tkinter/introduction/</p>
<p>wxPython Построен на многоплатформной библиотеке wxWidgets (раньше называлась wxWindows).
    Выглядит родным для всех платформ, активно совершенствуется, осуществлена поддержка GL. Имеется
    для всех основных платформ. Возможно, займет место Tkinter в будущих версиях Python. Сайт:
    http://www.wxpython.org/</p>
<p>PyGTK Набор визуальных компонентов для GTK+ и Gnome. Только для платформы GTK.</p>
<p>PyQT/PyKDE Хорошие пакеты для тех, кто использует Qt (под UNIX или Windows) или KDE.</p>
<p>Pythonwin Построен вокруг MFC, поставляется вместе с оболочкой в пакете win32all; только для
    Windows.</p>
<p>pyFLTK Аналог Xforms, поддержка OpenGL. Имеется для платформ Windows и Unix. Сайт:
    http://pyfltk.sourceforge.net/</p>
<p>AWT, JFC, Swing Поставляется вместе с Jython, а для Jython доступны средства, которые использует
    Java. Поддерживает платформу Java.</p>
<p>anygui Независимый от нижележащей платформы пакет для построения графического интерфейса для
    программ на Python. Сайт: http://anygui.sourceforge.net/</p>
<p>PythonCard Построитель графического интерфейса, сходный по идеологии с HyperCard/MetaCard.
    Разработан на базе wxPython. Сайт: http://pythoncard.sourceforge.net/</p>
<p>Список актуальных ссылок на различные графические библиотеки, доступные из Python, можно найти по
    следующему адресу: http://phaseit.net/claird/comp.lang.python/python_GUI.html</p>
<p>Библиотеки могут быть многоуровневыми. Например, PythonCard использует wxPython, который, скажем,
    на платформе Linux базируется на многоплатформной GUI–библиотеке wxWindows, которая, в свою
    очередь, базируется на GTK+ или на Motif, а те — тоже используют для вывода X Window. Кстати,
    для Motif в Python имеются свои привязки.</p>
<p>В лекции будет рассматриваться пакет Tkinter, который по сути является оберткой для Tcl/Tk —
    известного графического пакета для сценарного языка Tcl. На примере этого пакета легко изучить
    основные принципы построения графического интерфейса пользователя.</p>
<p>О графическом интерфейсе</p>
<p>Почти все современные графические интерфейсы общего назначения строятся по модели WIMP — Window,
    Icon, Menu, Pointer (окно, иконка, меню, указатель). Внутри окон рисуются элементы графического
    интерфейса, которые для краткости будут называться виджетами (widget — штучка). Меню могут
    располагаться в различных частях окна, но их поведение достаточно однотипно: они служат для
    выбора действия из набора предопределенных действий. Пользователь графического интерфейса
    «объясняет» компьютерной программе требуемые действия с помощью указателя. Обычно указателем
    служит курсор мыши или джойстика, однако есть и другие «указательные» устройства. С помощью
    иконок графический интерфейс приобретает независимость от языка и в некоторых случаях позволяет
    быстрее ориентироваться в интерфейсе.</p>
<p>Основной задачей графического интерфейса является упрощение коммуникации между пользователем и
    компьютером. Об этом следует постоянно помнить при проектировании интерфейса. Применение
    имеющихся в наличии у программиста (или дизайнера) средств при создании графического интерфейса
    нужно свести до минимума, выбирая наиболее удобные пользователю виджеты в каждом конкретном
    случае. Кроме того, полезно следовать принципу наименьшего удивления: из формы интерфейса должно
    быть понятно его поведение. Плохо продуманный интерфейс портит ощущения пользователя от
    программы, даже если за фасадом интерфейса скрывается эффективный алгоритм. Интерфейс должен
    быть удобен для типичных действий пользователя. Для многих приложений такие действия выделены в
    отдельные серии экранов, называемые «мастерами» (wizards). Однако если приложение — скорее
    конструктор, из которого пользователь может строить нужные ему решения, типичным действием
    является именно построение решения. Определить типичные действия не всегда легко, поэтому
    компромиссом может быть гибрид, в котором есть «мастера» и хорошие возможности для собственных
    построений. Тем не менее, графический интерфейс не является самым эффективным интерфейсом во
    всех случаях. Для многих предметных областей решение проще выразить с помощью деклараций на
    некотором формальном языке или алгоритма на сценарном языке.</p>
<p>Основы Tk</p>
<p>Основная черта любой программы с графическим интерфейсом — интерактивность. Программа не просто
    что–то считает (в пакетном режиме) от начала своего запуска до конца: ее действия зависят от
    вмешательства пользователя. Фактически, графическое приложение выполняет бесконечный цикл
    обработки событий. Программа, реализующая графический интерфейс, событийно–ориентирована. Она
    ждет от интерфейса событий, которые и обрабатывает сообразно своему внутреннему состоянию.</p>
<p>Эти события возникают в элементах графического интерфейса (виджетах) и обрабатываются
    прикрепленными к этим виджетам обработчиками. Сами виджеты имеют многочисленные свойства (цвет,
    размер, расположение), выстраиваются в иерархию принадлежности (один виджет может быть хозяином
    другого), имеют методы для доступа к своему состоянию.</p>
<p>Расположением виджетов (внутри других виджетов) ведают так называемые менеджеры расположения.
    Виджет устанавливается на место по правилам менеджера расположения. Эти правила могут определять
    не только координаты виджета, но и его размеры. В Tk имеются три типа менеджеров расположения:
    простой упаковщик (pack), сетка (grid) и произвольное расположение (place).</p>
<p>Но этого для работы графической программы недостаточно. Дело в том, что некоторые виджеты в
    графической программе должны быть взаимосвязаны определенным образом. Например, полоска
    прокрутки может быть взаимосвязана с текстовым виджетом: при использовании полоски текст в
    виджете должен двигаться, и наоборот, при перемещении по тексту полоска должна показывать
    текущее положение. Для связи между виджетами в Tk используются переменные, через которые виджеты
    и передают друг другу параметры.</p>
<p>Классы виджетов</p>
<p>Для построения графического интерфейса в библиотеке Tk отобраны следующие классы виджетов (в
    алфавитном порядке):</p>
<p>Button (Кнопка) Простая кнопка для вызова некоторых действий (выполнения определенной
    команды).</p>
<p>Canvas (Рисунок) Основа для вывода графических примитивов.</p>
<p>Checkbutton (Флажок) Кнопка, которая умеет переключаться между двумя состояниями при нажатии на
    нее.</p>
<p>Entry (Поле ввода) Горизонтальное поле, в которое можно ввести строку текста.</p>
<p>Frame (Рамка) Виджет, который содержит в себе другие визуальные компоненты.</p>
<p>Label (Надпись) Виджет может показывать текст или графическое изображение.</p>
<p>Listbox (Список) Прямоугольная рамка со списком, из которого пользователь может выделить один или
    несколько элементов.</p>
<p>Menu (Меню) Элемент, с помощью которого можно создавать всплывающие (popup) и ниспадающие
    (pulldown) меню.</p>
<p>Menubutton (Кнопка–меню) Кнопка с ниспадающим меню.</p>
<p>Message (Сообщение) Аналогично надписи, но позволяет заворачивать длинные строки и менять размер
    по требованию менеджера расположения.</p>
<p>Radiobutton (Селекторная кнопка) Кнопка для представления одного из альтернативных значений.
    Такие кнопки, как правило, действует в группе. При нажатии на одну из них кнопка группы,
    выбранная ранее, «отскакивает».</p>
<p>Scale (Шкала) Служит для задания числового значения путем перемещения движка в определенном
    диапазоне.</p>
<p>Scrollbar (Полоса прокрутки) Полоса прокрутки служит для отображения величины прокрутки в других
    виджетах. Может быть как вертикальной, так и горизонтальной.</p>
<p>Text (Форматированный текст) Этот прямоугольный виджет позволяет редактировать и форматировать
    текст с использованием различных стилей, внедрять в текст рисунки и даже окна.</p>
<p>Toplevel (Окно верхнего уровня) Показывается как отдельное окно и содержит внутри другие
    виджеты.</p>
<p>Все эти классы не имеют отношений наследования друг с другом — они равноправны. Этот набор
    достаточен для построения интерфейса в большинстве случаев.</p>
<p>События</p>
<p>В системе современного графического интерфейса имеется возможность отслеживать различные события,
    связанные с клавиатурой и мышью, и происходящие на «территории» того или иного виджета. В Tk
    события описываются в виде текстовой строки — шаблона события, состоящего из трех элементов
    (модификаторы, тип события и детализация события).</p>
<p>Тип события Содержание события</p>
<p>Activate Активизация окна</p>
<p>ButtonPress Нажатие кнопки мыши</p>
<p>ButtonRelease Отжатие кнопки мыши</p>
<p>Deactivate Деактивация окна</p>
<p>Destroy Закрытие окна</p>
<p>Enter Вхождение курсора в пределы виджета</p>
<p>FocusIn Получение фокуса окном</p>
<p>FocusOut Потеря фокуса окном</p>
<p>KeyPress Нажатие клавиши на клавиатуре</p>
<p>KeyRelease Отжатие клавиши на клавиатуре</p>
<p>Leave Выход курсора за пределы виджета</p>
<p>Motion Движение мыши в пределах виджета</p>
<p>MouseWheel Прокрутка колесика мыши</p>
<p>Reparent Изменение родителя окна</p>
<p>Visibility Изменение видимости окна</p>
<p>Примеры описаний событий строками и некоторые названия клавиш приведены ниже:</p>
<p>"&lt;ButtonPress–3&gt;" или просто "&lt;3&gt;" — щелчок правой кнопки мыши (то есть, третьей,
    если считать на трехкнопочной мыши слева–направо). "&lt;Shift–Double–Button–1&gt;" — двойной
    щелчок мышью (левой кнопкой) с нажатой кнопкой Shift. В качестве модификаторов могут быть
    использованы следующие (список неполный):</p>
<p>Листинг</p>
<p>Control, Shift, Lock,</p>
<p>Button1–Button5 или B1–B5,</p>
<p>Meta, Alt, Double, Triple.</p>
<p>Просто символ обозначает событие — нажатие клавиши. Например, «k» — тоже, что "&lt;KeyPress–k&gt;".
    Для неалфавитно–цифровых клавиш есть специальные названия:</p>
<p>Листинг</p>
<p>Cancel, BackSpace, Tab, Return, Shift_L, Control_L, Alt_L,</p>
<p>Pause, Caps_Lock, Escape, Prior, Next, End, Home, Left,</p>
<p>Up, Right, Down, Print, Insert, Delete, F1, F2, F3, F4, F5, F6, F7,</p>
<p>F8, F9, F10, F11, F12, Num_Lock, Scroll_Lock, space, less</p>
<p>Здесь &lt;space&gt; обозначает пробел, а &lt;less&gt; - знак меньше. &lt;Left&gt;, &lt;Right&gt;,
    &lt;Up&gt;, &lt;Down&gt; - стрелки. &lt;Prior&gt;, &lt;Next&gt; - это PageUp и PageDown.
    Остальные клавиши более или менее соответствуют надписям на стандартной клавиатуре.</p>
<p>Примечание:</p>
<p>Следует заметить, что Shift_L, в отличие от Shift, нельзя использовать как модификатор.</p>
<p>В конкретной среде комбинации, означающие что–то особенное в системе, могут не дойти до
    графического приложения. Например, известный всем Ctrl–Alt–Del.</p>
<p>Следующая программа позволяет печатать направляемые виджету события, в частности — keysym, а
    также анализировать, как различные клавиши можно представить в шаблоне события:</p>
<p>Листинг</p>
<p>from Tkinter import *</p>
<p>tk = Tk() # основное окно приложения</p>
<p>txt = Text(tk) # текстовый виджет, принадлежащий окну tk</p>
<p>txt.pack() # располагается менеджером pack</p>
<p># функция обработки события</p>
<p>def event_info(event):</p>
<p>txt.delete(«1.0», END) # удаляется с начала до конца текста</p>
<p>for k in dir(event): # цикл по атрибутам события</p>
<p>if k[0] != "_": # берутся только неслужебные атрибуты</p>
<p># готовится описание атрибута события</p>
<p>ev = "%15s: %s\n» % (k, repr(getattr(event, k)))</p>
<p>txt.insert(END, ev) # добавляется в конец текста</p>
<p># привязывается виджету txt функция event_info для обработки событий,</p>
<p># соответствующих шаблону &lt;KeyPress&gt;</p>
<p>txt.bind("&lt;KeyPress&gt;", event_info)</p>
<p>tk.mainloop() # главный цикл обработки событий</p>
<p>При нажатии клавиши Esc в окне можно увидеть примерно следующее:</p>
<p>Листинг</p>
<p>char: '\x1b'</p>
<p>delta: 9</p>
<p>height: 0</p>
<p>keycode: 9</p>
<p>keysym: 'Escape'</p>
<p>keysym_num: 65307</p>
<p>num: 9</p>
<p>send_event: False</p>
<p>serial: 159</p>
<p>state: 0</p>
<p>time: — 1072960858</p>
<p>type: '2'</p>
<p>widget: &lt;Tkinter.Text instance at 0x401e268c&gt;</p>
<p>width: 0</p>
<p>x: 83</p>
<p>x_root: 448</p>
<p>y: 44</p>
<p>y_root: 306</p>
<p>Следует объяснить некоторые из этих атрибутов:</p>
<p>char Нажатый символ (для некоторых событий - ??)</p>
<p>height, width Высота и ширина.</p>
<p>focus Был ли в момент события фокус у окна?</p>
<p>keycode Код символа (скан–код клавиатуры).</p>
<p>keysym Символическое имя клавиши.</p>
<p>serial Серийный номер события. Увеличивается по мере возникновения событий.</p>
<p>time Время возникновения события. Все время увеличивается.</p>
<p>widget Виджет, в котором возникло событие.</p>
<p>x, y Координаты указателя в виджете во время события.</p>
<p>x_root, y_root Координаты указателя на экране во время события.</p>
<p>В принципе, совсем необязательно, чтобы события обрабатывал тот же виджет, который их первично
    принял. Например, можно перенаправить все события внутри подчиненных виджетов на данный виджет с
    помощью метода grab_set() (grab_release() освобождает виджет от этой обязанности). В Tk
    существуют и другие возможности управления событиями, которые можно изучить по документации.</p>
<p>Создание и конфигурирование виджета</p>
<p>Создание виджета происходит вызовом конструктора соответствующего класса. Вызов конструктора
    имеет следующий синтаксис:</p>
<p>Листинг</p>
<p>Widget([master[, option=value, …]])</p>
<p>Здесь Widget — класс виджета, master — виджет–хозяин, option и value — конфигурационная опция и
    ее значение (таких пар может быть несколько).</p>
<p>Каждый виджет имеет свойства, которые можно устанавливать (конфигурировать) с помощью методов
    config() (или configure()) и читать с помощью методов, подобных методам работы со словарями.
    Ниже приведен возможный синтаксис для работы со свойствами:</p>
<p>Листинг</p>
<p>widget.config(option=value, …)</p>
<p>widget[«option»] = value</p>
<p>value = widget[«option»]</p>
<p>widget.keys()</p>
<p>В случае, когда имя свойства совпадает с ключевым словом языка Python, принято использовать после
    имени одиночное подчеркивание. Так, свойство class нужно задавать как class_, а to как to_.</p>
<p>Изменять конфигурацию виджета можно в любой момент. Это изменение прорисуется на экране по
    возвращении в цикл обработки событий или при явном вызове update_idletasks().</p>
<p>Следующий пример показывает окно с двумя виджетами внутри — полем ввода и надписью. С помощью
    переменной надпись напрямую связана с полем ввода. Этот пример нарочно использует очень много
    свойств, чтобы продемонстрировать возможности по конфигурированию:</p>
<p>Листинг</p>
<p>from Tkinter import *</p>
<p>tk = Tk()</p>
<p>tv = StringVar()</p>
<p>Label(tk,</p>
<p>textvariable=tv,</p>
<p>relief=«groove»,</p>
<p>borderwidth=3,</p>
<p>font=(«Courier», 20, «bold»),</p>
<p>justify=LEFT,</p>
<p>width=50,</p>
<p>padx=10,</p>
<p>pady=20,</p>
<p>takefocus=False,</p>
<p>).pack()</p>
<p>Entry(tk,</p>
<p>textvariable=tv,</p>
<p>takefocus=True,</p>
<p>).pack()</p>
<p>tv.set(«123»)</p>
<p>tk.mainloop()</p>
<p>В результате на экране можно увидеть:</p>
<p>Виджеты конфигурируются прямо при создании. Более того, виджеты не связываются с именами, их
    только располагают внутри виджета–окна. В данном примере использованы свойства textvariable
    (текстовая переменная), relief (рельеф), borderwidth (ширина границы), justify (выравнивание),
    width (ширина, в знакоместах), padx и pady (прослойка в пикселях между содержимым и границами
    виджета), takefocus (возможность принять фокус при нажатии клавиши Tab), font (шрифт, один из
    способов его задания). Эти свойства достаточно типичны для многих виджетов, хотя иногда единицы
    измерения могут отличаться, например, для виджета Canvas ширина задается в пикселях, а не в
    знакоместах.</p>
<p>В следующем примере демонстрируются возможности по назначению цветов фону, переднему плану
    (тексту), выделению виджета (подсветка границы) в активном состоянии и при отсутствии
    фокуса:</p>
<p>Листинг</p>
<p>from Tkinter import *</p>
<p>tk = Tk()</p>
<p>tv = StringVar()</p>
<p>Entry(tk,</p>
<p>textvariable=tv,</p>
<p>takefocus=True,</p>
<p>borderwidth=10,</p>
<p>).pack()</p>
<p>mycolor1 = "#%02X%02X%02X» % (200, 200, 20)</p>
<p>Entry(tk,</p>
<p>textvariable=tv,</p>
<p>takefocus=True,</p>
<p>borderwidth=10,</p>
<p>foreground=mycolor1, # fg, текст виджета</p>
<p>background="#0000FF», # bg, фон виджета</p>
<p>highlightcolor='green', # подсветка при фокусе</p>
<p>highlightbackground='red', # подсветка без фокуса</p>
<p>).pack()</p>
<p>tv.set(«123»)</p>
<p>tk.mainloop()</p>
<p>При желании можно задать стилевые опции для всех виджетов сразу: с помощью метода
    tk_setPalette(). Помимо использованных выше свойств в этом методе можно использовать
    selectForeground и selectBackground (передний план и фон выделения), selectColor (цвет в
    выбранном состоянии, например, у Checkbutton), insertBackground (цвет точки вставки) и некоторые
    другие.</p>
<p>Примечание:</p>
<p>Получить значение из поля ввода можно и при помощи метода get(). Например, если назвать объект
    класса Entry именем e, получить значение можно так: e.get(). Правда, этот метод не обладает той
    же гибкостью, что метод get() экземпляров класса для форматированного текста Text: можно взять
    только все значение целиком.</p>
<p>Виджет форматированного текста</p>
<p>Для того чтобы показать работу с нетривиальным виджетом, можно взять виджет ScrolledText из
    одноименного модуля Python. Этот виджет аналогичен рамке с форматированным текстом и
    вертикальной полосой прокрутки:</p>
<p>Листинг</p>
<p>from Tkinter import *</p>
<p>from ScrolledText import ScrolledText</p>
<p>tk = Tk() # окно верхнего уровня</p>
<p>txt = ScrolledText(tk) # виджет текста с прокруткой</p>
<p>txt.pack() # виджет размещается</p>
<p>for x in range(1, 1024): # виджет наполняется текстовым содержимым</p>
<p>txt.insert(END, str(2L**x)+»\n»)</p>
<p>tk.mainloop()</p>
<p>Теперь следует рассмотреть методы и свойства виджета с форматированным текстом более
    подробно.</p>
<p>Для навигации в тексте в Tk предусмотрены специальные индексы. Индексы вроде 1.0 и END уже
    встречались — это начало текста (первая строка, нулевой символ) и его конец. (В Tk строки
    нумеруются с единицы, а символы строки — с нуля). Более полный список индексов:</p>
<p>L.C Здесь L — номер строки, а C — номер символа в строке.</p>
<p>INSERT Точка вставки.</p>
<p>CURRENT Символ, ближайший к курсору мыши.</p>
<p>END Позиция сразу за последним символом в тексте</p>
<p>M.first, M.last Индексы начала и конца помеченного тегом M участка текста.</p>
<p>SEL_FIRST, SEL_LAST Индексы начала и конца выделенного текста.</p>
<p>M Пользователь может определять свои именованные позиции в тексте (аналогично END, INSERT или
    CURRENT). При редактировании текста маркеры будут сдвигаться с заданными для них правилами.</p>
<p>@x,y Символ текста, ближайший к точке с координатами x, y.</p>
<p>Следующий пример показывает, как снабдить форматированный текст гипертекстовыми
    возможностями:</p>
<p>Листинг</p>
<p>from Tkinter import *</p>
<p>import urllib</p>
<p>tk = Tk()</p>
<p>txt = Text(tk, width=64) # поле с текстом</p>
<p>txt.grid(row=0, column=0, rowspan=2)</p>
<p>addr=Text(tk, background=«White», width=64, height=1) # поле адреса</p>
<p>addr.grid(row=0, column=1)</p>
<p>page=Text(tk, background=«White», width=64) # поле с html–кодом</p>
<p>page.grid(row=1, column=1)</p>
<p>def fetch_url(event):</p>
<p>click_point = "@%s,%s» % (event.x, event.y)</p>
<p>trs = txt.tag_ranges(«href») # список областей текста, отмеченных как href</p>
<p>url = ""</p>
<p># определяется, на какой участок пришелся щелчок мыши, и берется</p>
<p># соответствующий ему URL</p>
<p>for i in range(0, len(trs), 2):</p>
<p>if txt.compare(trs[i], "&lt;=", click_point) and \</p>
<p>txt.compare(click_point, "&lt;=", trs[i+1]):</p>
<p>url = txt.get(trs[i], trs[i+1])</p>
<p>html_doc = urllib.urlopen(url).read()</p>
<p>addr.delete(«1.0», END)</p>
<p>addr.insert(«1.0», url) # URL помещается в поле адреса</p>
<p>page.delete(«1.0», END)</p>
<p>page.insert(«1.0», html_doc) # показывается HTML–документ</p>
<p>textfrags = [«Python main site: ", «http://www.python.org»,</p>
<p>«\nJython site: ", «http://www.jython.org»,</p>
<p>«\nThat is all!»]</p>
<p>for frag in textfrags:</p>
<p>if frag.startswith(«http:"):</p>
<p>txt.insert(END, frag, «href») # URL помещается в текст с меткой href</p>
<p>else:</p>
<p>txt.insert(END, frag) # фрагмент помещается в текст</p>
<p># ссылки отмечаются подчеркиванием и синим цветом</p>
<p>txt.tag_config(«href», foreground=«Blue», underline=1)</p>
<p># при щелчке мыши на тексте, отмеченном как «href»,</p>
<p># следует вызывать fetch_url()</p>
<p>txt.tag_bind(«href», "&lt;1&gt;", fetch_url)</p>
<p>tk.mainloop() # запускается цикл событий</p>
<p>В результате (после нажатия на гиперссылку) можно увидеть примерно следующее:</p>
<p>Для придания некоторым участкам текста особых свойств необходимо их отметить тегом. В данном
    случае URL отмечается тегом href. Позднее с помощью метода tag_config() задаются свойства
    отображения текста, отмеченного таким тегом. Методом tag_bind() привязывается некоторое событие
    (щелчок мыши) с вызовом заданной функции (fetch_url()).</p>
<p>В самой функции fetch_url()нужно в начале определить, на какой именно участок текста пришелся
    щелчок мыши. Для этого с помощью метода tag_ranges() получаются все интервалы, которые отмечены
    как href. Для определения конкретного URL проводятся сравнения (методом compare()) точки щелчка
    мышью с каждым из интервалов. Так находится интервал, на который попал щелчок, и с помощью
    метода get()получается текстовое значение найденного интервала. Найдя URL, его в поле
    записываются адреса, и получается HTML–код, соответствующий URL.</p>
<p>Этот пример показывает основные принципы работы с форматированным текстом. Примененными методами
    арсенал виджета не исчерпывается. О других методах и свойствах можно узнать из документации.</p>
<p>Менеджеры расположения</p>
<p>Следующий пример достаточно нагляден, чтобы понять принципы работы менеджеров расположения,
    имеющихся в Tk. В трех рамках можно применить различные менеджеры: pack, grid и place:</p>
<p>Листинг</p>
<p>from Tkinter import *</p>
<p>tk = Tk()</p>
<p># Создаем три рамки</p>
<p>frames = {}</p>
<p>b = {}</p>
<p>for fn in 1, 2, 3:</p>
<p>f = Frame(tk, width=100, height=200, bg=«White»)</p>
<p>f.pack(side=LEFT, fill=BOTH)</p>
<p>frames[fn] = f</p>
<p>for bn in 1, 2, 3, 4: # Создаются кнопки для каждой из рамок</p>
<p>b[fn, bn] = Button(frames[fn], text="%s.%s» % (fn, bn))</p>
<p># Первая рамка:</p>
<p># Сначала две кнопки прикрепляются к левому краю</p>
<p>b[1, 1].pack(side=LEFT, fill=BOTH, expand=1)</p>
<p>b[1, 2].pack(side=LEFT, fill=BOTH, expand=1)</p>
<p># Еще две — к нижнему</p>
<p>b[1, 3].pack(side=BOTTOM, fill=Y)</p>
<p>b[1, 4].pack(side=BOTTOM, fill=BOTH)</p>
<p># Вторая рамка:</p>
<p># Две кнопки сверху</p>
<p>b[2, 1].grid(row=0, column=0, sticky=NW+SE)</p>
<p>b[2, 2].grid(row=0, column=1, sticky=NW+SE)</p>
<p># и одна на две колонки в низу</p>
<p>b[2, 3].grid(row=1, column=0, columnspan=2, sticky=NW+SE)</p>
<p># Третья рамка:</p>
<p># Кнопки высотой и шириной в 40% рамки, якорь в левом верхнем углу.</p>
<p># Координаты якоря 1/10 от ширины и высоты рамки</p>
<p>b[3, 1].place(relx=0.1, rely=0.1, relwidth=0.4, relheight=0.4, anchor=NW)</p>
<p># Кнопка строго по центру. Якорь в центре кнопки</p>
<p>b[3, 2].place(relx=0.5, rely=0.5, relwidth=0.4, relheight=0.4, anchor=CENTER)</p>
<p># Якорь по центру кнопки. Координаты якоря 9/10 от ширины и высоты рамки</p>
<p>b[3, 3].place(relx=0.9, rely=0.9, relwidth=0.4, relheight=0.4, anchor=CENTER)</p>
<p>tk.mainloop()</p>
<p>Результат следующий:</p>
<p>Менеджер pack просто заполняет внутреннее пространство на основании предпочтения того или иного
    края, необходимости заполнить все измерение. В некоторых случаях ему приходится менять размеры
    подчиненных виджетов. Этот менеджер стоит использовать только для достаточно простых схем
    расположения виджетов.</p>
<p>Менеджер grid помещает виджеты в клетки сетки (это очень похоже на способ верстки таблиц в HTML).
    Каждому располагаемому виджету даются координаты в одной из ячеек сетки (row — строка, column —
    столбец), а также, если нужно, столько последующих ячеек (в строках ниже или в столбцах правее)
    сколько он может занять (свойства rowspan или columnspan). Это самый гибкий из всех
    менеджеров.</p>
<p>Менеджер place позволяет располагать виджеты по произвольным координатам и с произвольными
    размерами подчиненных виджетов. Размеры и координаты могут быть заданы в долях от размера
    виджета–хозяина.</p>
<p>Непосредственно внутри одного виджета нельзя использовать более одного менеджера расположения:
    менеджеры могут наложить противоречащие ограничения на вложенные виджеты и внутренние виджеты
    просто не смогут быть расположены.</p>
<p>Изображения в Tkinter</p>
<p>Средствами Tkinter можно выводить не только текст, примитивные формы (с помощью виджета Canvas),
    но и растровые изображения. Следующий пример демонстрирует вывод иконки с растровым изображением
    (для этого примера нужно предварительно установить пакет Python Imaging Library, PIL):</p>
<p>Листинг</p>
<p>import Tkinter, Image, ImageTk</p>
<p>FILENAME = «lena.jpg» # файл с графическим изображением</p>
<p>tk = Tkinter.Tk()</p>
<p>c = Tkinter.Canvas(tk, width=128, height=128)</p>
<p>src_img = Image.open(FILENAME)</p>
<p>img = ImageTk.PhotoImage(src_img)</p>
<p>c.create_image(0, 0, image=img, anchor=«nw»)</p>
<p>c.pack()</p>
<p>Tkinter.Label(tk, text=FILENAME).pack()</p>
<p>tk.mainloop()</p>
<p>В результате получается:</p>
<p>Здесь использован виджет–рисунок (Canvas). С помощью функций из пакетов Image и ImageTk из PIL
    получается объект–изображение, подходящее для включения в рисунок Tkinter. Свойство anchor
    задает угол, который привязывается к координатам (0, 0) в рисунке. В данном примере это
    северо–западный угол (NW — North–West). Другие возможности: n (север), w (запад), s (юг), e
    (восток), ne, sw, se и с (центр).</p>
<p>В следующем примере показаны графические примитивы, которые можно использовать на рисунке
    (приведенные комментарии объясняют свойства графических объектов внутри виджета–рисунка):</p>
<p>Листинг</p>
<p>from Tkinter import *</p>
<p>tk = Tk()</p>
<p># Рисунок 300x300 пикселей, фон — белый</p>
<p>c = Canvas(tk, width=300, height=300, bg=«white»)</p>
<p>c.create_arc((5, 5, 50, 50), style=PIESLICE) # Сектор («кусок пирога»)</p>
<p>c.create_arc((55, 5, 100, 50), style=ARC) # Дуга</p>
<p>c.create_arc((105, 5, 150, 50), style=CHORD, # Сегмент</p>
<p>start=0, extent=150, fill=«blue») # от 0 до 150 градусов</p>
<p># Ломаная со стрелкой на конце</p>
<p>c.create_line([(5, 55), (55, 55), (30, 95)], arrow=LAST)</p>
<p># Кривая (сглаженная ломаная)</p>
<p>c.create_line([(105, 55), (155, 55), (130, 95)], smooth=1)</p>
<p># Многоугольник зеленого цвета</p>
<p>c.create_polygon([(205, 55), (255, 55), (230, 95)], fill=«green»)</p>
<p># Овал</p>
<p>c.create_oval((5, 105, 50, 120), )</p>
<p># Прямоугольник красного цвета с большой серой границей</p>
<p>c.create_rectangle((105, 105, 150, 130), fill=«red»,</p>
<p>outline=«grey», width=«5»)</p>
<p># Текст</p>
<p>c.create_text((5, 205), text=" Hello», anchor=«nw»)</p>
<p># Эта точка визуально обозначает угол привязки</p>
<p>c.create_oval((5, 205, 6, 206), outline=«red»)</p>
<p># Текст с заданным выравниванием</p>
<p>c.create_text((105, 205), text=«Hello,\nmy friend!»,</p>
<p>justify=LEFT, anchor=«c»)</p>
<p>c.create_oval((105, 205, 106, 206), outline=«red»)</p>
<p># Еще один вариант</p>
<p>c.create_text((205, 205), text=«Hello,\nmy friend!»,</p>
<p>justify=CENTER, anchor=«se»)</p>
<p>c.create_oval((205, 205, 206, 206), outline=«red»)</p>
<p>c.pack()</p>
<p>tk.mainloop()</p>
<p>В результате работы этой программы на экране появится окно:</p>
<p>Следует заметить, что методы create_* создают объекты, свойства которых можно менять в
    дальнейшем: переместить в другое место, перекрасить, удалить, изменить порядок и т.д. В
    следующем примере можно нарисовать кружок, меняющий цвет по щелчку мыши:</p>
<p>Листинг</p>
<p>from Tkinter import *</p>
<p>from random import choice</p>
<p>colors = «Red Orange Yellow Green LightBlue Blue Violet».split()</p>
<p>R = 10</p>
<p>tk = Tk()</p>
<p>c = Canvas(tk, bg=«White», width=«4i», height=300, relief=SUNKEN)</p>
<p>c.pack(expand=1, fill=BOTH)</p>
<p>def change_ball(event):</p>
<p>c.coords(CURRENT, (event.x–R, event.y–R, event.x+R, event.y+R))</p>
<p>c.itemconfigure(CURRENT, fill=choice(colors))</p>
<p>oval = c.create_oval((100–R, 100–R, 100+R, 100+R), fill=«Black»)</p>
<p>c.tag_bind(oval, "&lt;1&gt;", change_ball)</p>
<p>tk.mainloop()</p>
<p>Здесь нарисован кружок радиуса R , с ним связана функция change_ball() по нажатию кнопки мыши. В
    указанной функции заданы новые координаты кружка (его центр расположен в месте щелчка мыши) и
    затем изменен цвет случайным образом методом itemconfigure(). Тег CURRENT в Tkinter использован
    для указания объекта, который принял событие.</p>
<p>Графическое приложение на Tkinter</p>
<p>Теперь следует рассмотреть небольшое приложение, написанное с использованием Tkinter. В этом
    приложении будет загружен файл с графическим изображением. Приложение будет иметь простейшее
    меню File с пунктами Open и Exit, а также виджет Canvas, на котором и будут демонстрироваться
    изображения (опять потребуется пакет PIL):</p>
<p>Листинг</p>
<p>from Tkinter import *</p>
<p>import Image, ImageTk, tkFileDialog</p>
<p>global img, imgobj</p>
<p>def show():</p>
<p>global img, imgobj</p>
<p># Запрос на имя файла</p>
<p>filename = tkFileDialog.askopenfilename()</p>
<p>if filename != (): # Если имя файла было задано пользователем</p>
<p># рисуется изображение из файла</p>
<p>src_img = Image.open(filename)</p>
<p>img = ImageTk.PhotoImage(src_img)</p>
<p># конфигурируется изображение на рисунке</p>
<p>c.itemconfigure(imgobj, image=img, anchor=«nw»)</p>
<p>tk = Tk()</p>
<p>main_menu = Menu(tk) # формируется меню</p>
<p>tk.config(menu=main_menu) # меню добавляется к окну</p>
<p>file_menu = Menu(main_menu) # создается подменю</p>
<p>main_menu.add_cascade(label=«File», menu=file_menu)</p>
<p># Заполняется меню File</p>
<p>file_menu.add_command(label=«Open», command=show)</p>
<p>file_menu.add_separator() # черта для отделения пунктов меню</p>
<p>file_menu.add_command(label=«Exit», command=tk.destroy)</p>
<p>c = Canvas(tk, width=300, height=300, bg=«white»)</p>
<p># готовим объект–изображение на рисунке</p>
<p>imgobj = c.create_image(0, 0)</p>
<p>c.pack()</p>
<p>tk.mainloop()</p>
<p>Приложение (с загруженной картинкой) будет выглядеть так:</p>
<p>Стоит отметить, что здесь пришлось применить две глобальные переменные. Это не очень хорошо.
    Существует другой подход, когда приложение создается на основе окна верхнего уровня. Таким
    образом, само приложение становится особым виджетом. Переделанная программа представлена
    ниже:</p>
<p>Листинг</p>
<p>from Tkinter import *</p>
<p>import Image, ImageTk, tkFileDialog</p>
<p>class App(Tk):</p>
<p>def __init__(self):</p>
<p>Tk.__init__(self)</p>
<p>main_menu = Menu(self)</p>
<p>self.config(menu=main_menu)</p>
<p>file_menu = Menu(main_menu)</p>
<p>main_menu.add_cascade(label=«File», menu=file_menu)</p>
<p>file_menu.add_command(label=«Open», command=self.show_img)</p>
<p>file_menu.add_separator()</p>
<p>file_menu.add_command(label=«Exit», command=self.destroy)</p>
<p>self.c = Canvas(self, width=300, height=300, bg=«white»)</p>
<p>self.imgobj = self.c.create_image(0, 0)</p>
<p>self.c.pack()</p>
<p>def show_img(self):</p>
<p>filename = tkFileDialog.askopenfilename()</p>
<p>if filename != ():</p>
<p>src_img = Image.open(filename)</p>
<p>self.img = ImageTk.PhotoImage(src_img)</p>
<p>self.c.itemconfigure(self.imgobj, image=self.img, anchor=«nw»)</p>
<p>app = App()</p>
<p>app.mainloop()</p>
<p>В объекте заключена информация, которая до этого была глобальной со всеми следующими из этого
    ограничениями. Можно пойти дальше и выделить в отдельный метод настройку меню (если приложение
    будет динамически изменять меню, объекты–меню тоже могут быть сохранены в приложении).</p>
<p>Примечание:</p>
<p>На некоторых системах новые версии Python плохо работают с национальными кодировками, в
    частности, с кодировками для кириллицы. Это связано с переходом на Unicode Tcl/Tk. Проблем можно
    избежать, если использовать кодировку UTF–8 в строках, которые должны выводиться в виджетах.</p>
<p>Заключение</p>
<p>В этой лекции было дано представление о (невизуальном) программировании графического интерфейса
    для Python на примере пакета Tkinter. Программа с графическим интерфейсом —
    событийно–управляемая программа, проводящая время в цикле обработки событий. События могут быть
    вызваны функционированием графического интерфейса или другими причинами (например, по таймеру).
    Обычно события возникают в виджетах и некоторые из них должны обрабатываться приложением. В
    Tkinter событие представлено отдельным объектом, из атрибутов которого можно установить, каково
    было положение указателя (курсора мыши), в каком виджете произошло событие и т.п.</p>
<p>Здесь были рассмотрены классы элементов интерфейса (виджеты), их свойства и методы. Виджеты имеют
    большое количество свойств и методов. Некоторые свойства и методы достаточно универсальны (их
    имеют все или почти все виджеты), другие же специфичны для конкретного класса виджетов.
    Графический пакет Python Imaging Library (PIL) предоставляет класс объекта для расположения в
    виджете–рисунке растрового графического изображения.</p>
<p>Виджеты располагаются внутри другого виджета (например, рамки) в соответствии с набором правил.
    Этот набор правил реализуют менеджеры расположения, которых в Tkinter три: pack, grid и
    place.</p>
<p>Приложение с графическим интерфейсом можно построить на базе окна верхнего уровня, простым
    наследованием. Этот подход позволяет инкапсулировать информацию, которую в противном случае
    пришлось бы делать глобальной.</p>
<p>Нужно отметить, что для построения интерфейса можно использовать не только чистый Tkinter.
    Например, в Python доступны модули ScrolledText и Tix, пополняющие набор виджетов. Кроме того,
    можно найти пакеты для специальных виджетов (например, для отображения дерева).</p>
<p>Построение графического интерфейса невизуальными способами — не такая сложная задача, если
    использовать Tkinter. Этот пакет входит в стандартную поставку Python и потому может
    использоваться почти везде, где установлен Python.</p>
<center>
    <div align="center"></div>
</center>

</body>
</html>
