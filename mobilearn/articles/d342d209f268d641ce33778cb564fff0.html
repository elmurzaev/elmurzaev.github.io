<!DOCTYPE html>
<html>
<head>

    <title>Лекция 2. Основы объектно-ориентированного программирования</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<div class="left">
    <p></p>
    <p></p>
    <center><h2>Лекция
        2. Основы объектно-ориентированного программирования</h2></center>
    <p>
    </p>
    <p>
    </p>
    <p>В этой лекции излагается основная концепция
        объектно-ориентирован­ного подхода (ООП) к проектированию программного
        обеспечения. Поскольку в Java почти все типы (за
        исключением восьми простейших) являются объектны­ми, владение ООП становится
        необходимым условием для успешного примене­ния языка. Лекция имеет вводный,
        обзорный характер. Для более детального изучения предлагается список
        дополнительной литературы и Internet-ресурсов.
    </p>
    <p>
    </p>
    <p>Ключевые слова: блок-схема, объектно-ориентированное програм­мирование, ООП, объект,
        состояние, поведение, уникальность, класс, UML, конструктор,
        деструктор, инкапсуляция, модульность, наследование, класс-предок, суперкласс,
        класс-потомок, подкласс, полиморфизм, перегруженная функция, перегрузка,
        ассоциация, метакласс.
    </p>
    <p>
    </p>
    <p>Методология
        процедурно-ориентированного программирования
    </p>
    <p>Появление первых электронных вычислительных машин, или
        компью­теров, ознаменовало новый этап в развитии техники вычислений. Казалось,
        достаточно разработать последовательность элементарных действий, каж­дое из
        которых можно преобразовать в понятные компьютеру инструкции, и любая
        вычислительная задача будет решена. Эта идея оказалась настоль­ко
        жизнеспособной, что долгое время доминировала над всем процессом разработки
        программ. Появились специализированные языки программи­рования, созданные для
        разработки программ, предназначенных для ре­шения вычислительных задач.
        Примерами таких языков могут служить FOCAL (FOrmula CALculator) и FORTRAN
        (FORmula TRANslator).
    </p>
    <p>Основой такой методологии разработки программ являлась
        проце­дурная, или алгоритмическая, организация структуры программного ко­да.
        Это было настолько естественно для решения вычислительных задач, То
        целесообразность такого подхода ни у кого не вызывала сомнений. Исходным в
        данной методологии было понятие алгоритма. Алгоритм — ^o способ решения вычислительных и
        других задач, точно описываю­щий
        определенную последовательность действий, которые необходимо выполнить для
        достижения заданной цели. Примерами алгоритмов явля­ется хорошо известные
        правила нахождения корней квадратного уравне­ния или линейной системы
        уравнений.
    </p>
    <p>
    </p>
    <table cellpadding="0" cellspacing="0">
        <tr>
            <td height="0" width="481"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <center><img height="457" src="http://kufas.ru/java.files/image005.png" width="452">
                </center>
            </td>
        </tr>
    </table>
    При увеличении объемов программ для упрощения их
    разработки по­явилась необходимость разбивать большие задачи на подзадачи
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> В языках программирования возникло и закрепилось новое понятие процедуры.
        Ис­пользование процедур позволило разбивать большие задачи на подзадачи и таким
        образом упростило написание больших программ. Кроме того, про­цедурный подход
        позволил уменьшить объем программного кода за счет написания часто используемых
        кусков кода в виде процедур и их примене­ния в различных частях программы.
    </p>
    <p>Как и алгоритм, процедура представляет собой законченную последо­вательность
        действий или операций, направленных на решение отдельной задачи. В языках программирования
        появилась специальная синтаксичес­кая
        конструкция, которая также получила название процедуры. Например, на языке Pascal описание
        процедуры
        выглядит следующим образом:
    </p>
    <p>
    </p>
    <p>Procedure printGreeting(name: String) Begin
    </p>
    <p>Print("Hello,
        ");
    </p>
    <p>PrintLn(s); End;
    </p>
    <p>Назначение данной процедуры — вывести на экран приветствие Hello, Name, где Name передается в
        процедуру в качестве входного параметра.
    </p>
    <p>Со временем
        вычислительные задачи становились все сложнее, а зна­чит, и решающие их
        программы увеличивались в размерах. Их разработка превратилась в серьезную
        проблему. Когда программа становится все боль­ше, ее приходится разделять на
        все более мелкие фрагменты. Основой для такого разбиения как раз и стала
        процедурная декомпозиция, при которой отдельные части программы, или модули,
        представляли собой совокупность процедур для решения одной или нескольких
        задач. Одна из основных осо­бенностей процедурного программирования заключается
        в том, что оно позволило создавать библиотеки подпрограмм (процедур), которые
        можно было бы использовать повторно в различных проектах или в рамках одного
        проекта. При процедурном подходе для визуального представления алгорит­ма
        выполнения программы применяется так называемая блок-схема. Соот­ветствующая
        система графических обозначений была зафиксирована в ГОСТ 19.701-90. Пример
        блок-схемы изображен на рисунке (рис. 2.1).
    </p>
    <p>Появление и интенсивное использование условных операторов и опе­ратора
        безусловного перехода стало предметом острых дискуссий среди специалистов по
        программированию. Дело в том, что бесконтрольное при­менение в программе
        оператора безусловного перехода goto может замет­но осложнить понимание кода. Такие
        запутанные
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>программы
        сравнивали с порцией спагетти (bowl of
        spaghetti), имея в виду многочисленные
        перехо­да от одного фрагмента программы к другому, или, что еще
        хуже, возврат % конечных операторов программы к начальным. Ситуация
        казалась на-ТОМгько драматичной, что многие предлагали исключить оператор goto из языков
        программирования. Именно с
        этого времени отсутствие безуслов­ных переходов стали считать хорошим стилем
        программирования.
    </p>
    <p>Дальнейшее увеличение программных систем способствовало фор­мированию
        новой точки зрения на процесс разработки программ и нали­чия программных кодов, которая
        получила название методологии структурного
        программирования. Ее основой является процедурная де­композиция предметной
        области решаемой задачи и организация отдель­ных модулей в виде совокупности процедур. В
        рамках этой методологии п°лучило развитие нисходящее проектирование программ, или
        проекти­рование
        "сверху вниз". Пик популярности идей структурного программи­рования
        приходится на конец 70-х — начало 80-х годов.
    </p>
    <p>В этот период основным показателем сложности разработки программ
        считался ее размер. Вполне серьезно обсуждались такие оценки сложности
        программ, как количество строк программного кода. Правда, при этом дела­лись
        некоторые предположения относительно синтаксиса самих строк, ко­торые должны
        были соответствовать определенным требованиям. Напри­мер, каждая строка кода
        должна была содержать не более одного оператора. Общая трудоемкость разработки
        программ оценивалась специальной едини­цей измерения —
        "человеко-месяц", или "человеко-год". А профессионализм
        программиста напрямую связывался с количеством строк программного ко­да,
        который он мог написать и отладить в течение, скажем, месяца.
    </p>
    <p>
    </p>
    <p>Методология объектно-ориентированного программирования
    </p>
    <p>Увеличение размеров программ приводило к необходимости привле­чения
        большего числа программистов, что, в свою очередь, потребовало дополнительных
        ресурсов для организации их согласованной работы. В пронессе разработки
        приложений заказчик зачастую изменял функцио­нальные требования, что еще более
        усложняло процесс создания про­граммного обеспечения.
    </p>
    <p>Но не менее важными оказались качественные изменения, связан­ные со
        смещением акцента использования компьютеров
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> В эпоху "боль­ших машин"
        основными потребителями программного обеспечения были такие крупные заказчики,
        как большие производственные предприятия, финансовые компании, государственные
        учреждения. Стоимость таких вычислительных устройств для небольших предприятий
        и организаций была слишком высока.
    </p>
    <p>Позже появились персональные компьютеры, которые имели гораз­до меньшую
        стоимость и были значительно компактнее. Это позволило широко использовать их в
        малом и среднем бизнесе. Основными задачами в этой области являются обработка
        данных и манипулирование ими, по­этому вычислительные и
        расчетно-алгоритмические задачи с появлением персональных компьютеров отошли на
        второй план.
    </p>
    <p>Как показала практика, традиционные методы процедурного про­граммирования
        не способны справиться ни с нарастающей сложностью программ и их разработки, ни
        с необходимостью повышения их надежно­сти. Во второй половине 80-х годов
        возникла настоятельная потребность в новой методологии программирования,
        которая была бы способна ре­шить весь этот комплекс проблем. Ею стало
        объектно-ориентированное программирование (ООП).
    </p>
    <p>После составления технического задания начинается этап проекти­рования,
        или дизайна, будущей системы. Объектно-ориентированный подход к проектированию
        основан на представлении предметной области задачи в виде множества моделей для
        независимой от языка разработки программной системы на основе ее прагматики.
    </p>
    <p>Последний термин нуждается в пояснении. Прагматика определяется целью
        разработки программной системы, например, обслуживание клиен-» тов банка,
        управление работой аэропорта, обслуживание чемпионата мира t, по футболу и т.п. В
        формулировке цели участвуют предметы и понятия ре­ального
        мира, имеющие отношение к создаваемой системе (см. рисунок 2.2 f |3]). При
        объектно-ориентированном подходе эти предметы и понятия за­меняются
        моделями, т.е. определенными формальными конструкциями.
    </p>
    <p></p>
    <center><img border="0" height="215" src="http://kufas.ru/java.files/image006.jpg" width="444">
    </center>
    <p>
    </p>
    <p>Рис. 2.2. Семантика (смысл программы с точки зрения выполняю­щего ее компьютера) и
        прагматика (смысл программы с точки зре­ния ее пользователей) [3].
    </p>
    <p>Модель содержит не все
        признаки и свойства представляемого ею едмета или понятия, а только те, которые
        существенны для разрабаты-емой программной системы. Таким образом, модель
        "беднее", а следо-|тельно, проще представляемого ею предмета или
        понятия.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Простота модели по
        отношению к реальному предмету позволяет делать ее формальной. Благодаря такому
        характеру моделей при разра-гке можно четко выделить все зависимости и операции
        над ними в со-
    </p>
    <table cellpadding="0" cellspacing="0" hspace="0" vspace="0">
        <tr>
            <td align="left" valign="top">
                <p>^
                </p>
            </td>
        </tr>
    </table>
    <p>аваемой программной
        системе. Это упрощает как разработку и изучение „ Кализ) моделей, так и их
        реализацию на компьютере.
    </p>
    <p>Объектно-ориентированный подход помогает справиться с такими проблемами,
        как:
    </p>
    <p>•
        уменьшение сложности
        программного обеспечения;
    </p>
    <p>•
        повышение надежности
        программного обеспечения;
    </p>
    <p>• обеспечение возможности модификации отдельных компонентов программного
        обеспечения без изменения остальных его компо­нентов;
    </p>
    <p>• обеспечение возможности повторного использования отдельных компонентов
        программного обеспечения.
    </p>
    <p>Более детально преимущества и недостатки объектно-ориентирован­ного
        программирования будут рассмотрены в конце лекции, так как для их понимания
        необходимо знание основных понятий и положений ООП.
    </p>
    <p>Систематическое применение объектно-ориентированного подхода позволяет
        разрабатывать хорошо структурированные, надежные в экс­плуатации, достаточно
        просто модифицируемые программные системы. Этим объясняется интерес
        программистов к объектно-ориентированному подходу и объектно-ориентированным
        языкам программирования. ООП является одним из наиболее интенсивно развивающихся
        направлений теоретического и прикладного программирования.
    </p>
    <p>
    </p>
    <p>Объекты
    </p>
    <p>По определению будем называть объектом понятие, абстракцию или любой
        предмет с четко очерченными границами, имеющий смысл в контексте
        рассматриваемой прикладной проблемы. Введение объектов преследует две цели:
    </p>
    <p>•
        понимание прикладной
        задачи (проблемы);
    </p>
    <p>•
        введение основы для
        реализации на компьютере.
    </p>
    <p>Примеры объектов:
        форточка, Банк "Империал", Петр Сидоров, дело № 7461, сберкнижка и
        т.д.
    </p>
    <p>Каждый объект имеет определенное время жизни. В процессе выпол­нения
        программы, или функционирования какой-либо реальной систе­мы, могут создаваться
        новые объекты и уничтожаться уже существующие.
    </p>
    <p>Гради Буч дает следующее
        определение объекта:
    </p>
    <p>Объект — это мыслимая или реальная сущность, обладающая харак­терным
        поведением и отличительными характеристиками и являющаяся важной в предметной
        области [2].
    </p>
    <p>Каждый объект имеет состояние, обладает четко определенным пове­дением и
        уникальной идентичностью.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>Состояние
    </p>
    <p>Рассмотрим пример. Любой человек может находиться в некотором положении
        (состоянии): стоять, сидеть, лежать, и — в то же время совер­шать какие либо
        действия.
    </p>
    <p>Например, человек может прыгать, если он стоит, и не может — если он
        лежит, для этого ему потребуется сначала встать. Также в объектно­ориентированном
        программировании состояние объекта может опреде­ляться наличием или отсутствием
        связей между моделируемым объектом и другими объектами. Более подробно все
        возможные связи между объек­тами будут рассмотрены в разделе "Типы
        отношений между классами".
    </p>
    <p>Например, если у человека есть удочка (у него есть связь с объектом
        "Удочка"), он может ловить рыбу, а если удочки нет, то такое действие
        не­возможно. Из этих примеров видно, что набор действий, которые может
        совершать человек, зависит от параметров объекта, его моделирующего.
    </p>
    <p>Для рассмотренных выше примеров такими характеристиками, или атрибутами,
        объекта "Человек" являются:
    </p>
    <p>•
        текущее положение человека
        (стоит, сидит, лежит);
    </p>
    <p>•
        наличие удочки (есть или
        нет).
    </p>
    <p>В конкретной задаче могут появиться и другие свойства, например,
        физическое состояние, здоровье (больной человек обычно не прыгает).
    </p>
    <p>Состояние (state) - совокупный результат поведения объекта: одно из стабильных условий,
        в которых объект может существовать, охаракте­ризованных количественно; в любой
        момент времени состояние объекта включает в себя перечень (обычно статический)
        свойств объекта и теку­щие значения (обычно динамические) этих свойств [2].
    </p>
    <p>
    </p>
    <p>Поведение
    </p>
    <p>Для каждого объекта существует определенный набор действий, которые с
        ним можно произвести. Например, возможные действия с некоторым файлом
        операционной системы ПК:
    </p>
    <p>•
        создать;
    </p>
    <p>•
        открыть;
    </p>
    <p>•
        читать из файла;
    </p>
    <p>•
        писать в файл;
    </p>
    <p>•
        закрыть;
    </p>
    <p>•
        удалить.
    </p>
    <p>Результат выполнения действий зависит от состояния объекта на мо­мент
        совершения действия, т.е. нельзя, например, удалить файл, если он открыт
        кем-либо (заблокирован). В то же время действия могут менять внутреннее
        состояние объекта - при открытии или закрытии файла свой­ство
        "открыт" принимает значения "да" или "нет",
        соответственно.
    </p>
    <p>Программа, написанная с использованием ООП, обычно состоит из Множества
        объектов, и все эти объекты взаимодействуют между собой, обычно говорят, что
        взаимодействие между объектами в программе про­исходит посредством передачи
        сообщений между ними.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>^ В терминологии
        объектно-ориентированного подхода понятия "дейст­ве ,
        "сообщение" и "метод" являются синонимами. Т.е. выражения
        "выпол­нить действие над объектом", "вызвать метод объекта"
        и "послать сообщение объекту для выполнения какого-либо действия"
        эквивалентны. Последняя фраза появилась из следующей модели. Программу,
        построенную по техно­логии ООП, можно представить себе как виртуальное
        пространство, запол­ненное объектами, которые условно "живут"
        некоторой жизнью. Их актив­ность проявляется в том, что они вызывают друг у
        друга методы, или посы­лают друг другу сообщения. Внешний интерфейс объекта,
        или набор его ме­тодов,— это описание того, какие сообщения он может принимать.
    </p>
    <p>Поведение (behavior) — действия и реакции объекта, выраженные в терминах передачи
        сообщений и изменения состояния; видимая извне и воспроизводимая активность
        объекта [2].
    </p>
    <p>
    </p>
    <p>Уникальность
    </p>
    <p>Уникальность - это то, что отличает объект от других объектов. На­пример,
        у вас может быть несколько одинаковых монет. Даже если абсо­лютно все их
        свойства (атрибуты) одинаковы (год выпуска, номинал и т.д.) и при этом вы
        можете использовать их независимо друг от друга, они по-прежнему остаются
        разными монетами.
    </p>
    <p>В машинном
        представлении под параметром уникальности объекта чаще всего понимается адрес
        размещения объекта в памяти.
    </p>
    <p>Identity (уникальность)
        объекта состоит в том, что всегда можно оп­ределить, указывают две ссылки на
        один и тот же объект или на разные объекты. При этом два объекта могут во всем
        быть похожими, их образ в памяти может представляться одинаковыми последовательностями
        бай­тов,
        но, тем не менее, их Identity может быть
        различна.
    </p>
    <p>Наиболее распространенной ошибкой является понимание уни­кальности как
        имени ссылки на объект. Это неверно, т.к. на один объект может указывать
        несколько ссылок, и ссылки могут менять свои значения (ссылаться на другие
        объекты).
    </p>
    <p>Итак, уникальность (identity) - свойство
        объекта; то, что отличает его от других объектов (автор не согласен с переводом
        русского издания [2], поэтому здесь приводится авторский перевод).
    </p>
    <p>
    </p>
    <p>Классы
    </p>
    <p>Все монеты из предыдущего примера принадлежат одному и тому же классу
        объектов (именно с этим связана их одинаковость)
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Номинальная стоимость монеты,
        металл, из которого она изготовлена, форма - это ат­рибуты класса. Совокупность
        атрибутов и их значений характеризует объ­ект. Наряду с термином
        "атрибут" часто используют термины "свойство" и
        "поле", которые в объектно-ориентированном программировании явля­ются
        синонимами.
    </p>
    <p>Все объекты одного и того же класса описываются одинаковыми на­борами
        атрибутов. Однако объединение объектов в классы определяется не наборами
        атрибутов, а семантикой. Так, например, объекты "конюш­ня" и
        "лошадь" могут иметь одинаковые атрибуты: цена и возраст. При этом
        они могут относиться к одному классу, если рассматриваются в зада­че просто как
        товар, либо к разным классам, если в рамках поставленной задачи будут
        использоваться по-разному, т.е. над ними будут совершаться различные действия.
    </p>
    <p>Объединение объектов в классы позволяет рассмотреть задачу в бо­лее
        общей постановке. Класс имеет имя (например, "лошадь"), которое относится
        ко всем объектам этого класса. Кроме того, в классе вводятся имена атрибутов,
        которые определены для объектов. В этом смысле опи­сание класса аналогично
        описанию типа структуры или записи (record), широко
        применяющихся в процедурном программировании; при этом каждый объект имеет тот
        же смысл, что и экземпляр структуры (перемен­ная или константа соответствующего
        типа).
    </p>
    <p>Формально класс - это шаблон поведения объектов определенного типа с
        заданными параметрами, определяющими состояние. Все экземп­ляры одного класса
        (объекты, порожденные от одного класса) имеют один и тот же набор свойств и
        общее поведение, то есть одинаково реаги­руют на одинаковые сообщения
    </p>
    <p></p>
    <center><img border="0" height="122" src="http://kufas.ru/java.files/image007.jpg" width="132">
    </center>
    <p>^ В соответствии с UML (Unified Modeling Language - унифицирован­ный
        язык моделирования), класс имеет следующее графическое представ­ление.
    </p>
    <p>Класс изображается в виде прямоугольника, состоящего из трех час­тей. В
        верхней части помещается название класса, в средней - свойства объектов класса,
        в нижней - действия, которые можно выполнять с объ­ектами данного класса
        (методы).
    </p>
    <p>Каждый класс также может иметь специальные методы, которые ав­томатически
        вызываются при создании и уничтожении объектов этого Класса:
    </p>
    <p>•
        конструктор (constructor) - выполняется при создании объектов;
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>•
        деструктор (destructor) - выполняется при уничтожении объектов.
    </p>
    <p>Обычно конструктор и деструктор имеют специальный синтаксис, который
        может отличаться от синтаксиса, используемого для написания обычных методов
        класса.
    </p>
    <p>
    </p>
    <p>Инкапсуляция
    </p>
    <p>Инкапсуляция (encapsulation) — это сокрытие реализации класса и отделение его внутреннего
        представления от внешнего (интерфейса). При использовании
        объектно-ориентированного подхода не принято применять прямой доступ к
        свойствам какого-либо класса из методов других классов. Для доступа к свойствам
        класса принято задействовать специальные методы этого класса для получения и
        изменения его свойств.
    </p>
    <p>Внутри объекта данные и методы могут обладать различной степенью
        открытости (или доступности). Степени доступности, принятые в языке Java, подробно будут
        рассмотрены лекции 6. Они позволяют более тонко управлять свойством
        инкапсуляции.
    </p>
    <p>Открытые члены класса составляют внешний интерфейс объекта. Это та
        функциональность, которая доступна другим классам. Закрытыми обычно объявляются
        все свойства класса, а также вспомогательные методы, которые являются деталями
        реализации и от которых не должны зависеть другие части системы.
    </p>
    <p>Благодаря сокрытию реализации за внешним интерфейсом класса можно менять
        внутреннюю логику отдельного класса, не меняя код осталь­ных компонентов
        системы. Это свойство называется модульность.
    </p>
    <p>Обеспечение доступа к свойствам класса только через его методы так­же
        дает ряд преимуществ. Во-первых, так гораздо проще контролировать корректные
        значения полей, ведь прямое обращение к свойствам отслежи­вать невозможно, а
        значит, им могут присвоить некорректные значения.
    </p>
    <p>Во-вторых, не
        составит труда изменить способ хранения данных. Ес­ли информация станет
        храниться не в памяти, а в долговременном храни­лище, таком как файловая
        система или база данных, потребуется изменить лишь ряд методов одного класса, а
        не вводить эту функциональность во все части системы.
    </p>
    <p>Наконец, программный код, написанный с использованием данно­го принципа,
        легче отлаживать. Для того, чтобы узнать, кто и когда изме­нил свойство
        интересующего нас объекта, достаточно добавить вывод от­ладочной информации в
        тот метод объекта, посредством которого осуще­ствляется доступ к свойству этого
        объекта. При использовании прямого до­ступа к свойствам объектов программисту
        пришлось бы добавлять вывод отладочной информации во все участки кода, где
        используется интересую­щий нас объект.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Наследование
    </p>
    <p>Наследование (inheritance) — это отношение между классами, при ко­тором класс использует
        структуру или поведение другого класса (одиноч­ное наследование), или других (множественное
        наследование) классов. Наследование вводит иерархию "общее/частное", в которой подкласс
        на­следует от одного или нескольких более общих суперклассов. Подклассы обычно дополняют или
        переопределяют унаследованную структуру и по­ведение.
    </p>
    <p>В качестве примера можно рассмотреть задачу, в которой необходи­мо
        реализовать классы "Легковой автомобиль" и "Грузовой
        автомобиль". Очевидно, эти два класса имеют общую функциональность. Так, оба они имеют 4
        колеса, двигатель, могут перемещаться и т.д. Всеми этими
        свой-ствами обладает любой автомобиль, независимо от того, грузовой он или двгковой, 5- или
        12-местный. Разумно вынести эти общие свойства и функциональность
        в отдельный класс, например, "Автомобиль" и насле­довать от него классы "Легковой
        автомобиль" и "Грузовой
        автомобиль", чтобы избежать повторного написания одного и того же кода в разных классах.
    </p>
    <p></p>
    <center><img border="0" height="153" src="http://kufas.ru/java.files/image008.jpg" width="387">
    </center>
    <p>Отношение обобщения обозначается сплошной линией с треуголь­ной стрелкой на конце. Стрелка
        указывает на более общий класс (класс-Иредок
        или суперкласс), а ее отсутствие - на более специальный класс (класс-потомок
        или подкласс).
    </p>
    <p>Использование наследования способствует уменьшению количества кода,
        созданного для описания схожих сущностей, а также способствует НагШсанию
        более эффективного и гибкого кода.
    </p>
    <p>В рассмотренном примере применено одиночное наследование. Не­который
        класс также может наследовать свойства и поведение сразу не-сКольких
        классов. Наиболее популярным примером применения множе-СТвенного
        наследования является проектирование системы учета товаров в зоомагазине.
    </p>
    <p>Все животные в зоомагазине являются наследниками класса "Живот­ное",
        а также наследниками класса "Товар". Т.е. все они имеют возраст, нуж­даются
        в пище и воде и в то же время имеют цену и могут быть проданы.
    </p>
    <p>Множественное наследование на диаграмме изображается точно так же, как
        одиночное, за исключением того, что линии наследования соеди­няют класс-потомок
        сразу с несколькими суперклассами.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Не все объектно-ориентированные языки программирования содер­жат
        языковые конструкции для описания множественного наследования.
    </p>
    <p>В языке Java множественное
        наследование имеет ограниченную под­держку через интерфейсы и будет рассмотрено
        в лекции 8.
    </p>
    <p>
    </p>
    <p>Полиморфизм
    </p>
    <p>Полиморфизм является одним из фундаментальных понятий в объ­ектно-ориентированном
        программировании наряду с наследованием и инкапсуляцией. Слово
        "полиморфизм" греческого происхождения и оз­начает "имеющий
        много форм". Чтобы понять, что оно означает приме­нительно к
        объектно-ориентированному программированию, рассмот­рим пример.
    </p>
    <p>Предположим, мы хотим создать векторный графический редактор, в котором
        нам нужно описать в виде классов набор графических прими­тивов - Point, Line, Circle, Box и
        т.д. У каждого из этих классов определим метод draw для отображения соответствующего
        примитива на экране.
    </p>
    <p>Очевидно, придется написать код, который при необходимости ото­бразить
        рисунок будет последовательно перебирать все примитивы, на момент отрисовки
        находящиеся на экране, и вызывать метод draw у каж­дого из них. Человек, незнакомый с
        полиморфизмом, вероятнее всего,
        создаст несколько массивов (отдельный массив для каждого типа прими­тивов) и
        напишет код, который последовательно переберет элементы из каждого массива и
        вызовет у каждого элемента метод draw. В результате
        получится примерно следующий код:
    </p>
    <p>
    </p>
    <p>//создание пустого массива, который может содержать //объекты Pointe максимальным
        объемом 1000 Point[] р = new Point[1000];
    </p>
    <p>Line[] I   = new Line[ 1000]; Circlef] c= new
        Circle[1000]; Box[]b = new Box[1000];
    </p>
    <p>
    </p>
    <p>//предположим, в этом
        месте происходит заполнение
    </p>
    <p>// всех массивов
        соответствующими объектами
    </p>
    <p>
    </p>
    <p>1ог(Ы \ = 0;\&lt;
        р.\епдт;\++) { //цикл с перебором
        всех ячеек массива.
    </p>
    <p>//вызов метода draw() в случае,
    </p>
    <p>// если ячейка не пустая.
    </p>
    <p>1т(р[1]!=пШ1) p.draw();
    </p>
    <p>}
    </p>
    <p>тогО'т I = 0; |" &lt; 1.1епдтх1;1++) {
        1т(1[1]!=пи11) 1.с1гауу();
    </p>
    <p>}
    </p>
    <p>1ог(\Ш \-0;\&lt;
        с.1епд№;1++)
        { №(с[1]!=пи11)
        c.draw();
    </p>
    <p>}
    </p>
    <p>1ог(\п\. I = 0; 1
        &lt; Ь.1епдтп;!++)
        { |т(Ь[ф=пи11)
        b.draw();
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Недостатком написанного выше кода является дублирование практи­чески
        идентичного кода для отображения каждого типа примитивов. Также неудобно то, что
        при дальнейшей модернизации нашего графического ре­дактора и добавлении
        возможности рисовать новые типы графических примитивов, например Text, Star и т
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>д., при таком подходе придется менять существующий код и добавлять в
        него определения новых массивов, а так­же обработку содержащихся в них
        элементов.
    </p>
    <p>Используя полиморфизм, мы можем значительно упростить реали­зацию
        подобной функциональности. Прежде всего, создадим общий ро­дительский класс для
        всех наших классов. Пусть таким классом будет Point. В результате
        получим иерархию классов, которая изображена на рисунке 2.3.
    </p>
    <p>У каждого из дочерних классов метод draw переопределен таким об­разом, чтобы отображать
        экземпляры каждого класса
        соответствующим образом.
    </p>
    <p>Для описанной выше иерархии классов, используя полиморфизм, можно
        написать следующий код:
    </p>
    <p>
    </p>
    <p>Point р[] = new Point[
        1000]; Р[0] = new Circle();
    </p>
    <p>курс
    </p>
    <p>Программирование
        на Java
    </p>
    <p>Лекция
        2_____________________ Основы
        объектно-ориентированного программирования
    </p>
    <p>
    </p>
    <p>р[1] = new Point(); р[2] = new Вох(); р[3] = new Une();
    </p>
    <p>for(int i = 0; i &lt; p.length;i++) { if(p[i]!=null) p.draw();
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>В описанном выше примере массив р[] может содержать любые объ­екты, порожденные от
        наследников класса Point. При вызове какого-либо метода у любого из элементов этого массива
        будет
        выполнен метод того объекта, который содержится в ячейке массива. Например,
        если в ячейке р[0] находится объект Circle, то при вызове метода draw следующим образом:
    </p>
    <p>
    </p>
    <p>p[0].draw()
    </p>
    <p>нарисуется круг, а не точка.
    </p>
    <p>В заключение приведем
        формальное определение полиморфизма.
    </p>
    <p>Полиморфизм (polymorphism) - положение теории типов, согласно которому имена (например,
        переменных) могут обозначать объекты раз­ных (но имеющих общего родителя)
        классов. Следовательно, любой объ­ект, обозначаемый полиморфным именем, может
        по-своему реагировать на некий общий набор операций [2].
    </p>
    <p>
    </p>
    <table cellpadding="0" cellspacing="0">
        <tr>
            <td height="0" width="31"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <center><img height="205" src="http://kufas.ru/java.files/image009.png" width="398">
                </center>
            </td>
        </tr>
    </table>
    В процедурном программировании тоже существует понятие
    полимор­физма, которое отличается от рассмотренного механизма в ООП. Процедур­ный
    полиморфизм предполагает возможность создания нескольких проце­дур или функций
    с одним и тем же именем, но разным количеством или раз­личными типами
    передаваемых параметров. Такие одноименные функции называются перегруженными, а
    само явление - перегрузкой (overloading). Перегрузка функций существует и в ООП и называется
    перегрузкой методов.
    <p>Примером использования перегрузки
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>методов в языке Java может служить класс
        PrinrWriter, который применяется, в частности, для вывода сообщений на консоль. Этот
        класс имеет множество методов printin, ко­торые различаются типами и/или количеством входных
        параметров. Вот
        лишь несколько из них:
    </p>
    <p>void printlnO                           //
        переход на новую строку
    </p>
    <p>void println(boolean х)   // выводит значение
        булевской
    </p>
    <p>// переменной (true или false) void println(String х)    
        // выводит строку - значение
    </p>
    <p>//текстового
        параметра.
    </p>
    <p>Определенные сложности возникают при вызове перегруженных методов. В Java существуют
        специальные правила, которые позволяют решать эту проблему. Они будут
        рассмотрены в соответствующей лекции.
    </p>
    <p>
    </p>
    <p>Типы отношений между классами
    </p>
    <p>Как правило, любая программа, написанная на объектно-ориенти­рованном
        языке, представляет собой некоторый набор связанных между собой классов. Можно
        провести аналогию между написанием программы и строительством дома. Подобно
        тому, как стена складывается из кирпичей, компьютерная программа с
        использованием ООП строится из классов. Причем эти классы должны иметь
        представление друг о друге, для того что­бы сообща выполнять
        поставленную задачу.
    </p>
    <p>Возможны следующие связи между классами в рамках объектной модели
        (приводятся лишь наиболее простые и часто используемые виды связей, подробное
        их рассмотрение выходит за рамки этой ознакомитель­ной лекции):
    </p>
    <p>•
        агрегация (Aggregation);
    </p>
    <p>•
        ассоциация (Association);
    </p>
    <p>•
        наследование (Inheritance);
    </p>
    <p>•
        метаклассы (Metaclass).
    </p>
    <p>
    </p>
    <p>Агрегация
    </p>
    <p>Отношение между классами типа "содержит" (contain) или "состоит из называется агрегацией, или
        включением. Например,
        если аквариум Наполнен водой и в нем плавают рыбки, то можно сказать, что аквариум
        агрегирует в
        себе воду и рыбок.
    </p>
    <p></p>
    <center><img border="0" height="72" src="http://kufas.ru/java.files/image010.jpg" width="397">
    </center>
    <p>Такое отношение включения, или агрегации (aggregation), изобража­ется линией с ромбиком на
        стороне того класса, который
        выступает в ка­честве владельца, или контейнера. Необязательное название
        отношения записывается посередине линии.
    </p>
    <p>В нашем примере отношение contain является
        двунаправленным. Объект класса Aquarium содержит несколько
        объектов Fish. В то же вре­мя каждая рыбка "знает", в каком именно аквариуме
        она живет. Каждый класс имеет свою роль в агрегации, которая указывает, какое
        место зани­мает класс в данном отношении. Имя роли не является обязательным
        элементом обозначений и может отсутствовать на диаграмме
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> В примере можно видеть роль home класса Aquarium (аквариум является домом
        для рыбок), а также роль inhabitants класса Fish (рыбки являются обитателя­ми
        аквариума). Название роли обычно совпадает с названием соответст­вующего поля в
        классе. Изображение такого поля на диаграмме излишне, если уже указано имя
        роли. Т.е. в данном случае класс Aquarium будет иметь свойство
        (поле) inhabitants, а класс Fish - свойство home.
    </p>
    <p>Число объектов, участвующих в отношении, записывается рядом с именем
        роли. Запись "0..п" означает "от нуля до бесконечности". Приняты также
        обозначения:
    </p>
    <p>• "1
        ..п" — от единицы до
        бесконечности;
    </p>
    <p>•
        "О" - ноль;
    </p>
    <p>• "
        1 " — один;
    </p>
    <p>• "п"
        — фиксированное
        количество;
    </p>
    <p>• "0..
        1 " — ноль или один.
    </p>
    <p>Код, описывающий рассмотренную модель и явление агрегации, может
        выглядеть, например, следующим образом:
    </p>
    <p>//
        определение класса Fish public class Fish {
    </p>
    <p>//
        определения поля home (ссылка на объект Aquarium)
    </p>
    <p>private Aquarium home;
    </p>
    <p>public Fish() { }
    </p>
    <p>}
    </p>
    <p>// определение класса Aquarium public class Aquarium {
    </p>
    <p>// определения поля inhabitants (массив ссылок на объекты Fish) private Fish inhabitants[];
        public Aquarium() { }
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Ассоциация
    </p>
    <p>Если объекты одного класса ссылаются на один или более объектов другого
        класса, но ни в ту, ни в другую сторону отношение между объек­тами не носит
        характера "владения", или контейнеризации, такое отно­шение называют
        ассоциацией (association). Отношение ассоциации изоб­ражается так же, как и отношение
        агрегации,
        но линия, связывающая классы,— простая, без ромбика.
    </p>
    <table cellpadding="0" cellspacing="0" height="14" hspace="0" vspace="0">
        <tr>
            <td align="left" height="14" valign="top">
                <p>Computer
                </p>
            </td>
        </tr>
    </table>
    <table cellpadding="0" cellspacing="0" height="14" hspace="0" vspace="0">
        <tr>
            <td align="left" height="14" valign="top">
                <p>Programmer
                </p>
            </td>
        </tr>
    </table>
    <p>В качестве примера можно рассмотреть программиста и его компью­тер. Между
        этими двумя объектами нет агрегации, но существует четкая взаимосвязь. Так,
        всегда можно установить, за какими компьютерами ра­ботает какой-либо
        программист, а также какие люди пользуются отдельно взятым компьютером. В рассмотренном
        примере имеет место ассоциация
        "многие-ко-многим".
    </p>
    <table cellpadding="0" cellspacing="0" height="14" hspace="0" vspace="0">
        <tr>
            <td align="left" height="14" valign="top">
                <p>Computerт
                </p>
            </td>
        </tr>
    </table>
    <table cellpadding="0" cellspacing="0" height="14" hspace="0" vspace="0">
        <tr>
            <td align="left" height="14" valign="top">
                <p>0..n
                </p>
            </td>
        </tr>
    </table>
    <p>-programmers   -computers
    </p>
    <p>Programmerт I 0 n
    </p>
    <p>
    </p>
    <p>В данном случае между экземплярами классов Programmer и Computer в обе стороны используется
        отношение "0..п", т.к. програм­мист, в принципе, может не работать с компьютером (если он
        теоретик Или на пенсии). В свою очередь, компьютер может никем не использовать­ся (если он
        новый и
        еще не установлен).
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Код, соответствующий рассмотренному примеру, будет, например, следующим:
    </p>
    <p>public class Programmer {
    </p>
    <p>private Computer computers[];
    </p>
    <p>public Programmerт {
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>public class Computer {
    </p>
    <p>private Programmer programmers[];
    </p>
    <p>public Computerт {
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Наследование
    </p>
    <p>Наследование является важным случаем отношений между двумя или более
        классами. Подробно оно рассматривалось выше.
    </p>
    <p>
    </p>
    <p>Метаклассы
    </p>
    <p>Итак, любой объект имеет структуру, состоящую из полей и методов.
        Объекты, имеющие одинаковую структуру и семантику, описываются од­ним классом,
        который и является, по сути, определением структуры объек­тов, порожденных от
        него.
    </p>
    <p>В свою очередь, каждый класс, или описание, всегда имеет строгий шаблон,
        задаваемый языком программирования или выбранной объект­ной моделью. Он
        определяет, например, допустимо ли множественное наследование, какие существуют
        ограничения на именование классов, как описываются поля и методы, набор
        существующих типов данных и многое другое. Таким образом, класс можно
        рассматривать как объект, у которого есть свойства (имя, список полей и их
        типы, список методов, список аргументов для каждого метода и т.д.). Также класс
        может обладать поведением, то есть поддерживать методы. А раз для любого
        объекта су­ществует шаблон, описывающий свойства и поведение этого объекта,
        значит, его можно определить и для класса. Такой шаблон, задающий раз­личные
        классы, называется метаклассом.
    </p>
    <p>Чтобы представить себе, что такое метакласс, рассмотрим пример не­кой
        бюрократической организации. Будем считать, что все классы в такой системе
        представляют собой строгие инструкции, которые описывают, что нужно сделать,
        чтобы породить новый объект (например, нанять нового служащего или открыть
        новый отдел). Как и полагается классам, они опи­сывают все свойства новых
        объектов (например, зарплату и профессио­нальный уровень для сотрудников,
        площадь и имущество для отделов) и их поведение (обязанности служащих и функции
        подразделений).
    </p>
    <p>В свою очередь,
        написание новой инструкции можно строго регла­ментировать. Скажем, необходимо
        использовать специальный бланк, при­держиваться правил оформления и заполнить
        все обязательные поля (на­пример, номер инструкции и фамилии ответственных
        работников). Такая "инструкция инструкций" и будет представлять собой
        метакласс в ООП.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Итак, объекты порождаются от классов, а классы — от метакласса. Он, как
        правило, в системе только один. Но существуют языки програм­мирования, в
        которых можно создавать и использовать собственные мета­классы, например язык Python. В
        частности,
        функциональность мета­класса может быть следующая: при формировании класса он
        будет про­сматривать список всех методов в классе и, если имя метода имеет вид set_XXX или
        get_XXX, автоматически создавать поле с именем XXX, если такого не существует.
    </p>
    <p>Поскольку метакласс сам является классом, то нет никакого смысла в
        создании "мета-мета-классов".
    </p>
    <p>В языке Java также есть метакласс. Это класс, который так и называ­ется — Class (описывает
        классы),
        он располагается в основной библиоте­ке java.lang. Виртуальная машина использует его по
        прямому назначе­нию. Когда
        загружается очередной .class-файл, содержащий описание нового класса, JVM порождает объект
        класса Class, который будет хра­нить его структуру. Таким образом, Java использует
        концепцию метаклас­са в самых практических целях. С помощью Class реализована поддерж­ка
        статических (static) полей и методов. Наконец, этот класс содержит ряд методов, полезных
        для разработчиков. Они будут рассмотрены в сле­дующих лекциях.
    </p>
    <p>
    </p>
    <p>Достоинства ООП
    </p>
    <p>От любой методики разработки программного обеспечения мы ждем, что она
        поможет нам в решении наших задач. Но одной из самых Значительных проблем
        проектирования является сложность. Чем больше И сложнее программная
        система, тем важнее разбить ее на небольшие, четко очерченные части. Чтобы
        справиться со сложностью, необходимо абстрагироваться от деталей. В этом смысле
        классы представляют собой весьма удобный инструмент.
    </p>
    <p>•
        Классы позволяют проводить
        конструирование из полезных ком­понентов, обладающих простыми инструментами,
        что позволяет абстрагироваться от деталей реализации.
    </p>
    <p>•
        Данные и операции над ними
        образуют определенную сущность, и они не разносятся по всей программе, как
        нередко бывает в случае процедурного программирования, а описываются вместе.
        Локали­зация кода и данных улучшает наглядность и удобство сопровож­дения
        программного обеспечения.
    </p>
    <p>•
        Инкапсуляция позволяет
        привнести свойство модульности, что об­легчает распараллеливание выполнения
        задачи между несколькими исполнителями и обновление версий отдельных
        компонентов.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>ООП дает возможность создавать расширяемые системы. Это одно Из основных достоинств
        ООП, и именно оно отличает данный подход от традиционных методов
        программирования. Расширяемость означает, что существующую систему можно
        заставить работать с новыми компонента­ми, причем без внесения в нее каких-либо
        изменений. Компоненты мо­гут быть добавлены на этапе исполнения программы.
    </p>
    <p>Полиморфизм оказывается полезным преимущественно в следую­щих ситуациях.
    </p>
    <p>•  Обработка разнородных
        структур данных.
    </p>
    <p>Программы могут
        работать, не различая вида объектов, что существен­но упрощает код. Новые виды
        могут быть добавлены в любой момент.
    </p>
    <p>•  Изменение поведения во
        время исполнения.
    </p>
    <p>На этапе исполнения
        один объект может быть заменен другим, что позволяет легко, без изменения кода,
        адаптировать алгоритм в за­висимости от того, какой используется объект.
    </p>
    <p>•  Реализация работы с
        наследниками.
    </p>
    <p>Алгоритмы можно
        обобщить настолько, что они уже смогут рабо­тать более чем с одним видом
        объектов.
    </p>
    <p>•  Создание
        "каркаса" (framework).
    </p>
    <p>Независимые от
        приложения части предметной области могут быть реализованы в виде набора
        универсальных классов, или каркаса (framework), и в дальнейшем расширены за счет добавле­ния
        частей, специфичных для
        конкретного приложения. Часто многоразового использования программного
        обеспечения не удается добиться из-за того, что существующие компоненты уже не
        отве­чают новым требованиям. ООП помогает этого достичь без нарушения работы
        уже имеющихся клиентов, что позволяет извлечь максимум из многоразового
        использования компонентов.
    </p>
    <p>•
        Сокращается время на
        разработку, которое может быть отдано дру­гим задачам.
    </p>
    <p>•
        Компоненты многоразового использования
        обычно содержат го­раздо меньше ошибок, чем вновь разработанные, ведь они уже
        не раз подвергались проверке.
    </p>
    <p>•
        Когда некий компонент
        используется сразу несколькими клиента­ми, улучшения, вносимые в его код,
        одновременно оказывают по­ложительное влияние и на множество работающих с ним
        программ.
    </p>
    <p>•   Если программа опирается на стандартные компоненты, ее структура и
        пользовательский интерфейс становятся более уни­фицированными, что облегчает ее
        понимание и упрощает ис­пользование.
    </p>
    <p>
    </p>
    <p>Недостатки ООП
    </p>
    <p>Документирование классов - задача более трудная, чем это было в слу­чае
        процедур и модулей
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Поскольку любой метод может быть переопреде­лен, в
        документации должно говориться не только о том, что делает данный метод, но и о
        том, в каком контексте он вызывается. Ведь переопределен­ные методы обычно
        вызываются не клиентом, а самим каркасом. Таким образом, программист должен
        знать, какие условия выполняются, когда вызывается данный метод. Для
        абстрактных методов, которые пусты, в документации должно говориться о том, для
        каких целей предполагается использовать переопределяемый метод.
    </p>
    <p>В сложных иерархиях классов поля и методы обычно наследуются с разных
        уровней. И не всегда легко определить, какие поля и методы фак­тически
        относятся к данному классу. Для получения такой информации нужны специальные
        инструменты, вроде навигаторов классов. Если кон­кретный класс расширяется, то
        каждый метод обычно сокращают перед передачей сообщения базовому классу.
        Реализация операции, таким об­разом, рассредоточивается по нескольким классам,
        и чтобы понять, как она работает, нам приходится внимательно просматривать весь
        код.
    </p>
    <p>Методы, как правило, короче процедур, поскольку они осуществляют только
        одну операцию над данными, зато их намного больше. В коротких методах легче
        разобраться, но они неудобны тем, что код для обработки со­общения иногда
        "размазан" по многим маленьким методам.
    </p>
    <p>Инкапсуляцией данных не следует злоупотреблять. Чем больше ло­гики и
        данных скрыто в недрах класса, тем сложнее его расширять. От­правной точкой
        здесь должно быть не то, что клиентам не разрешается знать о тех или иных
        данных, а то, что клиентам для работы с классом этих данных знать не требуется.
    </p>
    <p>Многие считают, что ООП является неэффективным. Как же обстоит де­ло в
        действительности? Мы должны проводить четкую грань между неэффек­тивностью на
        этапе выполнения, неэффективностью в смысле распределения памяти и
        неэффективностью, связанной с излишней универсализацией.
    </p>
    <p>1. Неэффективность на этапе выполнения. В языках типа Smalltalk со­общения
        интерпретируются во время выполнения программы путем осуществления их поиска в
        одной или нескольких таблицах и за счет выбора подходящего метода. Конечно, это
        медленный процесс. И да­же при использовании наилучших методов оптимизации
        Smalltalk-программы в десять раз медленнее оптимизированных С-программ. В
        гибридных языках типа Oberon-2, Object Pascal и С++ отправка
        сообщения приводит лишь к вызову через указатель процедурной переменной. На
        некоторых машинах сообщения выполняются лишь на 10% медленнее, чем обычные
        процедурные вызовы. И по­скольку сообщения встречаются в программе гораздо реже
        других операций, их воздействие на время выполнения влияния практи­чески не
        оказывает.
    </p>
    <p>Однако существует
        другой фактор, который влияет на время выпол­нения: это инкапсуляция данных.
        Рекомендуется не предоставлять прямой доступ к полям класса, а выполнять каждую
        операцию над данными через методы. Такая схема приводит к необходимости вы­полнения
        процедурного вызова каждый раз при доступе к данным. Однако если инкапсуляция
        используется только там, где она необ­ходима (т.е. в тех случаях, когда это
        становится преимуществом), то замедление вполне приемлемое.
    </p>
    <p>2.
        Неэффективность в смысле
        распределения памяти. Динамическое связывание и проверка типа на этапе
        выполнения требуют по ходу работы информации о типе объекта. Такая информация
        хранится в дескрипторе типа и он выделяется один на кл&amp;сс. Каждый объект
        имеет невидимый указатель на дескриптор типа для своего класса. Таким образом,
        в объектно-ориентированных программах необхо­димая дополнительная память выражается
        в одном указателе для объекта и в одном дескрипторе типа для класса.
    </p>
    <p>3.
        Излишняя универсальность.
        Неэффективность также может озна­чать, что в программе реализованы избыточные
        возможности. В библиотечном классе часто содержится больше методов, чем это
        реально необходимо. А поскольку лишние методы не могут быть удалены, они
        становятся мертвым грузом. Это не влияет на время выполнения, но сказывается на
        размере кода.
    </p>
    <p>Одно из возможных
        решений — строить базовый класс с минималь­ным числом методов, а затем уже
        реализовывать различные расши­рения этого класса, которые позволят нарастить
        функциональность. Другой подход — дать компоновщику возможность удалять лиш­ние
        методы. Такие интеллектуальные компоновщики уже сущест­вуют для различных
        языков и операционных систем. Но нельзя утверждать, что ООП неэффективно. Если
        классы исполь­зуются лишь там, где это действительно необходимо, то потеря
        эффектив­ности из-за повышенного расхода памяти и меньшей производительности
        незначительна. Кроме того, надежность программного обеспечения и быс­трота его
        написания часто бывает важнее, чем производительность.
    </p>
    <p>
    </p>
    <p>Заключение
    </p>
    <p>В этой лекции мы рассказали об объектно-ориентированном подхо­де к
        разработке ПО, а также о том, что послужило предпосылками к его появлению и
        сделало его популярным. Были рассмотрены ключевые по­нятия ООП - объект и
        класс. Далее были описаны основные свойства объектной модели - инкапсуляции,
        наследование, полиморфизм. Основ­ными видами отношений между классами являются
        наследование, ассоци­ация, агрегация, метакласс. Также были описаны правила
        изображения классов и связей между ними на языке ТЛМЬ.
    </p>
    <p>Вариант 1
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>1.      Почему объектно-ориентированное
        программирование
        пришло на смену процедурному программированию?
    </p>
    <p>&#9633;       программы,
        написанные с использованием ООП, выполняются на компьютере быстрее
    </p>
    <p>&#9633;       использование
        ООП позволяет создавать не зависящие от платформы программы
    </p>
    <p>&#9633;
        ООП позволяет уменьшить
        сложность создаваемого ПО
    </p>
    <p>&#9633;
        ООП позволяет увеличить
        надежность создаваемого ПО
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.       Что
        используется для описания поведения объекта?
    </p>
    <p>&#9633;        поля
        П   методы
    </p>
    <p>П   наследование
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.       Инкапсуляция
        - это:
    </p>
    <p>&#9633;       объединение
        данных и обрабатывающего
        их программного кода в одной логической структуре (классе)
    </p>
    <p>&#9633;       сокрытие
        реализации класса и отделение его внутреннего представления от внешнего
        интерфейса
    </p>
    <p>&#9633;       одно
        из базовых понятий ООП, которое позволяет расширять функциональность программы,
        не расширяя объектную модель этой программы
    </p>
    <p>
    </p>
    <table cellpadding="0" cellspacing="0">
        <tr>
            <td height="0" width="489"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <center><img height="269" src="http://kufas.ru/java.files/image011.png" width="437">
                </center>
            </td>
        </tr>
    </table>
    Вариант 2
    <p>
    </p>
    <p>
    </p>
    <p>1.       Что
        из перечисленного является классами,
        а что - объектами (отметьте классы):
    </p>
    <p>П      яблоко
    </p>
    <p>П      Иван
        Сидорович Петров
    </p>
    <p>П      легковой
        автомобиль
    </p>
    <p>&#9633;       страховое
        свидетельство №113-043-429-18
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.       Зачем
        нужен полиморфизм?
    </p>
    <p>П   полиморфизм
        используется для написания общего кода,
    </p>
    <p>который
        будет одинаково работать с разными типами данных (объектами разных классов),
        при условии, что классы, от которых созданы эти объекты, имеют общего предка
    </p>
    <p>П   полиморфизм
        позволяет создавать в одном классе несколько методов с одинаковыми именами, но
        с разным набором параметров
    </p>
    <p>П   полиморфизм
        необходим в любой программе, использующей ООП. Без него невозможно написать
        программу на объектноориентированном языке программирования
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.       Метакласс
        - это:
    </p>
    <p>П   базовый
        класс в дереве наследования. Все потомки этого класса расширяют или замещают
        его функциональность
    </p>
    <p>П   некоторый
        шаблон, который описывает свойства и поведение класса, подобно тому, как класс
        описывает свойства и поведение объекта
    </p>
    <p>П   класс,
        от которого наследуются все классы в дереве наследования. Любой из классов в
        программе обязательно является наследником этого класса (пример java.lang.Object)
    </p>
    <p>2.   Что из перечисленного является в классе «Лифт»
        внешним интерфейсом:
    </p>
    <p>&#9633; кнопки
        управления П    разводка проводов
    </p>
    <p>&#9633;
        реакция на нажатие какой-либо
        кнопки П                количество людей в лифте
    </p>
    <p>П   марка металла, из которого изготовлен
        трос
    </p>
    <p>
    </p>
    <p>3&gt;   Множественным наследованием
        называют:
    </p>
    <p>П   ситуацию, когда у некоторого класса
        есть более чем один непосредственный наследник
    </p>
    <p>О   наследование, в котором участвует
        множество классов (более двух)
    </p>
    <p>О   отношение наследования, при котором
        класс-наследник расширяет или дополняет функциональность нескольких базовых
        классов
    </p>
    <p>—==
    </p>
    <p>
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <center><h2>Лекция
        2. Основы объектно-ориентированного программирования</h2></center>
    <p>
    </p>
    <p>
    </p>
    <p>В этой лекции излагается основная концепция
        объектно-ориентирован­ного подхода (ООП) к проектированию программного
        обеспечения. Поскольку в Java почти все типы (за
        исключением восьми простейших) являются объектны­ми, владение ООП становится
        необходимым условием для успешного примене­ния языка. Лекция имеет вводный,
        обзорный характер. Для более детального изучения предлагается список
        дополнительной литературы и Internet-ресурсов.
    </p>
    <p>
    </p>
    <p>Ключевые слова: блок-схема, объектно-ориентированное програм­мирование, ООП, объект,
        состояние, поведение, уникальность, класс, UML, конструктор,
        деструктор, инкапсуляция, модульность, наследование, класс-предок, суперкласс,
        класс-потомок, подкласс, полиморфизм, перегруженная функция, перегрузка,
        ассоциация, метакласс.
    </p>
    <p>
    </p>
    <p>Методология
        процедурно-ориентированного программирования
    </p>
    <p>Появление первых электронных вычислительных машин, или
        компью­теров, ознаменовало новый этап в развитии техники вычислений. Казалось,
        достаточно разработать последовательность элементарных действий, каж­дое из
        которых можно преобразовать в понятные компьютеру инструкции, и любая
        вычислительная задача будет решена. Эта идея оказалась настоль­ко
        жизнеспособной, что долгое время доминировала над всем процессом разработки
        программ. Появились специализированные языки программи­рования, созданные для
        разработки программ, предназначенных для ре­шения вычислительных задач.
        Примерами таких языков могут служить FOCAL (FOrmula CALculator) и FORTRAN
        (FORmula TRANslator).
    </p>
    <p>Основой такой методологии разработки программ являлась
        проце­дурная, или алгоритмическая, организация структуры программного ко­да.
        Это было настолько естественно для решения вычислительных задач, То
        целесообразность такого подхода ни у кого не вызывала сомнений. Исходным в
        данной методологии было понятие алгоритма. Алгоритм — ^o способ решения вычислительных и
        других задач, точно описываю­щий
        определенную последовательность действий, которые необходимо выполнить для
        достижения заданной цели. Примерами алгоритмов явля­ется хорошо известные
        правила нахождения корней квадратного уравне­ния или линейной системы
        уравнений.
    </p>
    <p>
    </p>
    <table cellpadding="0" cellspacing="0">
        <tr>
            <td height="0" width="481"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <center><img height="457" src="http://kufas.ru/java.files/image005.png" width="452">
                </center>
            </td>
        </tr>
    </table>
    При увеличении объемов программ для упрощения их
    разработки по­явилась необходимость разбивать большие задачи на подзадачи
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> В языках программирования возникло и закрепилось новое понятие процедуры.
        Ис­пользование процедур позволило разбивать большие задачи на подзадачи и таким
        образом упростило написание больших программ. Кроме того, про­цедурный подход
        позволил уменьшить объем программного кода за счет написания часто используемых
        кусков кода в виде процедур и их примене­ния в различных частях программы.
    </p>
    <p>Как и алгоритм, процедура представляет собой законченную последо­вательность
        действий или операций, направленных на решение отдельной задачи. В языках программирования
        появилась специальная синтаксичес­кая
        конструкция, которая также получила название процедуры. Например, на языке Pascal описание
        процедуры
        выглядит следующим образом:
    </p>
    <p>
    </p>
    <p>Procedure printGreeting(name: String) Begin
    </p>
    <p>Print("Hello,
        ");
    </p>
    <p>PrintLn(s); End;
    </p>
    <p>Назначение данной процедуры — вывести на экран приветствие Hello, Name, где Name передается в
        процедуру в качестве входного параметра.
    </p>
    <p>Со временем
        вычислительные задачи становились все сложнее, а зна­чит, и решающие их
        программы увеличивались в размерах. Их разработка превратилась в серьезную
        проблему. Когда программа становится все боль­ше, ее приходится разделять на
        все более мелкие фрагменты. Основой для такого разбиения как раз и стала
        процедурная декомпозиция, при которой отдельные части программы, или модули,
        представляли собой совокупность процедур для решения одной или нескольких
        задач. Одна из основных осо­бенностей процедурного программирования заключается
        в том, что оно позволило создавать библиотеки подпрограмм (процедур), которые
        можно было бы использовать повторно в различных проектах или в рамках одного
        проекта. При процедурном подходе для визуального представления алгорит­ма
        выполнения программы применяется так называемая блок-схема. Соот­ветствующая
        система графических обозначений была зафиксирована в ГОСТ 19.701-90. Пример
        блок-схемы изображен на рисунке (рис. 2.1).
    </p>
    <p>Появление и интенсивное использование условных операторов и опе­ратора
        безусловного перехода стало предметом острых дискуссий среди специалистов по
        программированию. Дело в том, что бесконтрольное при­менение в программе
        оператора безусловного перехода goto может замет­но осложнить понимание кода. Такие
        запутанные
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>программы
        сравнивали с порцией спагетти (bowl of
        spaghetti), имея в виду многочисленные
        перехо­да от одного фрагмента программы к другому, или, что еще
        хуже, возврат % конечных операторов программы к начальным. Ситуация
        казалась на-ТОМгько драматичной, что многие предлагали исключить оператор goto из языков
        программирования. Именно с
        этого времени отсутствие безуслов­ных переходов стали считать хорошим стилем
        программирования.
    </p>
    <p>Дальнейшее увеличение программных систем способствовало фор­мированию
        новой точки зрения на процесс разработки программ и нали­чия программных кодов, которая
        получила название методологии структурного
        программирования. Ее основой является процедурная де­композиция предметной
        области решаемой задачи и организация отдель­ных модулей в виде совокупности процедур. В
        рамках этой методологии п°лучило развитие нисходящее проектирование программ, или
        проекти­рование
        "сверху вниз". Пик популярности идей структурного программи­рования
        приходится на конец 70-х — начало 80-х годов.
    </p>
    <p>В этот период основным показателем сложности разработки программ
        считался ее размер. Вполне серьезно обсуждались такие оценки сложности
        программ, как количество строк программного кода. Правда, при этом дела­лись
        некоторые предположения относительно синтаксиса самих строк, ко­торые должны
        были соответствовать определенным требованиям. Напри­мер, каждая строка кода
        должна была содержать не более одного оператора. Общая трудоемкость разработки
        программ оценивалась специальной едини­цей измерения —
        "человеко-месяц", или "человеко-год". А профессионализм
        программиста напрямую связывался с количеством строк программного ко­да,
        который он мог написать и отладить в течение, скажем, месяца.
    </p>
    <p>
    </p>
    <p>Методология объектно-ориентированного программирования
    </p>
    <p>Увеличение размеров программ приводило к необходимости привле­чения
        большего числа программистов, что, в свою очередь, потребовало дополнительных
        ресурсов для организации их согласованной работы. В пронессе разработки
        приложений заказчик зачастую изменял функцио­нальные требования, что еще более
        усложняло процесс создания про­граммного обеспечения.
    </p>
    <p>Но не менее важными оказались качественные изменения, связан­ные со
        смещением акцента использования компьютеров
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> В эпоху "боль­ших машин"
        основными потребителями программного обеспечения были такие крупные заказчики,
        как большие производственные предприятия, финансовые компании, государственные
        учреждения. Стоимость таких вычислительных устройств для небольших предприятий
        и организаций была слишком высока.
    </p>
    <p>Позже появились персональные компьютеры, которые имели гораз­до меньшую
        стоимость и были значительно компактнее. Это позволило широко использовать их в
        малом и среднем бизнесе. Основными задачами в этой области являются обработка
        данных и манипулирование ими, по­этому вычислительные и
        расчетно-алгоритмические задачи с появлением персональных компьютеров отошли на
        второй план.
    </p>
    <p>Как показала практика, традиционные методы процедурного про­граммирования
        не способны справиться ни с нарастающей сложностью программ и их разработки, ни
        с необходимостью повышения их надежно­сти. Во второй половине 80-х годов
        возникла настоятельная потребность в новой методологии программирования,
        которая была бы способна ре­шить весь этот комплекс проблем. Ею стало
        объектно-ориентированное программирование (ООП).
    </p>
    <p>После составления технического задания начинается этап проекти­рования,
        или дизайна, будущей системы. Объектно-ориентированный подход к проектированию
        основан на представлении предметной области задачи в виде множества моделей для
        независимой от языка разработки программной системы на основе ее прагматики.
    </p>
    <p>Последний термин нуждается в пояснении. Прагматика определяется целью
        разработки программной системы, например, обслуживание клиен-» тов банка,
        управление работой аэропорта, обслуживание чемпионата мира t, по футболу и т.п. В
        формулировке цели участвуют предметы и понятия ре­ального
        мира, имеющие отношение к создаваемой системе (см. рисунок 2.2 f |3]). При
        объектно-ориентированном подходе эти предметы и понятия за­меняются
        моделями, т.е. определенными формальными конструкциями.
    </p>
    <p></p>
    <center><img border="0" height="215" src="http://kufas.ru/java.files/image006.jpg" width="444">
    </center>
    <p>
    </p>
    <p>Рис. 2.2. Семантика (смысл программы с точки зрения выполняю­щего ее компьютера) и
        прагматика (смысл программы с точки зре­ния ее пользователей) [3].
    </p>
    <p>Модель содержит не все
        признаки и свойства представляемого ею едмета или понятия, а только те, которые
        существенны для разрабаты-емой программной системы. Таким образом, модель
        "беднее", а следо-|тельно, проще представляемого ею предмета или
        понятия.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Простота модели по
        отношению к реальному предмету позволяет делать ее формальной. Благодаря такому
        характеру моделей при разра-гке можно четко выделить все зависимости и операции
        над ними в со-
    </p>
    <table cellpadding="0" cellspacing="0" hspace="0" vspace="0">
        <tr>
            <td align="left" valign="top">
                <p>^
                </p>
            </td>
        </tr>
    </table>
    <p>аваемой программной
        системе. Это упрощает как разработку и изучение „ Кализ) моделей, так и их
        реализацию на компьютере.
    </p>
    <p>Объектно-ориентированный подход помогает справиться с такими проблемами,
        как:
    </p>
    <p>•
        уменьшение сложности
        программного обеспечения;
    </p>
    <p>•
        повышение надежности
        программного обеспечения;
    </p>
    <p>• обеспечение возможности модификации отдельных компонентов программного
        обеспечения без изменения остальных его компо­нентов;
    </p>
    <p>• обеспечение возможности повторного использования отдельных компонентов
        программного обеспечения.
    </p>
    <p>Более детально преимущества и недостатки объектно-ориентирован­ного
        программирования будут рассмотрены в конце лекции, так как для их понимания
        необходимо знание основных понятий и положений ООП.
    </p>
    <p>Систематическое применение объектно-ориентированного подхода позволяет
        разрабатывать хорошо структурированные, надежные в экс­плуатации, достаточно
        просто модифицируемые программные системы. Этим объясняется интерес
        программистов к объектно-ориентированному подходу и объектно-ориентированным
        языкам программирования. ООП является одним из наиболее интенсивно развивающихся
        направлений теоретического и прикладного программирования.
    </p>
    <p>
    </p>
    <p>Объекты
    </p>
    <p>По определению будем называть объектом понятие, абстракцию или любой
        предмет с четко очерченными границами, имеющий смысл в контексте
        рассматриваемой прикладной проблемы. Введение объектов преследует две цели:
    </p>
    <p>•
        понимание прикладной
        задачи (проблемы);
    </p>
    <p>•
        введение основы для
        реализации на компьютере.
    </p>
    <p>Примеры объектов:
        форточка, Банк "Империал", Петр Сидоров, дело № 7461, сберкнижка и
        т.д.
    </p>
    <p>Каждый объект имеет определенное время жизни. В процессе выпол­нения
        программы, или функционирования какой-либо реальной систе­мы, могут создаваться
        новые объекты и уничтожаться уже существующие.
    </p>
    <p>Гради Буч дает следующее
        определение объекта:
    </p>
    <p>Объект — это мыслимая или реальная сущность, обладающая харак­терным
        поведением и отличительными характеристиками и являющаяся важной в предметной
        области [2].
    </p>
    <p>Каждый объект имеет состояние, обладает четко определенным пове­дением и
        уникальной идентичностью.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>
    </p>
    <p>Состояние
    </p>
    <p>Рассмотрим пример. Любой человек может находиться в некотором положении
        (состоянии): стоять, сидеть, лежать, и — в то же время совер­шать какие либо
        действия.
    </p>
    <p>Например, человек может прыгать, если он стоит, и не может — если он
        лежит, для этого ему потребуется сначала встать. Также в объектно­ориентированном
        программировании состояние объекта может опреде­ляться наличием или отсутствием
        связей между моделируемым объектом и другими объектами. Более подробно все
        возможные связи между объек­тами будут рассмотрены в разделе "Типы
        отношений между классами".
    </p>
    <p>Например, если у человека есть удочка (у него есть связь с объектом
        "Удочка"), он может ловить рыбу, а если удочки нет, то такое действие
        не­возможно. Из этих примеров видно, что набор действий, которые может
        совершать человек, зависит от параметров объекта, его моделирующего.
    </p>
    <p>Для рассмотренных выше примеров такими характеристиками, или атрибутами,
        объекта "Человек" являются:
    </p>
    <p>•
        текущее положение человека
        (стоит, сидит, лежит);
    </p>
    <p>•
        наличие удочки (есть или
        нет).
    </p>
    <p>В конкретной задаче могут появиться и другие свойства, например,
        физическое состояние, здоровье (больной человек обычно не прыгает).
    </p>
    <p>Состояние (state) - совокупный результат поведения объекта: одно из стабильных условий,
        в которых объект может существовать, охаракте­ризованных количественно; в любой
        момент времени состояние объекта включает в себя перечень (обычно статический)
        свойств объекта и теку­щие значения (обычно динамические) этих свойств [2].
    </p>
    <p>
    </p>
    <p>Поведение
    </p>
    <p>Для каждого объекта существует определенный набор действий, которые с
        ним можно произвести. Например, возможные действия с некоторым файлом
        операционной системы ПК:
    </p>
    <p>•
        создать;
    </p>
    <p>•
        открыть;
    </p>
    <p>•
        читать из файла;
    </p>
    <p>•
        писать в файл;
    </p>
    <p>•
        закрыть;
    </p>
    <p>•
        удалить.
    </p>
    <p>Результат выполнения действий зависит от состояния объекта на мо­мент
        совершения действия, т.е. нельзя, например, удалить файл, если он открыт
        кем-либо (заблокирован). В то же время действия могут менять внутреннее
        состояние объекта - при открытии или закрытии файла свой­ство
        "открыт" принимает значения "да" или "нет",
        соответственно.
    </p>
    <p>Программа, написанная с использованием ООП, обычно состоит из Множества
        объектов, и все эти объекты взаимодействуют между собой, обычно говорят, что
        взаимодействие между объектами в программе про­исходит посредством передачи
        сообщений между ними.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>^ В терминологии
        объектно-ориентированного подхода понятия "дейст­ве ,
        "сообщение" и "метод" являются синонимами. Т.е. выражения
        "выпол­нить действие над объектом", "вызвать метод объекта"
        и "послать сообщение объекту для выполнения какого-либо действия"
        эквивалентны. Последняя фраза появилась из следующей модели. Программу,
        построенную по техно­логии ООП, можно представить себе как виртуальное
        пространство, запол­ненное объектами, которые условно "живут"
        некоторой жизнью. Их актив­ность проявляется в том, что они вызывают друг у
        друга методы, или посы­лают друг другу сообщения. Внешний интерфейс объекта,
        или набор его ме­тодов,— это описание того, какие сообщения он может принимать.
    </p>
    <p>Поведение (behavior) — действия и реакции объекта, выраженные в терминах передачи
        сообщений и изменения состояния; видимая извне и воспроизводимая активность
        объекта [2].
    </p>
    <p>
    </p>
    <p>Уникальность
    </p>
    <p>Уникальность - это то, что отличает объект от других объектов. На­пример,
        у вас может быть несколько одинаковых монет. Даже если абсо­лютно все их
        свойства (атрибуты) одинаковы (год выпуска, номинал и т.д.) и при этом вы
        можете использовать их независимо друг от друга, они по-прежнему остаются
        разными монетами.
    </p>
    <p>В машинном
        представлении под параметром уникальности объекта чаще всего понимается адрес
        размещения объекта в памяти.
    </p>
    <p>Identity (уникальность)
        объекта состоит в том, что всегда можно оп­ределить, указывают две ссылки на
        один и тот же объект или на разные объекты. При этом два объекта могут во всем
        быть похожими, их образ в памяти может представляться одинаковыми последовательностями
        бай­тов,
        но, тем не менее, их Identity может быть
        различна.
    </p>
    <p>Наиболее распространенной ошибкой является понимание уни­кальности как
        имени ссылки на объект. Это неверно, т.к. на один объект может указывать
        несколько ссылок, и ссылки могут менять свои значения (ссылаться на другие
        объекты).
    </p>
    <p>Итак, уникальность (identity) - свойство
        объекта; то, что отличает его от других объектов (автор не согласен с переводом
        русского издания [2], поэтому здесь приводится авторский перевод).
    </p>
    <p>
    </p>
    <p>Классы
    </p>
    <p>Все монеты из предыдущего примера принадлежат одному и тому же классу
        объектов (именно с этим связана их одинаковость)
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Номинальная стоимость монеты,
        металл, из которого она изготовлена, форма - это ат­рибуты класса. Совокупность
        атрибутов и их значений характеризует объ­ект. Наряду с термином
        "атрибут" часто используют термины "свойство" и
        "поле", которые в объектно-ориентированном программировании явля­ются
        синонимами.
    </p>
    <p>Все объекты одного и того же класса описываются одинаковыми на­борами
        атрибутов. Однако объединение объектов в классы определяется не наборами
        атрибутов, а семантикой. Так, например, объекты "конюш­ня" и
        "лошадь" могут иметь одинаковые атрибуты: цена и возраст. При этом
        они могут относиться к одному классу, если рассматриваются в зада­че просто как
        товар, либо к разным классам, если в рамках поставленной задачи будут
        использоваться по-разному, т.е. над ними будут совершаться различные действия.
    </p>
    <p>Объединение объектов в классы позволяет рассмотреть задачу в бо­лее
        общей постановке. Класс имеет имя (например, "лошадь"), которое относится
        ко всем объектам этого класса. Кроме того, в классе вводятся имена атрибутов,
        которые определены для объектов. В этом смысле опи­сание класса аналогично
        описанию типа структуры или записи (record), широко
        применяющихся в процедурном программировании; при этом каждый объект имеет тот
        же смысл, что и экземпляр структуры (перемен­ная или константа соответствующего
        типа).
    </p>
    <p>Формально класс - это шаблон поведения объектов определенного типа с
        заданными параметрами, определяющими состояние. Все экземп­ляры одного класса
        (объекты, порожденные от одного класса) имеют один и тот же набор свойств и
        общее поведение, то есть одинаково реаги­руют на одинаковые сообщения
    </p>
    <p></p>
    <center><img border="0" height="122" src="http://kufas.ru/java.files/image007.jpg" width="132">
    </center>
    <p>^ В соответствии с UML (Unified Modeling Language - унифицирован­ный
        язык моделирования), класс имеет следующее графическое представ­ление.
    </p>
    <p>Класс изображается в виде прямоугольника, состоящего из трех час­тей. В
        верхней части помещается название класса, в средней - свойства объектов класса,
        в нижней - действия, которые можно выполнять с объ­ектами данного класса
        (методы).
    </p>
    <p>Каждый класс также может иметь специальные методы, которые ав­томатически
        вызываются при создании и уничтожении объектов этого Класса:
    </p>
    <p>•
        конструктор (constructor) - выполняется при создании объектов;
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>•
        деструктор (destructor) - выполняется при уничтожении объектов.
    </p>
    <p>Обычно конструктор и деструктор имеют специальный синтаксис, который
        может отличаться от синтаксиса, используемого для написания обычных методов
        класса.
    </p>
    <p>
    </p>
    <p>Инкапсуляция
    </p>
    <p>Инкапсуляция (encapsulation) — это сокрытие реализации класса и отделение его внутреннего
        представления от внешнего (интерфейса). При использовании
        объектно-ориентированного подхода не принято применять прямой доступ к
        свойствам какого-либо класса из методов других классов. Для доступа к свойствам
        класса принято задействовать специальные методы этого класса для получения и
        изменения его свойств.
    </p>
    <p>Внутри объекта данные и методы могут обладать различной степенью
        открытости (или доступности). Степени доступности, принятые в языке Java, подробно будут
        рассмотрены лекции 6. Они позволяют более тонко управлять свойством
        инкапсуляции.
    </p>
    <p>Открытые члены класса составляют внешний интерфейс объекта. Это та
        функциональность, которая доступна другим классам. Закрытыми обычно объявляются
        все свойства класса, а также вспомогательные методы, которые являются деталями
        реализации и от которых не должны зависеть другие части системы.
    </p>
    <p>Благодаря сокрытию реализации за внешним интерфейсом класса можно менять
        внутреннюю логику отдельного класса, не меняя код осталь­ных компонентов
        системы. Это свойство называется модульность.
    </p>
    <p>Обеспечение доступа к свойствам класса только через его методы так­же
        дает ряд преимуществ. Во-первых, так гораздо проще контролировать корректные
        значения полей, ведь прямое обращение к свойствам отслежи­вать невозможно, а
        значит, им могут присвоить некорректные значения.
    </p>
    <p>Во-вторых, не
        составит труда изменить способ хранения данных. Ес­ли информация станет
        храниться не в памяти, а в долговременном храни­лище, таком как файловая
        система или база данных, потребуется изменить лишь ряд методов одного класса, а
        не вводить эту функциональность во все части системы.
    </p>
    <p>Наконец, программный код, написанный с использованием данно­го принципа,
        легче отлаживать. Для того, чтобы узнать, кто и когда изме­нил свойство
        интересующего нас объекта, достаточно добавить вывод от­ладочной информации в
        тот метод объекта, посредством которого осуще­ствляется доступ к свойству этого
        объекта. При использовании прямого до­ступа к свойствам объектов программисту
        пришлось бы добавлять вывод отладочной информации во все участки кода, где
        используется интересую­щий нас объект.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Наследование
    </p>
    <p>Наследование (inheritance) — это отношение между классами, при ко­тором класс использует
        структуру или поведение другого класса (одиноч­ное наследование), или других (множественное
        наследование) классов. Наследование вводит иерархию "общее/частное", в которой подкласс
        на­следует от одного или нескольких более общих суперклассов. Подклассы обычно дополняют или
        переопределяют унаследованную структуру и по­ведение.
    </p>
    <p>В качестве примера можно рассмотреть задачу, в которой необходи­мо
        реализовать классы "Легковой автомобиль" и "Грузовой
        автомобиль". Очевидно, эти два класса имеют общую функциональность. Так, оба они имеют 4
        колеса, двигатель, могут перемещаться и т.д. Всеми этими
        свой-ствами обладает любой автомобиль, независимо от того, грузовой он или двгковой, 5- или
        12-местный. Разумно вынести эти общие свойства и функциональность
        в отдельный класс, например, "Автомобиль" и насле­довать от него классы "Легковой
        автомобиль" и "Грузовой
        автомобиль", чтобы избежать повторного написания одного и того же кода в разных классах.
    </p>
    <p></p>
    <center><img border="0" height="153" src="http://kufas.ru/java.files/image008.jpg" width="387">
    </center>
    <p>Отношение обобщения обозначается сплошной линией с треуголь­ной стрелкой на конце. Стрелка
        указывает на более общий класс (класс-Иредок
        или суперкласс), а ее отсутствие - на более специальный класс (класс-потомок
        или подкласс).
    </p>
    <p>Использование наследования способствует уменьшению количества кода,
        созданного для описания схожих сущностей, а также способствует НагШсанию
        более эффективного и гибкого кода.
    </p>
    <p>В рассмотренном примере применено одиночное наследование. Не­который
        класс также может наследовать свойства и поведение сразу не-сКольких
        классов. Наиболее популярным примером применения множе-СТвенного
        наследования является проектирование системы учета товаров в зоомагазине.
    </p>
    <p>Все животные в зоомагазине являются наследниками класса "Живот­ное",
        а также наследниками класса "Товар". Т.е. все они имеют возраст, нуж­даются
        в пище и воде и в то же время имеют цену и могут быть проданы.
    </p>
    <p>Множественное наследование на диаграмме изображается точно так же, как
        одиночное, за исключением того, что линии наследования соеди­няют класс-потомок
        сразу с несколькими суперклассами.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Не все объектно-ориентированные языки программирования содер­жат
        языковые конструкции для описания множественного наследования.
    </p>
    <p>В языке Java множественное
        наследование имеет ограниченную под­держку через интерфейсы и будет рассмотрено
        в лекции 8.
    </p>
    <p>
    </p>
    <p>Полиморфизм
    </p>
    <p>Полиморфизм является одним из фундаментальных понятий в объ­ектно-ориентированном
        программировании наряду с наследованием и инкапсуляцией. Слово
        "полиморфизм" греческого происхождения и оз­начает "имеющий
        много форм". Чтобы понять, что оно означает приме­нительно к
        объектно-ориентированному программированию, рассмот­рим пример.
    </p>
    <p>Предположим, мы хотим создать векторный графический редактор, в котором
        нам нужно описать в виде классов набор графических прими­тивов - Point, Line, Circle, Box и
        т.д. У каждого из этих классов определим метод draw для отображения соответствующего
        примитива на экране.
    </p>
    <p>Очевидно, придется написать код, который при необходимости ото­бразить
        рисунок будет последовательно перебирать все примитивы, на момент отрисовки
        находящиеся на экране, и вызывать метод draw у каж­дого из них. Человек, незнакомый с
        полиморфизмом, вероятнее всего,
        создаст несколько массивов (отдельный массив для каждого типа прими­тивов) и
        напишет код, который последовательно переберет элементы из каждого массива и
        вызовет у каждого элемента метод draw. В результате
        получится примерно следующий код:
    </p>
    <p>
    </p>
    <p>//создание пустого массива, который может содержать //объекты Pointe максимальным
        объемом 1000 Point[] р = new Point[1000];
    </p>
    <p>Line[] I   = new Line[ 1000]; Circlef] c= new
        Circle[1000]; Box[]b = new Box[1000];
    </p>
    <p>
    </p>
    <p>//предположим, в этом
        месте происходит заполнение
    </p>
    <p>// всех массивов
        соответствующими объектами
    </p>
    <p>
    </p>
    <p>1ог(Ы \ = 0;\&lt;
        р.\епдт;\++) { //цикл с перебором
        всех ячеек массива.
    </p>
    <p>//вызов метода draw() в случае,
    </p>
    <p>// если ячейка не пустая.
    </p>
    <p>1т(р[1]!=пШ1) p.draw();
    </p>
    <p>}
    </p>
    <p>тогО'т I = 0; |" &lt; 1.1епдтх1;1++) {
        1т(1[1]!=пи11) 1.с1гауу();
    </p>
    <p>}
    </p>
    <p>1ог(\Ш \-0;\&lt;
        с.1епд№;1++)
        { №(с[1]!=пи11)
        c.draw();
    </p>
    <p>}
    </p>
    <p>1ог(\п\. I = 0; 1
        &lt; Ь.1епдтп;!++)
        { |т(Ь[ф=пи11)
        b.draw();
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Недостатком написанного выше кода является дублирование практи­чески
        идентичного кода для отображения каждого типа примитивов. Также неудобно то, что
        при дальнейшей модернизации нашего графического ре­дактора и добавлении
        возможности рисовать новые типы графических примитивов, например Text, Star и т
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>д., при таком подходе придется менять существующий код и добавлять в
        него определения новых массивов, а так­же обработку содержащихся в них
        элементов.
    </p>
    <p>Используя полиморфизм, мы можем значительно упростить реали­зацию
        подобной функциональности. Прежде всего, создадим общий ро­дительский класс для
        всех наших классов. Пусть таким классом будет Point. В результате
        получим иерархию классов, которая изображена на рисунке 2.3.
    </p>
    <p>У каждого из дочерних классов метод draw переопределен таким об­разом, чтобы отображать
        экземпляры каждого класса
        соответствующим образом.
    </p>
    <p>Для описанной выше иерархии классов, используя полиморфизм, можно
        написать следующий код:
    </p>
    <p>
    </p>
    <p>Point р[] = new Point[
        1000]; Р[0] = new Circle();
    </p>
    <p>курс
    </p>
    <p>Программирование
        на Java
    </p>
    <p>Лекция
        2_____________________ Основы
        объектно-ориентированного программирования
    </p>
    <p>
    </p>
    <p>р[1] = new Point(); р[2] = new Вох(); р[3] = new Une();
    </p>
    <p>for(int i = 0; i &lt; p.length;i++) { if(p[i]!=null) p.draw();
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>В описанном выше примере массив р[] может содержать любые объ­екты, порожденные от
        наследников класса Point. При вызове какого-либо метода у любого из элементов этого массива
        будет
        выполнен метод того объекта, который содержится в ячейке массива. Например,
        если в ячейке р[0] находится объект Circle, то при вызове метода draw следующим образом:
    </p>
    <p>
    </p>
    <p>p[0].draw()
    </p>
    <p>нарисуется круг, а не точка.
    </p>
    <p>В заключение приведем
        формальное определение полиморфизма.
    </p>
    <p>Полиморфизм (polymorphism) - положение теории типов, согласно которому имена (например,
        переменных) могут обозначать объекты раз­ных (но имеющих общего родителя)
        классов. Следовательно, любой объ­ект, обозначаемый полиморфным именем, может
        по-своему реагировать на некий общий набор операций [2].
    </p>
    <p>
    </p>
    <table cellpadding="0" cellspacing="0">
        <tr>
            <td height="0" width="31"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <center><img height="205" src="http://kufas.ru/java.files/image009.png" width="398">
                </center>
            </td>
        </tr>
    </table>
    В процедурном программировании тоже существует понятие
    полимор­физма, которое отличается от рассмотренного механизма в ООП. Процедур­ный
    полиморфизм предполагает возможность создания нескольких проце­дур или функций
    с одним и тем же именем, но разным количеством или раз­личными типами
    передаваемых параметров. Такие одноименные функции называются перегруженными, а
    само явление - перегрузкой (overloading). Перегрузка функций существует и в ООП и называется
    перегрузкой методов.
    <p>Примером использования перегрузки
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p>методов в языке Java может служить класс
        PrinrWriter, который применяется, в частности, для вывода сообщений на консоль. Этот
        класс имеет множество методов printin, ко­торые различаются типами и/или количеством входных
        параметров. Вот
        лишь несколько из них:
    </p>
    <p>void printlnO                           //
        переход на новую строку
    </p>
    <p>void println(boolean х)   // выводит значение
        булевской
    </p>
    <p>// переменной (true или false) void println(String х)    
        // выводит строку - значение
    </p>
    <p>//текстового
        параметра.
    </p>
    <p>Определенные сложности возникают при вызове перегруженных методов. В Java существуют
        специальные правила, которые позволяют решать эту проблему. Они будут
        рассмотрены в соответствующей лекции.
    </p>
    <p>
    </p>
    <p>Типы отношений между классами
    </p>
    <p>Как правило, любая программа, написанная на объектно-ориенти­рованном
        языке, представляет собой некоторый набор связанных между собой классов. Можно
        провести аналогию между написанием программы и строительством дома. Подобно
        тому, как стена складывается из кирпичей, компьютерная программа с
        использованием ООП строится из классов. Причем эти классы должны иметь
        представление друг о друге, для того что­бы сообща выполнять
        поставленную задачу.
    </p>
    <p>Возможны следующие связи между классами в рамках объектной модели
        (приводятся лишь наиболее простые и часто используемые виды связей, подробное
        их рассмотрение выходит за рамки этой ознакомитель­ной лекции):
    </p>
    <p>•
        агрегация (Aggregation);
    </p>
    <p>•
        ассоциация (Association);
    </p>
    <p>•
        наследование (Inheritance);
    </p>
    <p>•
        метаклассы (Metaclass).
    </p>
    <p>
    </p>
    <p>Агрегация
    </p>
    <p>Отношение между классами типа "содержит" (contain) или "состоит из называется агрегацией, или
        включением. Например,
        если аквариум Наполнен водой и в нем плавают рыбки, то можно сказать, что аквариум
        агрегирует в
        себе воду и рыбок.
    </p>
    <p></p>
    <center><img border="0" height="72" src="http://kufas.ru/java.files/image010.jpg" width="397">
    </center>
    <p>Такое отношение включения, или агрегации (aggregation), изобража­ется линией с ромбиком на
        стороне того класса, который
        выступает в ка­честве владельца, или контейнера. Необязательное название
        отношения записывается посередине линии.
    </p>
    <p>В нашем примере отношение contain является
        двунаправленным. Объект класса Aquarium содержит несколько
        объектов Fish. В то же вре­мя каждая рыбка "знает", в каком именно аквариуме
        она живет. Каждый класс имеет свою роль в агрегации, которая указывает, какое
        место зани­мает класс в данном отношении. Имя роли не является обязательным
        элементом обозначений и может отсутствовать на диаграмме
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> В примере можно видеть роль home класса Aquarium (аквариум является домом
        для рыбок), а также роль inhabitants класса Fish (рыбки являются обитателя­ми
        аквариума). Название роли обычно совпадает с названием соответст­вующего поля в
        классе. Изображение такого поля на диаграмме излишне, если уже указано имя
        роли. Т.е. в данном случае класс Aquarium будет иметь свойство
        (поле) inhabitants, а класс Fish - свойство home.
    </p>
    <p>Число объектов, участвующих в отношении, записывается рядом с именем
        роли. Запись "0..п" означает "от нуля до бесконечности". Приняты также
        обозначения:
    </p>
    <p>• "1
        ..п" — от единицы до
        бесконечности;
    </p>
    <p>•
        "О" - ноль;
    </p>
    <p>• "
        1 " — один;
    </p>
    <p>• "п"
        — фиксированное
        количество;
    </p>
    <p>• "0..
        1 " — ноль или один.
    </p>
    <p>Код, описывающий рассмотренную модель и явление агрегации, может
        выглядеть, например, следующим образом:
    </p>
    <p>//
        определение класса Fish public class Fish {
    </p>
    <p>//
        определения поля home (ссылка на объект Aquarium)
    </p>
    <p>private Aquarium home;
    </p>
    <p>public Fish() { }
    </p>
    <p>}
    </p>
    <p>// определение класса Aquarium public class Aquarium {
    </p>
    <p>// определения поля inhabitants (массив ссылок на объекты Fish) private Fish inhabitants[];
        public Aquarium() { }
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Ассоциация
    </p>
    <p>Если объекты одного класса ссылаются на один или более объектов другого
        класса, но ни в ту, ни в другую сторону отношение между объек­тами не носит
        характера "владения", или контейнеризации, такое отно­шение называют
        ассоциацией (association). Отношение ассоциации изоб­ражается так же, как и отношение
        агрегации,
        но линия, связывающая классы,— простая, без ромбика.
    </p>
    <table cellpadding="0" cellspacing="0" height="14" hspace="0" vspace="0">
        <tr>
            <td align="left" height="14" valign="top">
                <p>Computer
                </p>
            </td>
        </tr>
    </table>
    <table cellpadding="0" cellspacing="0" height="14" hspace="0" vspace="0">
        <tr>
            <td align="left" height="14" valign="top">
                <p>Programmer
                </p>
            </td>
        </tr>
    </table>
    <p>В качестве примера можно рассмотреть программиста и его компью­тер. Между
        этими двумя объектами нет агрегации, но существует четкая взаимосвязь. Так,
        всегда можно установить, за какими компьютерами ра­ботает какой-либо
        программист, а также какие люди пользуются отдельно взятым компьютером. В рассмотренном
        примере имеет место ассоциация
        "многие-ко-многим".
    </p>
    <table cellpadding="0" cellspacing="0" height="14" hspace="0" vspace="0">
        <tr>
            <td align="left" height="14" valign="top">
                <p>Computerт
                </p>
            </td>
        </tr>
    </table>
    <table cellpadding="0" cellspacing="0" height="14" hspace="0" vspace="0">
        <tr>
            <td align="left" height="14" valign="top">
                <p>0..n
                </p>
            </td>
        </tr>
    </table>
    <p>-programmers   -computers
    </p>
    <p>Programmerт I 0 n
    </p>
    <p>
    </p>
    <p>В данном случае между экземплярами классов Programmer и Computer в обе стороны используется
        отношение "0..п", т.к. програм­мист, в принципе, может не работать с компьютером (если он
        теоретик Или на пенсии). В свою очередь, компьютер может никем не использовать­ся (если он
        новый и
        еще не установлен).
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Код, соответствующий рассмотренному примеру, будет, например, следующим:
    </p>
    <p>public class Programmer {
    </p>
    <p>private Computer computers[];
    </p>
    <p>public Programmerт {
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>public class Computer {
    </p>
    <p>private Programmer programmers[];
    </p>
    <p>public Computerт {
    </p>
    <p>}
    </p>
    <p>}
    </p>
    <p>
    </p>
    <p>Наследование
    </p>
    <p>Наследование является важным случаем отношений между двумя или более
        классами. Подробно оно рассматривалось выше.
    </p>
    <p>
    </p>
    <p>Метаклассы
    </p>
    <p>Итак, любой объект имеет структуру, состоящую из полей и методов.
        Объекты, имеющие одинаковую структуру и семантику, описываются од­ним классом,
        который и является, по сути, определением структуры объек­тов, порожденных от
        него.
    </p>
    <p>В свою очередь, каждый класс, или описание, всегда имеет строгий шаблон,
        задаваемый языком программирования или выбранной объект­ной моделью. Он
        определяет, например, допустимо ли множественное наследование, какие существуют
        ограничения на именование классов, как описываются поля и методы, набор
        существующих типов данных и многое другое. Таким образом, класс можно
        рассматривать как объект, у которого есть свойства (имя, список полей и их
        типы, список методов, список аргументов для каждого метода и т.д.). Также класс
        может обладать поведением, то есть поддерживать методы. А раз для любого
        объекта су­ществует шаблон, описывающий свойства и поведение этого объекта,
        значит, его можно определить и для класса. Такой шаблон, задающий раз­личные
        классы, называется метаклассом.
    </p>
    <p>Чтобы представить себе, что такое метакласс, рассмотрим пример не­кой
        бюрократической организации. Будем считать, что все классы в такой системе
        представляют собой строгие инструкции, которые описывают, что нужно сделать,
        чтобы породить новый объект (например, нанять нового служащего или открыть
        новый отдел). Как и полагается классам, они опи­сывают все свойства новых
        объектов (например, зарплату и профессио­нальный уровень для сотрудников,
        площадь и имущество для отделов) и их поведение (обязанности служащих и функции
        подразделений).
    </p>
    <p>В свою очередь,
        написание новой инструкции можно строго регла­ментировать. Скажем, необходимо
        использовать специальный бланк, при­держиваться правил оформления и заполнить
        все обязательные поля (на­пример, номер инструкции и фамилии ответственных
        работников). Такая "инструкция инструкций" и будет представлять собой
        метакласс в ООП.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>Итак, объекты порождаются от классов, а классы — от метакласса. Он, как
        правило, в системе только один. Но существуют языки програм­мирования, в
        которых можно создавать и использовать собственные мета­классы, например язык Python. В
        частности,
        функциональность мета­класса может быть следующая: при формировании класса он
        будет про­сматривать список всех методов в классе и, если имя метода имеет вид set_XXX или
        get_XXX, автоматически создавать поле с именем XXX, если такого не существует.
    </p>
    <p>Поскольку метакласс сам является классом, то нет никакого смысла в
        создании "мета-мета-классов".
    </p>
    <p>В языке Java также есть метакласс. Это класс, который так и называ­ется — Class (описывает
        классы),
        он располагается в основной библиоте­ке java.lang. Виртуальная машина использует его по
        прямому назначе­нию. Когда
        загружается очередной .class-файл, содержащий описание нового класса, JVM порождает объект
        класса Class, который будет хра­нить его структуру. Таким образом, Java использует
        концепцию метаклас­са в самых практических целях. С помощью Class реализована поддерж­ка
        статических (static) полей и методов. Наконец, этот класс содержит ряд методов, полезных
        для разработчиков. Они будут рассмотрены в сле­дующих лекциях.
    </p>
    <p>
    </p>
    <p>Достоинства ООП
    </p>
    <p>От любой методики разработки программного обеспечения мы ждем, что она
        поможет нам в решении наших задач. Но одной из самых Значительных проблем
        проектирования является сложность. Чем больше И сложнее программная
        система, тем важнее разбить ее на небольшие, четко очерченные части. Чтобы
        справиться со сложностью, необходимо абстрагироваться от деталей. В этом смысле
        классы представляют собой весьма удобный инструмент.
    </p>
    <p>•
        Классы позволяют проводить
        конструирование из полезных ком­понентов, обладающих простыми инструментами,
        что позволяет абстрагироваться от деталей реализации.
    </p>
    <p>•
        Данные и операции над ними
        образуют определенную сущность, и они не разносятся по всей программе, как
        нередко бывает в случае процедурного программирования, а описываются вместе.
        Локали­зация кода и данных улучшает наглядность и удобство сопровож­дения
        программного обеспечения.
    </p>
    <p>•
        Инкапсуляция позволяет
        привнести свойство модульности, что об­легчает распараллеливание выполнения
        задачи между несколькими исполнителями и обновление версий отдельных
        компонентов.
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p></p>
    <p>ООП дает возможность создавать расширяемые системы. Это одно Из основных достоинств
        ООП, и именно оно отличает данный подход от традиционных методов
        программирования. Расширяемость означает, что существующую систему можно
        заставить работать с новыми компонента­ми, причем без внесения в нее каких-либо
        изменений. Компоненты мо­гут быть добавлены на этапе исполнения программы.
    </p>
    <p>Полиморфизм оказывается полезным преимущественно в следую­щих ситуациях.
    </p>
    <p>•  Обработка разнородных
        структур данных.
    </p>
    <p>Программы могут
        работать, не различая вида объектов, что существен­но упрощает код. Новые виды
        могут быть добавлены в любой момент.
    </p>
    <p>•  Изменение поведения во
        время исполнения.
    </p>
    <p>На этапе исполнения
        один объект может быть заменен другим, что позволяет легко, без изменения кода,
        адаптировать алгоритм в за­висимости от того, какой используется объект.
    </p>
    <p>•  Реализация работы с
        наследниками.
    </p>
    <p>Алгоритмы можно
        обобщить настолько, что они уже смогут рабо­тать более чем с одним видом
        объектов.
    </p>
    <p>•  Создание
        "каркаса" (framework).
    </p>
    <p>Независимые от
        приложения части предметной области могут быть реализованы в виде набора
        универсальных классов, или каркаса (framework), и в дальнейшем расширены за счет добавле­ния
        частей, специфичных для
        конкретного приложения. Часто многоразового использования программного
        обеспечения не удается добиться из-за того, что существующие компоненты уже не
        отве­чают новым требованиям. ООП помогает этого достичь без нарушения работы
        уже имеющихся клиентов, что позволяет извлечь максимум из многоразового
        использования компонентов.
    </p>
    <p>•
        Сокращается время на
        разработку, которое может быть отдано дру­гим задачам.
    </p>
    <p>•
        Компоненты многоразового использования
        обычно содержат го­раздо меньше ошибок, чем вновь разработанные, ведь они уже
        не раз подвергались проверке.
    </p>
    <p>•
        Когда некий компонент
        используется сразу несколькими клиента­ми, улучшения, вносимые в его код,
        одновременно оказывают по­ложительное влияние и на множество работающих с ним
        программ.
    </p>
    <p>•   Если программа опирается на стандартные компоненты, ее структура и
        пользовательский интерфейс становятся более уни­фицированными, что облегчает ее
        понимание и упрощает ис­пользование.
    </p>
    <p>
    </p>
    <p>Недостатки ООП
    </p>
    <p>Документирование классов - задача более трудная, чем это было в слу­чае
        процедур и модулей
    </p>
    <center>
    </center>
</div>
<div class="left">
    <p></p>
    <p> Поскольку любой метод может быть переопреде­лен, в
        документации должно говориться не только о том, что делает данный метод, но и о
        том, в каком контексте он вызывается. Ведь переопределен­ные методы обычно
        вызываются не клиентом, а самим каркасом. Таким образом, программист должен
        знать, какие условия выполняются, когда вызывается данный метод. Для
        абстрактных методов, которые пусты, в документации должно говориться о том, для
        каких целей предполагается использовать переопределяемый метод.
    </p>
    <p>В сложных иерархиях классов поля и методы обычно наследуются с разных
        уровней. И не всегда легко определить, какие поля и методы фак­тически
        относятся к данному классу. Для получения такой информации нужны специальные
        инструменты, вроде навигаторов классов. Если кон­кретный класс расширяется, то
        каждый метод обычно сокращают перед передачей сообщения базовому классу.
        Реализация операции, таким об­разом, рассредоточивается по нескольким классам,
        и чтобы понять, как она работает, нам приходится внимательно просматривать весь
        код.
    </p>
    <p>Методы, как правило, короче процедур, поскольку они осуществляют только
        одну операцию над данными, зато их намного больше. В коротких методах легче
        разобраться, но они неудобны тем, что код для обработки со­общения иногда
        "размазан" по многим маленьким методам.
    </p>
    <p>Инкапсуляцией данных не следует злоупотреблять. Чем больше ло­гики и
        данных скрыто в недрах класса, тем сложнее его расширять. От­правной точкой
        здесь должно быть не то, что клиентам не разрешается знать о тех или иных
        данных, а то, что клиентам для работы с классом этих данных знать не требуется.
    </p>
    <p>Многие считают, что ООП является неэффективным. Как же обстоит де­ло в
        действительности? Мы должны проводить четкую грань между неэффек­тивностью на
        этапе выполнения, неэффективностью в смысле распределения памяти и
        неэффективностью, связанной с излишней универсализацией.
    </p>
    <p>1. Неэффективность на этапе выполнения. В языках типа Smalltalk со­общения
        интерпретируются во время выполнения программы путем осуществления их поиска в
        одной или нескольких таблицах и за счет выбора подходящего метода. Конечно, это
        медленный процесс. И да­же при использовании наилучших методов оптимизации
        Smalltalk-программы в десять раз медленнее оптимизированных С-программ. В
        гибридных языках типа Oberon-2, Object Pascal и С++ отправка
        сообщения приводит лишь к вызову через указатель процедурной переменной. На
        некоторых машинах сообщения выполняются лишь на 10% медленнее, чем обычные
        процедурные вызовы. И по­скольку сообщения встречаются в программе гораздо реже
        других операций, их воздействие на время выполнения влияния практи­чески не
        оказывает.
    </p>
    <p>Однако существует
        другой фактор, который влияет на время выпол­нения: это инкапсуляция данных.
        Рекомендуется не предоставлять прямой доступ к полям класса, а выполнять каждую
        операцию над данными через методы. Такая схема приводит к необходимости вы­полнения
        процедурного вызова каждый раз при доступе к данным. Однако если инкапсуляция
        используется только там, где она необ­ходима (т.е. в тех случаях, когда это
        становится преимуществом), то замедление вполне приемлемое.
    </p>
    <p>2.
        Неэффективность в смысле
        распределения памяти. Динамическое связывание и проверка типа на этапе
        выполнения требуют по ходу работы информации о типе объекта. Такая информация
        хранится в дескрипторе типа и он выделяется один на кл&amp;сс. Каждый объект
        имеет невидимый указатель на дескриптор типа для своего класса. Таким образом,
        в объектно-ориентированных программах необхо­димая дополнительная память выражается
        в одном указателе для объекта и в одном дескрипторе типа для класса.
    </p>
    <p>3.
        Излишняя универсальность.
        Неэффективность также может озна­чать, что в программе реализованы избыточные
        возможности. В библиотечном классе часто содержится больше методов, чем это
        реально необходимо. А поскольку лишние методы не могут быть удалены, они
        становятся мертвым грузом. Это не влияет на время выполнения, но сказывается на
        размере кода.
    </p>
    <p>Одно из возможных
        решений — строить базовый класс с минималь­ным числом методов, а затем уже
        реализовывать различные расши­рения этого класса, которые позволят нарастить
        функциональность. Другой подход — дать компоновщику возможность удалять лиш­ние
        методы. Такие интеллектуальные компоновщики уже сущест­вуют для различных
        языков и операционных систем. Но нельзя утверждать, что ООП неэффективно. Если
        классы исполь­зуются лишь там, где это действительно необходимо, то потеря
        эффектив­ности из-за повышенного расхода памяти и меньшей производительности
        незначительна. Кроме того, надежность программного обеспечения и быс­трота его
        написания часто бывает важнее, чем производительность.
    </p>
    <p>
    </p>
    <p>Заключение
    </p>
    <p>В этой лекции мы рассказали об объектно-ориентированном подхо­де к
        разработке ПО, а также о том, что послужило предпосылками к его появлению и
        сделало его популярным. Были рассмотрены ключевые по­нятия ООП - объект и
        класс. Далее были описаны основные свойства объектной модели - инкапсуляции,
        наследование, полиморфизм. Основ­ными видами отношений между классами являются
        наследование, ассоци­ация, агрегация, метакласс. Также были описаны правила
        изображения классов и связей между ними на языке ТЛМЬ.
    </p>
    <p>Вариант 1
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>1.      Почему объектно-ориентированное
        программирование
        пришло на смену процедурному программированию?
    </p>
    <p>&#9633;       программы,
        написанные с использованием ООП, выполняются на компьютере быстрее
    </p>
    <p>&#9633;       использование
        ООП позволяет создавать не зависящие от платформы программы
    </p>
    <p>&#9633;
        ООП позволяет уменьшить
        сложность создаваемого ПО
    </p>
    <p>&#9633;
        ООП позволяет увеличить
        надежность создаваемого ПО
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.       Что
        используется для описания поведения объекта?
    </p>
    <p>&#9633;        поля
        П   методы
    </p>
    <p>П   наследование
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.       Инкапсуляция
        - это:
    </p>
    <p>&#9633;       объединение
        данных и обрабатывающего
        их программного кода в одной логической структуре (классе)
    </p>
    <p>&#9633;       сокрытие
        реализации класса и отделение его внутреннего представления от внешнего
        интерфейса
    </p>
    <p>&#9633;       одно
        из базовых понятий ООП, которое позволяет расширять функциональность программы,
        не расширяя объектную модель этой программы
    </p>
    <p>
    </p>
    <table cellpadding="0" cellspacing="0">
        <tr>
            <td height="0" width="489"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <center><img height="269" src="http://kufas.ru/java.files/image011.png" width="437">
                </center>
            </td>
        </tr>
    </table>
    Вариант 2
    <p>
    </p>
    <p>
    </p>
    <p>1.       Что
        из перечисленного является классами,
        а что - объектами (отметьте классы):
    </p>
    <p>П      яблоко
    </p>
    <p>П      Иван
        Сидорович Петров
    </p>
    <p>П      легковой
        автомобиль
    </p>
    <p>&#9633;       страховое
        свидетельство №113-043-429-18
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>2.       Зачем
        нужен полиморфизм?
    </p>
    <p>П   полиморфизм
        используется для написания общего кода,
    </p>
    <p>который
        будет одинаково работать с разными типами данных (объектами разных классов),
        при условии, что классы, от которых созданы эти объекты, имеют общего предка
    </p>
    <p>П   полиморфизм
        позволяет создавать в одном классе несколько методов с одинаковыми именами, но
        с разным набором параметров
    </p>
    <p>П   полиморфизм
        необходим в любой программе, использующей ООП. Без него невозможно написать
        программу на объектноориентированном языке программирования
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>3.       Метакласс
        - это:
    </p>
    <p>П   базовый
        класс в дереве наследования. Все потомки этого класса расширяют или замещают
        его функциональность
    </p>
    <p>П   некоторый
        шаблон, который описывает свойства и поведение класса, подобно тому, как класс
        описывает свойства и поведение объекта
    </p>
    <p>П   класс,
        от которого наследуются все классы в дереве наследования. Любой из классов в
        программе обязательно является наследником этого класса (пример java.lang.Object)
    </p>
    <p>2.   Что из перечисленного является в классе «Лифт»
        внешним интерфейсом:
    </p>
    <p>&#9633; кнопки
        управления П    разводка проводов
    </p>
    <p>&#9633;
        реакция на нажатие какой-либо
        кнопки П                количество людей в лифте
    </p>
    <p>П   марка металла, из которого изготовлен
        трос
    </p>
    <p>
    </p>
    <p>3&gt;   Множественным наследованием
        называют:
    </p>
    <p>П   ситуацию, когда у некоторого класса
        есть более чем один непосредственный наследник
    </p>
    <p>О   наследование, в котором участвует
        множество классов (более двух)
    </p>
    <p>О   отношение наследования, при котором
        класс-наследник расширяет или дополняет функциональность нескольких базовых
        классов
    </p>
    <p>—==
    </p>
    <p>
    </p>
    <center>
    </center>
</div>

</body>
</html>
