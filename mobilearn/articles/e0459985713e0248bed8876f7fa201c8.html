<!DOCTYPE html>
<html>
<head>

    <title> Лекция 10. Понятие класса</title>
	<meta charset="utf-8">
	<link id="style" href="../style.css" rel="stylesheet"/>
	
	


    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
          name="viewport"/>



<script type="text/javascript" src="../script.js"></script>
</head>
<body>






<section id="l10_1">
    <h1>1. Понятие класса </h1>
    <p>
        Целью введения концепции классов в <span>C++</span> является предоставление программисту
        средств создания новых типов, которые настолько же удобны в использовании, как и встроенные.
        Кроме того, производные классы и шаблоны представляют способы организации классов, имеющих
        между собой нечто общее.
    </p>
    <p>
        Тип является конкретным представлением некоторой концепции. Например, встроенный тип <i>float</i>
        вместе с операциями +, –, * и т.д. представляет конкретное воплощение математической
        концепции вещественного числа.
    </p>
    <p>
        <b>Класс</b> – это определённый пользователем <i><b>тип</b></i>. Определение класса задаёт
        <i>представление объектов этого класса</i> и <i>набор операций</i>, которые можно применять
        к таким объектам. Класс обеспечивает абстракцию данных, он скрывает детали представления
        объекта и предоставляет доступ к содержащимся в нём данным только посредством функций и
        операций, описанных как часть этого класса.
    </p>
    <p>
        Основной смысл введения новых типов состоит в разделении малозначащих деталей реализации
        (например, расположения в памяти составных частей объектов данного типа) от свойств, имеющих
        определяющее значение для правильного использования сущности (например, полный набор функций
        доступа к данным). Подобное разделение лучше всего выражается в терминах ограничения доступа
        к данным извне и использования для этой цели специальных процедур в рамках четко
        определённого интерфейса.
    </p>
    <p>
        Тщательно подобранный набор типов, определяемых пользователем, делает программу более
        краткой и выразительной. Кроме того, такие типы дают возможность проведения разнообразного
        анализа кода. В частности, они позволяют компилятору обнаружить случаи недопустимого
        использования объектов, которые иначе не были бы выявлены вплоть до этапа тестирования.
    </p>
    <p id="l10_bando">
        Определение класса выглядит следующим образом:
        <span class="sint">
<b>class</b> &lt;<i>имя класса</i>&gt; { &lt;<i>список членов класса</i>&gt; };
</span>
    </p>
    <p id="l10_oggetto">
        Объявление класса является объявлением некоторого типа. Для дальнейшей работы необходимо
        объявлять соответствующие переменные или <b>объекты</b> класса.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">class</span> X { ... };
            </td>
            <td class="commenti">// Объявление типа <b><i>X</i></b></td>
        </tr>
        <tr>
            <td class="esempi">X x;</td>
            <td class="commenti">// Объявляем переменную <b>х</b> – объект класса (типа) <i>Х</i>
            </td>
        </tr>
    </table>
    <p>
        Объекты класса можно присваивать, передавать в качестве параметров функции и возвращать как
        её результат. Другие естественные операции, вроде проверки на равенство, также могут быть
        определены пользователем.
    </p></section>
<section id="l10_2">
    <h1> 2. Члены класса </h1>
    <p>
        В <i>списке членов класса</i> можно объявлять переменные, функции, классы, , а также . Член
        класса не может объявляться в списке членов класса дважды. Это относиться и к функциям (хотя
        могут быть функции с одним именем, но разным набором формальных параметров). Кроме того,
        нельзя объявить в классе переменную и функцию с одним именем. Список членов класса
        определяет полный набор членов этого класса. Нельзя добавлять к классу члены ещё в каком-то
        месте.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">class</span> X
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"> { <span class="chiavi">int</span> i;</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"><span class="chiavi">int</span> i;</td>
            <td class="commenti">// Ошибка – повторное объявление</td>
        </tr>
        <tr>
            <td class="esempi"> };</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">int</span> X::k;
            </td>
            <td class="commenti">// Ошибка – попытка объявить член класса вне объявления класса</td>
        </tr>
        <tr>
            <td class="esempi"><span class="chiavi">class</span> Y</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"> { <span class="chiavi">int</span> f();</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"><span class="chiavi">int</span> f();</td>
            <td class="commenti">// Ошибка – повторное объявление функции</td>

        </tr>
        <tr>
            <td class="esempi"><span class="chiavi">int</span> f(int x);</td>
            <td class="commenti">// Ошибок нет</td>
        </tr>
        <tr>
            <td class="esempi"> };</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">class</span> Z
            </td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"> { <span class="chiavi">int</span> f();</td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"><span class="chiavi">int</span> f;</td>
            <td class="commenti">// Ошибка – есть функция с таким же именем</td>
        </tr>
        <tr>
            <td class="esempi"> };</td>
            <td class="commenti"></td>
        </tr>
    </table>
    <p>
        Член класса не может иметь . Член класса не может быть объявлен со <i>auto</i>,
        <i>extern</i> и <i>register</i>. Инициализация объектов класса осуществляется с помощью .
        Объект класса не может содержать объект того же класса, но может содержать или на объект
        того же класса.
    </p>
    <p id="l10_scelta">
        Для доступа к членам класса (после объявления некоторой переменной этого класса или
        указателя на объект данного класса) используется следующий синтаксис:
        <span class="sint">
<i>&lt;переменная&gt; <b>.</b> &lt;имя члена класса&gt;
&lt;указатель&gt; <b>-&gt;</b> &lt;имя члена класса&gt;
</i></span>
    </p></section>
<section id="l10_3">
    <h1> 3. Доступ к членам класса </h1>
    <p>
        Управление доступом применяется единообразно к функциям-членам класса и данным-членам
        класса.
    </p>
    <p>
        Член класса может быть:
    </p>
    <ul>
        <li><b>приватным</b> (<span class="sint">private</span>) – это значит, что его имя может
            употребляться лишь внутри функций-членов класса и , в котором этот член класса объявлен;
        </li>
        <li><b>защищённым</b> (<span class="sint">protected</span>) – это значит, что его имя может
            употребляться лишь внутри функций-членов класса, этого класса и от него классов;
        </li>
        <li><b>публичным</b> (<span class="sint">public</span>) – это значит, что его имя может
            употребляться внутри любой функции (а также и вне функций в ).
        </li>
    </ul>
    <p>
        Модификаторы доступа можно использовать несколько раз в одном и том же объявлении класса.
    </p>
    <p>
        Механизмы управления доступом в <span>C++</span> обеспечивают защиту от случайного, а <b>не
        от преднамеренного</b> доступа. Однако это относится к проблемам <b>дисциплины</b>
        программирования, а не к проблемам языка.
    </p>
    <p>
        Члены класса без спецификатора доступа по умолчанию являются <b>приватными</b>. Члены и по
        умолчанию являются <b>публичными</b>.
    </p></section>
<section id="l10_4">
    <h1> 4. Функции-члены класса </h1>
    <p>
        Функция, объявленная в классе без спецификатора , называется <i>функцией-членом класса</i>.
        Её вызов имеет соответствующий синтаксис.
    </p>
    <p>
        Описание функции-члена класса относиться к области действия класса. Это означает, что
        функция-член класса может непосредственно использовать имена членов своего класса.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">class</span> X
                { <span class="chiavi">private</span>:
                <span class="chiavi">int</span> n;
                <span class="chiavi">public</span>:
                <span class="chiavi">void</span> f();
                };
            </td>

            <td class="commenti">// Объявление класса Х</td>
        </tr>
        <tr>
            <td class="esempi">
                <span class="chiavi">void</span> X::f()
                { n++; }
            </td>
            <td class="commenti">// Определение функции <i>f</i> из класса <i>Х</i></td>
        </tr>
        <tr>
            <td class="esempi">X a, b;</td>
            <td class="commenti">// Объявление переменных класса <i>Х</i></td>
        </tr>
        <tr>
            <td class="esempi">a.f();</td>

            <td class="commenti">// Вызов функции <i>f</i> применяется к переменной <b>а</b>. Таким
                образом,
                // изменяется член <i>n</i> переменной <b>a</b>. Переменная <b>b</b> остаётся без
                изменений.
            </td>
        </tr>
    </table>
    <h2 id="l10_4_1">4.1. Константные функции-члены класса </h2>
    <p>
        В объявлении функции после списка параметров можно добавить модификатор <i>const</i>. Это
        будет означать, что функция не меняет состояние объекта, к которому она применяется. Суффикс
        <i>const</i> является частью типа функции и должен записываться, когда функция определяется
        вне класса.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">class</span> X
                { <span class="chiavi">private</span>:
                <span class="chiavi">int</span> n;
                <span class="chiavi">public</span>:
                <span class="chiavi">int</span> f() <span class="chiavi">const</span>;
                };

                <span class="chiavi">int</span> X::f() <span class="chiavi">const</span></td>
            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"> { <span class="chiavi">return</span> n++; }</td>
            <td class="commenti">// Ошибка – попытка изменить значение члена класса в константной
                функции
            </td>
        </tr>
    </table>
    <p>
        Константную функцию-член класса можно вызвать как для константного, так и для неконстантного
        объекта, в то время как неконстантную функцию можно вызвать только для объекта, не
        являющегося константой.
    </p>
    <h2 id="l10_4_2">4.2. Указатель <i>this</i></h2>
    <p>
        В нестатической функции-члене класса ключевое слово <span class="sint">this</span>
        обозначает на объект, для которого вызвана данная функция, т.е. внутри функции-члена класса
        член того же класса с именем <i>х</i> можно обозначать как <span class="sint">x</span>, и
        как <span class="sint">this -&gt; x</span>. Указатель на объект, для которого вызвана
        функция, является неявным параметром этой функции.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">class</span> X
                { <span class="chiavi">private</span>:
                <span class="chiavi">int</span> n;
                <span class="chiavi">public</span>:
            </td>

            <td class="commenti"></td>
        </tr>
        <tr>
            <td class="esempi"><span class="chiavi">void</span> f(<span class="chiavi">int</span> n)
                { <span class="chiavi">this</span> -&gt; n = n; }
                };
            </td>

            <td class="commenti">// Члену класса <i>n</i> присваивается значение параметра <b>n</b>
            </td>
        </tr>
    </table>
    <p>
        Указатель <i>this</i> в функции-члене класса <i>Х</i> имеет тип
        <span><i>X * const</i></span>. Однако, это не обычная переменная, невозможно получить её
        адрес или присвоить ей что-нибудь. В константной функции-члене класса
        <span><i>Х this</i></span> имеет тип <i>const X * const</i> для предотвращения модификации
        самого объекта.
    </p>
    <p>
        В большинстве случаев использование <i>this</i> является неявным. В частности, каждое
        обращение к нестатическому члену класса неявно использует <i>this</i> для доступа к члену
        соответствующего объекта.
    </p>
    <p>
        Функции-члены класса могут также возвращать с помощью указателя <i>this</i> ссылку на объект
        класса для того, чтобы можно было использовать вызов функции как параметр другой функции.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">class</span> X
                { ...
                <span class="chiavi">public</span>:
                X&amp; f();
                };
                X&amp; X::f()
                { ...
                <span class="chiavi">return</span> *<span class="chiavi">this</span>;
                }
            </td>
        </tr>
    </table>
    <h2 id="l10_4_3"> 4.3. Встраиваемые функции-члены класса </h2>
    <p>
        Функция-член класса может быть описана внутри объявления класса. В этом случае она считается
        .
    </p>
    <p>
        <b>Пример.</b> В обоих случаях функция <i>GetSize</i> является встраиваемой.
    </p>
    <table>
        <tr>
            <td class="esempi">
                <span class="chiavi">class</span> Vector
                { <span class="chiavi">private:</span>
                <span class="chiavi">int</span> size;
                ...
                <span class="chiavi">public:</span>
                <span class="chiavi">int</span> GetSize() { <span class="chiavi"> return</span>
                size; }
                ...
                }
                <span class="chiavi">class</span> Vector
                { <span class="chiavi">private:</span>
                <span class="chiavi">int</span> size;
                ...
                <span class="chiavi">public:
    int</span> GetSize();
                ...
                }

                <span class="chiavi">inline int</span> Vector::GetSize() { <span class="chiavi"> return</span>
                size; }
            </td>
        </tr>
    </table>
</section>

</body>
</html>
